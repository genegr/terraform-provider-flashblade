// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package fb_sdk

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiTokenScopes            = "ApiToken.Scopes"
	AuthorizationHeaderScopes = "AuthorizationHeader.Scopes"
)

// ActiveDirectory defines model for ActiveDirectory.
type ActiveDirectory struct {
	// ComputerName The common name of the computer account to be created in the Active Directory
	// domain.
	// If not specified, defaults to the name of the Active Directory
	// configuration.
	ComputerName *string `json:"computer_name,omitempty"`

	// DirectoryServers A list of directory servers that will be used for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name with optional @domain suffix.
	// If the suffix is ommited, the joined domain is assumed.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	DirectoryServers *[]string `json:"directory_servers,omitempty"`

	// Domain The Active Directory domain to join.
	Domain *string `json:"domain,omitempty"`

	// EncryptionTypes The encryption types that are supported for use by clients for Kerberos
	// authentication.
	EncryptionTypes *[]string `json:"encryption_types,omitempty"`

	// GlobalCatalogServers A list of global catalog servers that will be used
	// for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name with optional @domain suffix.
	// If the suffix is ommited, the joined domain is assumed.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	GlobalCatalogServers *[]string `json:"global_catalog_servers,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// JoinOu The relative distinguished name of the organizational unit in which the
	// computer account was created when joining the domain.
	JoinOu *string `json:"join_ou,omitempty"`

	// KerberosServers A list of key distribution servers to use for Kerberos protocol.
	// Accepted server formats are IP address and DNS name.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS.
	KerberosServers *[]string `json:"kerberos_servers,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Server The server containing this active directory account.
	Server *FixedReference `json:"server,omitempty"`

	// ServicePrincipalNames A list of service principal names registered for the machine account,
	// which can be used for the creation of keys for Kerberos authentication.
	ServicePrincipalNames *[]string `json:"service_principal_names,omitempty"`
}

// ActiveDirectoryDirectoryServers defines model for ActiveDirectoryDirectoryServers.
type ActiveDirectoryDirectoryServers struct {
	// DirectoryServers A list of directory servers that will be used for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name with optional @domain suffix.
	// If the suffix is ommited, the joined domain is assumed.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	// The specified list can have a maximum length of 50.
	DirectoryServers *[]string `json:"directory_servers,omitempty"`

	// GlobalCatalogServers A list of global catalog servers that will be used for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name with optional @domain suffix.
	// If the suffix is ommited, the joined domain is assumed.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	// The specified list can have a maximum length of 50.
	GlobalCatalogServers *[]string `json:"global_catalog_servers,omitempty"`
}

// ActiveDirectoryGetResponse defines model for ActiveDirectoryGetResponse.
type ActiveDirectoryGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of Active Directory computer account configuration objects.
	Items *[]ActiveDirectory `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ActiveDirectoryPatch defines model for ActiveDirectoryPatch.
type ActiveDirectoryPatch struct {
	// DirectoryServers A list of directory servers that will be used for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	// If not specified, servers are resolved for the domain in DNS.
	// The specified list can have a maximum length of 5.
	DirectoryServers *[]string `json:"directory_servers,omitempty"`

	// EncryptionTypes The encryption types that will be supported for use by clients for Kerberos
	// authentication.
	// Valid values include `aes256-cts-hmac-sha1-96`, `aes128-cts-hmac-sha1-96`, and
	// `arcfour-hmac`.
	EncryptionTypes *[]string `json:"encryption_types,omitempty"`

	// Fqdns A list of fully qualified domain names to use to register service principal
	// names for the machine account. If specified, every service principal that
	// is supported by the array will be registered for each fully qualified domain
	// name specified. If neither `fqdns` nor `service_principal_names` is specified,
	// the default `service_principal_names` are constructed using
	// the `computer_name` and `domain` fields.
	// Cannot be provided in combination with `service_principal_names`.
	Fqdns *[]string `json:"fqdns,omitempty"`

	// GlobalCatalogServers A list of global catalog servers that will be used for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name with optional @domain suffix.
	// If the suffix is ommited, the joined domain is assumed.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	// The specified list can have a maximum length of 50.
	GlobalCatalogServers *[]string `json:"global_catalog_servers,omitempty"`

	// JoinOu The relative distinguished name of the organizational unit in which the
	// computer account should be created when joining the domain.
	JoinOu *string `json:"join_ou,omitempty"`

	// KerberosServers A list of key distribution servers to use for Kerberos protocol.
	// Accepted server formats are IP address and DNS name.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS.
	// If not specified, servers are resolved for the domain in DNS.
	// The specified list can have a maximum length of 5.
	KerberosServers *[]string `json:"kerberos_servers,omitempty"`

	// ServicePrincipalNames A list of service principal names to register for the machine account,
	// which can be used for the creation of keys for Kerberos authentication.
	// If neither `service_principal_names` nor `fqdns` is specified,
	// the default `service_principal_names` are constructed using
	// the `computer_name` and `domain` fields.
	// Cannot be provided in combination with `fqdns`.
	ServicePrincipalNames *[]string `json:"service_principal_names,omitempty"`
}

// ActiveDirectoryPost defines model for ActiveDirectoryPost.
type ActiveDirectoryPost struct {
	// ComputerName The common name of the computer account to be created in the Active Directory
	// domain.
	// If not specified, defaults to the name of the Active Directory
	// configuration.
	ComputerName *string `json:"computer_name,omitempty"`

	// DirectoryServers A list of directory servers that will be used for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	// If not specified, servers are resolved for the domain in DNS.
	// The specified list can have a maximum length of 5.
	DirectoryServers *[]string `json:"directory_servers,omitempty"`

	// Domain The Active Directory domain to join.
	Domain string `json:"domain"`

	// EncryptionTypes The encryption types that will be supported for use by clients for Kerberos
	// authentication.
	// Defaults to `aes256-cts-hmac-sha1-96`.
	// Valid values include `aes256-cts-hmac-sha1-96`, `aes128-cts-hmac-sha1-96`, and
	// `arcfour-hmac`.
	// Cannot be provided if using an existing machine account.
	EncryptionTypes *[]string `json:"encryption_types,omitempty"`

	// Fqdns A list of fully qualified domain names to use to register service principal
	// names for the machine account. If specified, every service principal that
	// is supported by the array will be registered for each fully qualified domain
	// name specified. If neither `fqdns` nor `service_principal_names` is specified,
	// the default `service_principal_names` are constructed using
	// the `computer_name` and `domain` fields.
	// Cannot be provided in combination with `service_principal_names`.
	// Cannot be provided if using an existing machine account.
	Fqdns *[]string `json:"fqdns,omitempty"`

	// GlobalCatalogServers A list of global catalog servers that will be used for lookups related to user authorization.
	// Accepted server formats are IP address and DNS name with optional @domain suffix.
	// If the suffix is ommited, the joined domain is assumed.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS and will only be communicated with over the secure LDAP (LDAPS) protocol.
	// The specified list can have a maximum length of 50.
	GlobalCatalogServers *[]string `json:"global_catalog_servers,omitempty"`

	// JoinOu The relative distinguished name of the organizational unit in which the
	// computer account should be created when joining the domain.
	// Cannot be provided if using an existing machine account.
	// If not specified, defaults to `CN=Computers`.
	JoinOu *string `json:"join_ou,omitempty"`

	// KerberosServers A list of key distribution servers to use for Kerberos protocol.
	// Accepted server formats are IP address and DNS name.
	// All specified servers must be registered to the domain appropriately in the array's
	// configured DNS.
	// If not specified, servers are resolved for the domain in DNS.
	// The specified list can have a maximum length of 5.
	KerberosServers *[]string `json:"kerberos_servers,omitempty"`

	// Password The login password of the user with privileges to create the computer account
	// in the domain. If using an existing computer account, the user must have privileges to
	// read attributes from the computer account and reset the password on that account.
	// This is not persisted on the array.
	Password string `json:"password"`

	// ServicePrincipalNames A list of service principal names to register for the machine account,
	// which can be used for the creation of keys for Kerberos authentication.
	// If neither `service_principal_names` nor `fqdns` is specified,
	// the default `service_principal_names` are constructed using
	// the `computer_name` and `domain` fields.
	// Cannot be provided in combination with `fqdns`.
	// Cannot be provided if using an existing machine account.
	ServicePrincipalNames *[]string `json:"service_principal_names,omitempty"`

	// User The login name of the user with privileges to create the computer account in
	// the domain. If using an existing computer account, the user must have privileges to
	// read attributes from the computer account and reset the password on that account.
	// This is not persisted on the array.
	User string `json:"user"`
}

// ActiveDirectoryResponse defines model for ActiveDirectoryResponse.
type ActiveDirectoryResponse struct {
	// Items A list of Active Directory computer account configuration objects.
	Items *[]ActiveDirectory `json:"items,omitempty"`
}

// Admin defines model for Admin.
type Admin struct {
	// ApiToken API token
	ApiToken *ApiToken `json:"api_token,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Returns a value of `true` if the user is local to the machine, otherwise `false`.
	IsLocal *bool `json:"is_local,omitempty"`

	// Locked Returns a value of `true` if the user is currently locked out, otherwise `false`.
	// Can be patched to false to unlock a user. This field is only visible to `array_admin` roles.
	// For all other users, the value is always `null`.
	Locked *bool `json:"locked,omitempty"`

	// LockoutRemaining The remaining lockout period, in milliseconds, if the user is locked out.
	// This field is only visible to `array_admin` roles.
	// For all other users, the value is always `null`.
	LockoutRemaining *int64 `json:"lockout_remaining,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PublicKey Public key for SSH access. Supported key types are `Ed25519` and `RSA`.
	PublicKey *string `json:"public_key,omitempty"`

	// Role A reference to this administrator's management role.
	Role *Reference `json:"role,omitempty"`
}

// AdminApiToken defines model for AdminApiToken.
type AdminApiToken struct {
	// Admin A reference to the admin to whom this token belongs.
	Admin    *Reference `json:"admin,omitempty"`
	ApiToken *ApiToken  `json:"api_token,omitempty"`
}

// AdminApiTokenGetResponse defines model for AdminApiTokenGetResponse.
type AdminApiTokenGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of administrator API tokens.
	Items *[]AdminApiToken `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AdminApiTokenResponse defines model for AdminApiTokenResponse.
type AdminApiTokenResponse struct {
	// Items A list of administrator API tokens.
	Items *[]AdminApiToken `json:"items,omitempty"`
}

// AdminCache defines model for AdminCache.
type AdminCache struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Role A reference to the `role` of this user.
	Role *FixedReference `json:"role,omitempty"`

	// Time Time the role was cached in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`
}

// AdminCacheGetResponse defines model for AdminCacheGetResponse.
type AdminCacheGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of admin cache entries.
	Items *[]AdminCache `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AdminGetResponse defines model for AdminGetResponse.
type AdminGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of administrative account objects.
	Items *[]Admin `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AdminPatch defines model for AdminPatch.
type AdminPatch struct {
	// Locked If set to `false`, the specified user is unlocked.
	// Setting to `true` is not allowed.
	Locked *bool `json:"locked,omitempty"`

	// OldPassword Old user password.
	OldPassword *string `json:"old_password,omitempty"`

	// Password New user password.
	Password *string `json:"password,omitempty"`

	// PublicKey Public key for SSH access. Supported key types are `Ed25519` and `RSA`.
	PublicKey *string `json:"public_key,omitempty"`

	// Role A reference to this administrator's management role. This may only be modified for
	// non-built-in users for whom `is_local` is `true`.
	Role *ReferenceWritable `json:"role,omitempty"`
}

// AdminPost An administrative user, who has rights to login and manage the array in some capacity.
type AdminPost struct {
	// Password New user password.
	Password *string `json:"password,omitempty"`

	// PublicKey Public key for SSH access. Supported key types include `Ed25519` and `RSA`.
	PublicKey *string `json:"public_key,omitempty"`

	// Role A reference to this administrator's management role.
	Role *ReferenceWritable `json:"role,omitempty"`
}

// AdminResponse defines model for AdminResponse.
type AdminResponse struct {
	// Items A list of administrative account objects.
	Items *[]Admin `json:"items,omitempty"`
}

// AdminSetting defines model for AdminSetting.
type AdminSetting struct {
	// LockoutDuration The lockout duration, in milliseconds, if a user has reached the
	// maximum number of login attempts. Ranges from 1 second to 90 days.
	// Default value is `null`. Use 0 to reset the value to `null`.
	LockoutDuration *int64 `json:"lockout_duration,omitempty"`

	// MaxLoginAttempts The maximum number of failed login attempts allowed before the user is locked out.
	// Default value is `null`. Use 0 to reset the value to `null`.
	MaxLoginAttempts *int32 `json:"max_login_attempts,omitempty"`

	// MinPasswordLength The minimum password length. If not specified, defaults to 1 character.
	MinPasswordLength *int32 `json:"min_password_length,omitempty"`
}

// AdminSettingsGetResponse defines model for AdminSettingsGetResponse.
type AdminSettingsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items Returns global admin settings.
	Items *[]AdminSetting `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AdminSettingsResponse defines model for AdminSettingsResponse.
type AdminSettingsResponse struct {
	// Items Returns global admin settings.
	Items *[]AdminSetting `json:"items,omitempty"`
}

// Alert defines model for Alert.
type Alert struct {
	// Action The action of the alert.
	Action *string `json:"action,omitempty"`

	// Code Alert code.
	Code *int64 `json:"code,omitempty"`

	// ComponentName The component name of the alert.
	ComponentName *string `json:"component_name,omitempty"`

	// ComponentType The component type of the alert.
	ComponentType *string `json:"component_type,omitempty"`

	// Created The creation timestamp of the alert.
	Created *int64 `json:"created,omitempty"`

	// Description The description of the alert.
	Description *string `json:"description,omitempty"`

	// Flagged Flagged state of the alert.
	Flagged *bool `json:"flagged,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The unique index of the alert.
	Index *int64 `json:"index,omitempty"`

	// KnowledgeBaseUrl URL of the relevant Knowledge Base page.
	KnowledgeBaseUrl *string `json:"knowledge_base_url,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Notified The last notification timestamp of the alert.
	Notified *int64 `json:"notified,omitempty"`

	// Severity Severity of the alert.
	// Valid values are `info`, `warning`, and `critical`.
	Severity *string `json:"severity,omitempty"`

	// State The current state of the alert.
	// Valid values are `open`, `closing`, `closed`, and
	// `waiting to downgrade`.
	State *string `json:"state,omitempty"`

	// Summary The summary of the alert.
	Summary *string `json:"summary,omitempty"`

	// Updated The last updated timestamp of the alert.
	Updated *int64 `json:"updated,omitempty"`

	// Variables Key-value pairs of additional information of the alert.
	Variables *map[string]string `json:"variables,omitempty"`
}

// AlertGetResponse defines model for AlertGetResponse.
type AlertGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of alert objects.
	Items *[]Alert `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AlertResponse defines model for AlertResponse.
type AlertResponse struct {
	// Items A list of alert objects.
	Items *[]Alert `json:"items,omitempty"`
}

// AlertWatcher defines model for AlertWatcher.
type AlertWatcher struct {
	// Enabled Is email notification enabled? If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// MinimumNotificationSeverity The minimum severity that an alert must have in order for emails to
	// be sent to the watcher.
	// Possible values include `info`, `warning`, and `critical`.
	MinimumNotificationSeverity *string `json:"minimum_notification_severity,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// AlertWatcherGetResponse defines model for AlertWatcherGetResponse.
type AlertWatcherGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of alert watcher objects.
	Items *[]AlertWatcher `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AlertWatcherPost defines model for AlertWatcherPost.
type AlertWatcherPost struct {
	// MinimumNotificationSeverity The minimum severity that an alert must have in order for emails to
	// be sent to the watcher.
	// Possible values include `info`, `warning`, and `critical`.
	// If not specified, defaults to `info`.
	MinimumNotificationSeverity *string `json:"minimum_notification_severity,omitempty"`
}

// AlertWatcherResponse defines model for AlertWatcherResponse.
type AlertWatcherResponse struct {
	// Items A list of alert watcher objects.
	Items *[]AlertWatcher `json:"items,omitempty"`
}

// ApiClient defines model for ApiClient.
type ApiClient struct {
	// AccessTokenTtlInMs The TTL (Time To Live) duration for which the exchanged access token is valid.
	// Measured in milliseconds.
	AccessTokenTtlInMs *int64 `json:"access_token_ttl_in_ms,omitempty"`

	// Enabled If `true`, the API client is permitted to exchange ID Tokens for access tokens.
	// API clients are disabled by default.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Issuer The name of the identity provider that will be issuing ID Tokens for this API client.
	// This string represents the JWT `iss` (issuer) claim in ID Tokens issued for this API client.
	Issuer *string `json:"issuer,omitempty"`

	// KeyId The unique identifier for the associated public key of this API client.
	// This string must match the JWT `kid` (key ID) claim in ID Tokens issued for this API client.
	KeyId *string `json:"key_id,omitempty"`

	// MaxRole The maximum role allowed for ID Tokens issued by this API client.
	// The bearer of an access token will be authorized to perform actions
	// within the intersection of this `max_role` and the role of the array
	// user specified as the JWT `sub` (subject) claim.
	// The `max_role` field is a reference to a `role`.
	// Valid `role`s are `readonly`, `ops_admin`, `array_admin`, and `storage_admin`.
	// Users with the `readonly` (Read Only) role can perform operations that convey the
	// state of the array. Read Only users cannot alter the state of the array.
	// Users with the `ops_admin` (Ops Admin) role can perform the same operations as
	// Read Only users plus enable and disable remote assistance sessions. Ops Admin users cannot
	// alter the state of the array.
	// Users with the `storage_admin` (Storage Admin) role can perform the same
	// operations as Read Only users plus storage related operations, such as administering file
	// systems, snapshots, and buckets.
	// Storage Admin users cannot perform operations that deal with global and system
	// configurations.
	// Users with the `array_admin` (Array Admin) role can perform the same
	// operations as Storage Admin users plus array-wide changes dealing with global and system
	// configurations. In other words, Array Admin users can perform all operations.
	MaxRole *FixedReference `json:"max_role,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PublicKey The API client's PEM formatted (Base64 encoded) RSA public key.
	PublicKey *string `json:"public_key,omitempty"`
}

// ApiClientsPost defines model for ApiClientsPost.
type ApiClientsPost struct {
	// AccessTokenTtlInMs The TTL (Time To Live) duration for which the exchanged access token is valid.
	// Measured in milliseconds. If not specified, defaults to `86400000`.
	AccessTokenTtlInMs *int64 `json:"access_token_ttl_in_ms,omitempty"`

	// Issuer The name of the identity provider that will be issuing ID Tokens for this API client.
	// The `iss` claim in the JWT issued must match this string.
	// If not specified, defaults to the API client name.
	Issuer *string `json:"issuer,omitempty"`

	// MaxRole The maximum role allowed for ID Tokens issued by this API client.
	// The bearer of an access token will be authorized to perform actions
	// within the intersection of this `max_role` and the role of the array
	// user specified as the JWT `sub` (subject) claim.
	// The `max_role` field is a reference to a `role`.
	// Valid `role`s are `readonly`, `ops_admin`, `array_admin`, and `storage_admin`.
	// Users with the `readonly` (Read Only) role can perform operations that convey the
	// state of the array. Read Only users cannot alter the state of the array.
	// Users with the `ops_admin` (Ops Admin) role can perform the same operations as
	// Read Only users plus enable and disable remote assistance sessions. Ops Admin users cannot
	// alter the state of the array.
	// Users with the `storage_admin` (Storage Admin) role can perform the same
	// operations as Read Only users plus storage related operations, such as administering volumes,
	// hosts, and host groups.
	// Storage Admin users cannot perform operations that deal with global and system configurations.
	// Users with the `array_admin` (Array Admin) role can perform the same
	// operations as Storage Admin users plus array-wide changes dealing with global and system
	// configurations. In other words, Array Admin users can perform all operations.
	MaxRole ReferenceWritable `json:"max_role"`

	// PublicKey The API client's PEM formatted (Base64 encoded) RSA public key.
	// It must include the `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----` lines.
	PublicKey string `json:"public_key"`
}

// ApiClientsResponse defines model for ApiClientsResponse.
type ApiClientsResponse struct {
	Items *[]ApiClient `json:"items,omitempty"`
}

// ApiVersion defines model for Api_version.
type ApiVersion struct {
	// Versions A list of supported API versions.
	Versions *[]string `json:"versions,omitempty"`
}

// Array defines model for Array.
type Array struct {
	// AsOf Array time in milliseconds since UNIX epoch.
	AsOf *int64 `json:"_as_of,omitempty"`

	// Banner A string to be shown when logging in to the array.
	Banner *string `json:"banner,omitempty"`

	// DefaultInboundTlsPolicy The default TLS policy governing inbound traffic from clients accessing the array.
	// This TLS policy will be applied for any IP addresses on the system that do not
	// have a specific policy applied to them at a more granular level.
	DefaultInboundTlsPolicy *ReferenceWritable      `json:"default_inbound_tls_policy,omitempty"`
	Encryption              *ArrayEncryption        `json:"encryption,omitempty"`
	EradicationConfig       *ArrayEradicationConfig `json:"eradication_config,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IdleTimeout Idle timeout in milliseconds. Valid values are
	// in the range of 300000 and 10800000. Setting this value to 0
	// disables timeouts.
	IdleTimeout *int32 `json:"idle_timeout,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// NetworkAccessPolicy The network access policy governing which clients are allowed or denied access to different
	// array interfaces.
	NetworkAccessPolicy *FixedReference `json:"network_access_policy,omitempty"`
	NtpServers          *[]string       `json:"ntp_servers,omitempty"`

	// Os Valid values are `Purity//FA` and `Purity//FB`.
	Os *string `json:"os,omitempty"`

	// ProductType For `FlashBlade//S` arrays, the value is determined by the blades in the system.
	// The value will be `FlashBlade` for all older arrays.
	// Valid values are `FlashBlade`, `FlashBlade//S`, `FlashBlade//S200`, and `FlashBladeS500`.
	ProductType *string `json:"product_type,omitempty"`
	Revision    *string `json:"revision,omitempty"`

	// SecurityUpdate The name of the installed security update that currently applies to the system.
	// This field will be `null` if either no security update has been installed, or if the
	// most recently installed security update is no longer needed by the current
	// FlashBlade software due to the current software fully incorporating the update.
	SecurityUpdate *string `json:"security_update,omitempty"`

	// SmbMode The current SMB mode of the array.
	// This controls the type of authentication that is used by the array for SMB.
	// Possible values include `ad-auto`, `ad-rfc2307`, `guest`, and `native`.
	// Modifying this value requires the assistance of Pure Storage Support.
	SmbMode *string `json:"smb_mode,omitempty"`

	// TimeZone The time zone to use for the array. In particular this affects
	// the CLI formatting and the default snapshot policy time zone.
	TimeZone *string `json:"time_zone,omitempty"`
	Version  *string `json:"version,omitempty"`
}

// ArrayConnection defines model for ArrayConnection.
type ArrayConnection struct {
	// CaCertificateGroup The group of CA certificates that can be used, in addition to
	// well-known Certificate Authority certificates, in order to
	// establish a secure connection to the target array.
	// Defaults to a reference to the `_default_replication_certs` group
	// if `secure_connection` is `true`, or `null` otherwise.
	CaCertificateGroup *FixedReference `json:"ca_certificate_group,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Encrypted If this is set to `true`, then all customer data replicated over
	// the connection will be sent over an encrypted connection using TLS,
	// or will not be sent if a secure connection cannot be
	// established.
	// If this is set to `false`, then all customer data replicated over
	// the connection will be sent over an unencrypted connection.
	// Defaults to `false`.
	Encrypted *bool `json:"encrypted,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// ManagementAddress Management address of the target array. Settable on POST only.
	ManagementAddress *string `json:"management_address,omitempty"`

	// Os The operating system of the connected array.
	Os *string `json:"os,omitempty"`

	// Remote The remote array.
	Remote *FixedReference `json:"remote,omitempty"`

	// ReplicationAddresses IP addresses and/or FQDNs of the target arrays. Settable on POST only.
	// If not set on POST, will be set to all the replication addresses
	// available on the target array at the time of the POST.
	ReplicationAddresses *[]string `json:"replication_addresses,omitempty"`

	// Status Status of the connection.
	// Valid values include `connected`, `partially_connected`, `connecting`,
	// and `incompatible`.
	// `connected` - The connection is OK.
	// `partially_connected` - Some replication addresses are working,
	// but others are not.
	// `connecting` - No connection exists and the array is trying to
	// reconnect.
	// `incompatible` - The target array is not compatible.
	Status *string `json:"status,omitempty"`

	// Throttle The bandwidth throttling for an array connection or target.
	Throttle *Throttle `json:"throttle,omitempty"`

	// Type The type of connection. Valid values include `async-replication` and `fleet-management`.
	Type *string `json:"type,omitempty"`

	// Version The version of the target array.
	Version *string `json:"version,omitempty"`
}

// ArrayConnectionGetResponse defines model for ArrayConnectionGetResponse.
type ArrayConnectionGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]ArrayConnection            `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayConnectionKey defines model for ArrayConnectionKey.
type ArrayConnectionKey struct {
	// ConnectionKey Connection-key, used on another array to connect to this array.
	// After creation, listing will only show ****.
	ConnectionKey *string `json:"connection_key,omitempty"`

	// Created Creation time in milliseconds since UNIX epoch.
	Created *int64 `json:"created,omitempty"`

	// Expires Expiration time in milliseconds since UNIX epoch.
	Expires *int64 `json:"expires,omitempty"`
}

// ArrayConnectionKeyGetResponse defines model for ArrayConnectionKeyGetResponse.
type ArrayConnectionKeyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string               `json:"continuation_token,omitempty"`
	Items             *[]ArrayConnectionKey `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayConnectionKeyResponse defines model for ArrayConnectionKeyResponse.
type ArrayConnectionKeyResponse struct {
	Items *[]ArrayConnectionKey `json:"items,omitempty"`
}

// ArrayConnectionPath defines model for ArrayConnectionPath.
type ArrayConnectionPath struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Destination IP address with the port of the target array.
	Destination *string `json:"destination,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Remote The remote array.
	Remote *FixedReference `json:"remote,omitempty"`

	// Source IP address of the source array.
	Source *string `json:"source,omitempty"`

	// Status Status of the connection.
	// Valid values are `connected` and `connecting`.
	// `connected` - The connection is OK.
	// `connecting` - No connection exists and the array is trying to
	// reconnect.
	Status *string `json:"status,omitempty"`

	// StatusDetails Additional information describing any issues encountered when
	// connecting, or `null` if the `status` is `connected`.
	StatusDetails *string `json:"status_details,omitempty"`

	// Type The type of path. Valid values include `async-replication` and `fleet-management`.
	Type *string `json:"type,omitempty"`
}

// ArrayConnectionPathGetResponse defines model for ArrayConnectionPathGetResponse.
type ArrayConnectionPathGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]ArrayConnectionPath        `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayConnectionPost defines model for ArrayConnectionPost.
type ArrayConnectionPost struct {
	// CaCertificateGroup The group of CA certificates that can be used, in addition to
	// well-known Certificate Authority certificates, in order to
	// establish a secure connection to the target array.
	// Defaults to a reference to the `_default_replication_certs` group
	// if `secure_connection` is `true`, or `null` otherwise.
	CaCertificateGroup *FixedReference `json:"ca_certificate_group,omitempty"`

	// ConnectionKey The connection key of the target array. Settable on POST only.
	ConnectionKey *string `json:"connection_key,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Encrypted If this is set to `true`, then all customer data replicated over
	// the connection will be sent over an encrypted connection using TLS,
	// or will not be sent if a secure connection cannot be
	// established.
	// If this is set to `false`, then all customer data replicated over
	// the connection will be sent over an unencrypted connection.
	// Defaults to `false`.
	Encrypted *bool `json:"encrypted,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// ManagementAddress Management address of the target array. Settable on POST only.
	ManagementAddress *string `json:"management_address,omitempty"`

	// Os The operating system of the connected array.
	Os *string `json:"os,omitempty"`

	// Remote The remote array.
	Remote *FixedReference `json:"remote,omitempty"`

	// ReplicationAddresses IP addresses and/or FQDNs of the target arrays. Settable on POST only.
	// If not set on POST, will be set to all the replication addresses
	// available on the target array at the time of the POST.
	ReplicationAddresses *[]string `json:"replication_addresses,omitempty"`

	// Status Status of the connection.
	// Valid values include `connected`, `partially_connected`, `connecting`,
	// and `incompatible`.
	// `connected` - The connection is OK.
	// `partially_connected` - Some replication addresses are working,
	// but others are not.
	// `connecting` - No connection exists and the array is trying to
	// reconnect.
	// `incompatible` - The target array is not compatible.
	Status *string `json:"status,omitempty"`

	// Throttle The bandwidth throttling for an array connection or target.
	Throttle *Throttle `json:"throttle,omitempty"`

	// Type The type of connection. Valid values include `async-replication` and `fleet-management`.
	Type *string `json:"type,omitempty"`

	// Version The version of the target array.
	Version *string `json:"version,omitempty"`
}

// ArrayConnectionResponse defines model for ArrayConnectionResponse.
type ArrayConnectionResponse struct {
	Items *[]ArrayConnection `json:"items,omitempty"`
}

// ArrayFactoryResetToken defines model for ArrayFactoryResetToken.
type ArrayFactoryResetToken struct {
	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Token A random 7-digit number required as input to perform a factory reset of the array.
	Token *int64 `json:"token,omitempty"`
}

// ArrayFactoryResetTokenGetResponse defines model for ArrayFactoryResetTokenGetResponse.
type ArrayFactoryResetTokenGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string                   `json:"continuation_token,omitempty"`
	Items             *[]ArrayFactoryResetToken `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayFactoryResetTokenResponse defines model for ArrayFactoryResetTokenResponse.
type ArrayFactoryResetTokenResponse struct {
	Items *[]ArrayFactoryResetToken `json:"items,omitempty"`
}

// ArrayGetResponse defines model for ArrayGetResponse.
type ArrayGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of array objects.
	Items *[]Array `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayHttpSpecificPerformance defines model for ArrayHttpSpecificPerformance.
type ArrayHttpSpecificPerformance struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadDirsPerSec Read directory requests processed per second.
	ReadDirsPerSec *float64 `json:"read_dirs_per_sec,omitempty"`

	// ReadFilesPerSec Read file requests processed per second.
	ReadFilesPerSec *float64 `json:"read_files_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadDirOp Average time, measured in microseconds, it takes the array to process
	// a read directory request.
	UsecPerReadDirOp *float64 `json:"usec_per_read_dir_op,omitempty"`

	// UsecPerReadFileOp Average time, measured in microseconds, it takes the array to process
	// a read file request.
	UsecPerReadFileOp *float64 `json:"usec_per_read_file_op,omitempty"`

	// UsecPerWriteDirOp Average time, measured in microseconds, it takes the array to process
	// a write directory request.
	UsecPerWriteDirOp *float64 `json:"usec_per_write_dir_op,omitempty"`

	// UsecPerWriteFileOp Average time, measured in microseconds, it takes the array to process
	// a write file request.
	UsecPerWriteFileOp *float64 `json:"usec_per_write_file_op,omitempty"`

	// WriteDirsPerSec Write directory requests processed per second.
	WriteDirsPerSec *float64 `json:"write_dirs_per_sec,omitempty"`

	// WriteFilesPerSec Write file requests processed per second.
	WriteFilesPerSec *float64 `json:"write_files_per_sec,omitempty"`
}

// ArrayHttpSpecificPerformanceGet defines model for ArrayHttpSpecificPerformanceGet.
type ArrayHttpSpecificPerformanceGet struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of http specific array performance metrics objects.
	Items *[]ArrayHttpSpecificPerformance `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayNfsSpecificPerformance defines model for ArrayNfsSpecificPerformance.
type ArrayNfsSpecificPerformance struct {
	// AccessesPerSec ACCESS requests processed per second.
	AccessesPerSec *float64 `json:"accesses_per_sec,omitempty"`

	// AggregateFileMetadataCreatesPerSec Sum of file-level or directory-level create-like metadata requests per
	// second. Includes CREATE, LINK, MKDIR, and SYMLINK.
	AggregateFileMetadataCreatesPerSec *float64 `json:"aggregate_file_metadata_creates_per_sec,omitempty"`

	// AggregateFileMetadataModifiesPerSec Sum of file-level or directory-level modify-like and delete-like
	// metadata requests per second. Includes REMOVE, RENAME, RMDIR, and
	// SETATTR.
	AggregateFileMetadataModifiesPerSec *float64 `json:"aggregate_file_metadata_modifies_per_sec,omitempty"`

	// AggregateFileMetadataReadsPerSec Sum of file-level or directory-level read-like metadata requests per
	// second. Includes GETATTR, LOOKUP, PATHCONF, READDIR, READDIRPLUS, and
	// READLINK.
	AggregateFileMetadataReadsPerSec *float64 `json:"aggregate_file_metadata_reads_per_sec,omitempty"`

	// AggregateOtherPerSec Sum of all other requests processed per second. This includes COMMIT,
	// MKNOD, NULL, NLM operations, and operations which are supported for
	// NFSv4.1 but not NFSv3.
	AggregateOtherPerSec *float64 `json:"aggregate_other_per_sec,omitempty"`

	// AggregateShareMetadataReadsPerSec Sum of share-level read-like metadata requests per second.
	// Includes ACCESS, FSINFO, and FSSTAT.
	AggregateShareMetadataReadsPerSec *float64 `json:"aggregate_share_metadata_reads_per_sec,omitempty"`

	// AggregateUsecPerFileMetadataCreateOp Average time, measured in microseconds, it takes the array to process a
	// file-level or directory-level create-like metadata request. Includes
	// CREATE, LINK, MKDIR, and SYMLINK.
	AggregateUsecPerFileMetadataCreateOp *float64 `json:"aggregate_usec_per_file_metadata_create_op,omitempty"`

	// AggregateUsecPerFileMetadataModifyOp Average time, measured in microseconds, it takes the array to process a
	// file-level or directory-level modify-like or delete-like metadata
	// request. Includes REMOVE, RENAME, RMDIR, and SETATTR.
	AggregateUsecPerFileMetadataModifyOp *float64 `json:"aggregate_usec_per_file_metadata_modify_op,omitempty"`

	// AggregateUsecPerFileMetadataReadOp Average time, measured in microseconds, it takes the array to process a
	// file-level or directory-level read-like metadata request. Includes
	// GETATTR, LOOKUP, PATHCONF, READDIR, READDIRPLUS, and READLINK.
	AggregateUsecPerFileMetadataReadOp *float64 `json:"aggregate_usec_per_file_metadata_read_op,omitempty"`

	// AggregateUsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// all other requests. This includes COMMIT, MKNOD, NULL, NLM operations,
	// and operations which are supported for NFSv4.1 but not NFSv3.
	AggregateUsecPerOtherOp *float64 `json:"aggregate_usec_per_other_op,omitempty"`

	// AggregateUsecPerShareMetadataReadOp Average time, measured in microseconds, it takes the array to process a
	// share-level read-like metadata request. Includes ACCESS, FSINFO, and
	// FSSTAT.
	AggregateUsecPerShareMetadataReadOp *float64 `json:"aggregate_usec_per_share_metadata_read_op,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// CreatesPerSec CREATE requests processed per second.
	CreatesPerSec *float64 `json:"creates_per_sec,omitempty"`

	// FsinfosPerSec FSINFO requests processed per second.
	FsinfosPerSec *float64 `json:"fsinfos_per_sec,omitempty"`

	// FsstatsPerSec FSSTAT requests processed per second.
	FsstatsPerSec *float64 `json:"fsstats_per_sec,omitempty"`

	// GetattrsPerSec GETATTR requests processed per second.
	GetattrsPerSec *float64 `json:"getattrs_per_sec,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// LinksPerSec LINK requests processed per second.
	LinksPerSec *float64 `json:"links_per_sec,omitempty"`

	// LookupsPerSec LOOKUP requests processed per second.
	LookupsPerSec *float64 `json:"lookups_per_sec,omitempty"`

	// MkdirsPerSec MKDIR requests processed per second.
	MkdirsPerSec *float64 `json:"mkdirs_per_sec,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PathconfsPerSec PATHCONF requests processed per second.
	PathconfsPerSec *float64 `json:"pathconfs_per_sec,omitempty"`

	// ReaddirplusesPerSec READDIRPLUS requests processed per second.
	ReaddirplusesPerSec *float64 `json:"readdirpluses_per_sec,omitempty"`

	// ReaddirsPerSec READDIR requests processed per second.
	ReaddirsPerSec *float64 `json:"readdirs_per_sec,omitempty"`

	// ReadlinksPerSec READLINK requests processed per second.
	ReadlinksPerSec *float64 `json:"readlinks_per_sec,omitempty"`

	// ReadsPerSec READ requests processed per second.
	ReadsPerSec *float64 `json:"reads_per_sec,omitempty"`

	// RemovesPerSec REMOVE requests processed per second.
	RemovesPerSec *float64 `json:"removes_per_sec,omitempty"`

	// RenamesPerSec RENAME requests processed per second.
	RenamesPerSec *float64 `json:"renames_per_sec,omitempty"`

	// RmdirsPerSec RMDIR requests processed per second.
	RmdirsPerSec *float64 `json:"rmdirs_per_sec,omitempty"`

	// SetattrsPerSec SETATTR requests processed per second.
	SetattrsPerSec *float64 `json:"setattrs_per_sec,omitempty"`

	// SymlinksPerSec SYMLINK requests processed per second.
	SymlinksPerSec *float64 `json:"symlinks_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerAccessOp Average time, measured in microseconds, it takes the array to process
	// an ACCESS request.
	UsecPerAccessOp *float64 `json:"usec_per_access_op,omitempty"`

	// UsecPerCreateOp Average time, measured in microseconds, it takes the array to process
	// a CREATE request.
	UsecPerCreateOp *float64 `json:"usec_per_create_op,omitempty"`

	// UsecPerFsinfoOp Average time, measured in microseconds, it takes the array to process
	// an FSINFO request.
	UsecPerFsinfoOp *float64 `json:"usec_per_fsinfo_op,omitempty"`

	// UsecPerFsstatOp Average time, measured in microseconds, it takes the array to process
	// an FSSTAT request.
	UsecPerFsstatOp *float64 `json:"usec_per_fsstat_op,omitempty"`

	// UsecPerGetattrOp Average time, measured in microseconds, it takes the array to process
	// a GETATTR request.
	UsecPerGetattrOp *float64 `json:"usec_per_getattr_op,omitempty"`

	// UsecPerLinkOp Average time, measured in microseconds, it takes the array to process
	// a LINK request.
	UsecPerLinkOp *float64 `json:"usec_per_link_op,omitempty"`

	// UsecPerLookupOp Average time, measured in microseconds, it takes the array to process
	// a LOOKUP request.
	UsecPerLookupOp *float64 `json:"usec_per_lookup_op,omitempty"`

	// UsecPerMkdirOp Average time, measured in microseconds, it takes the array to process
	// a MKDIR request.
	UsecPerMkdirOp *float64 `json:"usec_per_mkdir_op,omitempty"`

	// UsecPerPathconfOp Average time, measured in microseconds, it takes the array to process
	// a PATHCONF request.
	UsecPerPathconfOp *float64 `json:"usec_per_pathconf_op,omitempty"`

	// UsecPerReadOp Average time, measured in microseconds, it takes the array to process
	// a READ request.
	UsecPerReadOp *float64 `json:"usec_per_read_op,omitempty"`

	// UsecPerReaddirOp Average time, measured in microseconds, it takes the array to process
	// a READDIR request.
	UsecPerReaddirOp *float64 `json:"usec_per_readdir_op,omitempty"`

	// UsecPerReaddirplusOp Average time, measured in microseconds, it takes the array to process
	// a READDIRPLUS request.
	UsecPerReaddirplusOp *float64 `json:"usec_per_readdirplus_op,omitempty"`

	// UsecPerReadlinkOp Average time, measured in microseconds, it takes the array to process
	// a READLINK request.
	UsecPerReadlinkOp *float64 `json:"usec_per_readlink_op,omitempty"`

	// UsecPerRemoveOp Average time, measured in microseconds, it takes the array to process
	// a REMOVE request.
	UsecPerRemoveOp *float64 `json:"usec_per_remove_op,omitempty"`

	// UsecPerRenameOp Average time, measured in microseconds, it takes the array to process
	// a RENAME request.
	UsecPerRenameOp *float64 `json:"usec_per_rename_op,omitempty"`

	// UsecPerRmdirOp Average time, measured in microseconds, it takes the array to process
	// an RMDIR request.
	UsecPerRmdirOp *float64 `json:"usec_per_rmdir_op,omitempty"`

	// UsecPerSetattrOp Average time, measured in microseconds, it takes the array to process
	// a SETATTR request.
	UsecPerSetattrOp *float64 `json:"usec_per_setattr_op,omitempty"`

	// UsecPerSymlinkOp Average time, measured in microseconds, it takes the array to process
	// a SYMLINK request.
	UsecPerSymlinkOp *float64 `json:"usec_per_symlink_op,omitempty"`

	// UsecPerWriteOp Average time, measured in microseconds, it takes the array to process
	// a WRITE request.
	UsecPerWriteOp *float64 `json:"usec_per_write_op,omitempty"`

	// WritesPerSec WRITE requests processed per second.
	WritesPerSec *float64 `json:"writes_per_sec,omitempty"`
}

// ArrayNfsSpecificPerformanceGet defines model for ArrayNfsSpecificPerformanceGet.
type ArrayNfsSpecificPerformanceGet struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of NFS specific array performance metrics objects.
	Items *[]ArrayNfsSpecificPerformance `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayPerformance defines model for ArrayPerformance.
type ArrayPerformance struct {
	// BytesPerOp Average operation size (read bytes+write bytes/read ops+write ops).
	BytesPerOp *float64 `json:"bytes_per_op,omitempty"`

	// BytesPerRead Average read size in bytes per read operation.
	BytesPerRead *float64 `json:"bytes_per_read,omitempty"`

	// BytesPerWrite Average write size in bytes per write operation.
	BytesPerWrite *float64 `json:"bytes_per_write,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadBytesPerSec Bytes read per second.
	ReadBytesPerSec *float64 `json:"read_bytes_per_sec,omitempty"`

	// ReadsPerSec Read requests processed per second.
	ReadsPerSec *float64 `json:"reads_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadOp Average time, measured in microseconds, it takes the array to process
	// a read request.
	UsecPerReadOp *float64 `json:"usec_per_read_op,omitempty"`

	// UsecPerWriteOp Average time, measured in microseconds, it takes the array to process
	// a write request.
	UsecPerWriteOp *float64 `json:"usec_per_write_op,omitempty"`

	// WriteBytesPerSec Bytes written per second.
	WriteBytesPerSec *float64 `json:"write_bytes_per_sec,omitempty"`

	// WritesPerSec Write requests processed per second.
	WritesPerSec *float64 `json:"writes_per_sec,omitempty"`
}

// ArrayPerformanceGetResponse defines model for ArrayPerformanceGetResponse.
type ArrayPerformanceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of array performance metrics objects.
	Items *[]ArrayPerformance `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayPerformanceReplicationGetResp defines model for ArrayPerformanceReplicationGetResp.
type ArrayPerformanceReplicationGetResp struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors         `json:"errors,omitempty"`
	Items  *[]RelationshipPerformanceReplication `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArrayResponse defines model for ArrayResponse.
type ArrayResponse struct {
	// Items A list of array objects.
	Items *[]Array `json:"items,omitempty"`
}

// ArrayS3SpecificPerformance defines model for ArrayS3SpecificPerformance.
type ArrayS3SpecificPerformance struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadBucketsPerSec Read buckets requests processed per second.
	ReadBucketsPerSec *float64 `json:"read_buckets_per_sec,omitempty"`

	// ReadObjectsPerSec Read object requests processed per second.
	ReadObjectsPerSec *float64 `json:"read_objects_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadBucketOp Average time, measured in microseconds, it takes the array to process
	// a read bucket request.
	UsecPerReadBucketOp *float64 `json:"usec_per_read_bucket_op,omitempty"`

	// UsecPerReadObjectOp Average time, measured in microseconds, it takes the array to process
	// a read object request.
	UsecPerReadObjectOp *float64 `json:"usec_per_read_object_op,omitempty"`

	// UsecPerWriteBucketOp Average time, measured in microseconds, it takes the array to process
	// a write bucket request.
	UsecPerWriteBucketOp *float64 `json:"usec_per_write_bucket_op,omitempty"`

	// UsecPerWriteObjectOp Average time, measured in microseconds, it takes the array to process
	// a write object request.
	UsecPerWriteObjectOp *float64 `json:"usec_per_write_object_op,omitempty"`

	// WriteBucketsPerSec Write buckets requests processed per second.
	WriteBucketsPerSec *float64 `json:"write_buckets_per_sec,omitempty"`

	// WriteObjectsPerSec Write object requests processed per second.
	WriteObjectsPerSec *float64 `json:"write_objects_per_sec,omitempty"`
}

// ArrayS3SpecificPerformanceGetResp defines model for ArrayS3SpecificPerformanceGetResp.
type ArrayS3SpecificPerformanceGetResp struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of S3 specific array performance metrics objects.
	Items *[]ArrayS3SpecificPerformance `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArraySpace defines model for ArraySpace.
type ArraySpace struct {
	// Capacity Usable capacity in bytes.
	Capacity *int64 `json:"capacity,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Parity A representation of data redundancy on the array.
	// Data redundancy is rebuilt automatically by the system whenever parity is less than 1.0.
	Parity *float32 `json:"parity,omitempty"`
	Space  *Space   `json:"space,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`
}

// ArraySpaceGetResponse defines model for ArraySpaceGetResponse.
type ArraySpaceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of array space metrics objects.
	Items *[]ArraySpace `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArraySpaceStorageClassGetResponse defines model for ArraySpaceStorageClassGetResponse.
type ArraySpaceStorageClassGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of array space metrics objects for each storage class.
	Items *[]StorageClassSpace `json:"items,omitempty"`
	Total *StorageClassSpace   `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ArraysSupportedTimeZonesGetResponse defines model for ArraysSupportedTimeZonesGetResponse.
type ArraysSupportedTimeZonesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string     `json:"continuation_token,omitempty"`
	Items             *[]TimeZone `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// Audit defines model for Audit.
type Audit struct {
	Arguments *string `json:"arguments,omitempty"`
	Command   *string `json:"command,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id        *string `json:"id,omitempty"`
	IpAddress *string `json:"ip_address,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name       *string         `json:"name,omitempty"`
	Origin     *FixedReference `json:"origin,omitempty"`
	Subcommand *string         `json:"subcommand,omitempty"`
	Time       *int64          `json:"time,omitempty"`
	User       *string         `json:"user,omitempty"`
	UserAgent  *string         `json:"user_agent,omitempty"`

	// UserInterface The user interface through which the user session event was performed.
	// Valid values are `CLI`, `GUI`, and `REST`.
	UserInterface *string `json:"user_interface,omitempty"`
}

// AuditFileSystemsPoliciesGetResponse defines model for AuditFileSystemsPoliciesGetResponse.
type AuditFileSystemsPoliciesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of audit policy objects.
	Items *[]AuditFileSystemsPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AuditFileSystemsPoliciesMembersGetResponse defines model for AuditFileSystemsPoliciesMembersGetResponse.
type AuditFileSystemsPoliciesMembersGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of members for audit policies.
	Items *[]PolicyMemberContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AuditFileSystemsPoliciesMembersResponse defines model for AuditFileSystemsPoliciesMembersResponse.
type AuditFileSystemsPoliciesMembersResponse struct {
	// Items A list of members for audit policies.
	Items *[]PolicyMemberContext `json:"items,omitempty"`
}

// AuditFileSystemsPoliciesPatch defines model for AuditFileSystemsPoliciesPatch.
type AuditFileSystemsPoliciesPatch struct {
	// AddLogTargets The log targets which will be added to the existing `log_targets` list for the
	// audit policy. These new log targets will be appended to the end of the existing list.
	// The `add_log_targets` field can not be used with `log_targets` field.
	AddLogTargets *[]Reference `json:"add_log_targets,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// LogTargets List of targets which will be utilized for audit log storage.
	// These may either be file system targets or remote syslog server targets.
	LogTargets *[]Reference `json:"log_targets,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// RemoveLogTargets The log targets which will be removed from the existing `log_targets` list for the
	// audit policy. The `remove_log_targets` field can not be used with `log_targets` field.
	RemoveLogTargets *[]Reference `json:"remove_log_targets,omitempty"`
}

// AuditFileSystemsPoliciesPost defines model for AuditFileSystemsPoliciesPost.
type AuditFileSystemsPoliciesPost = AuditFileSystemsPolicyNoContext

// AuditFileSystemsPoliciesResponse defines model for AuditFileSystemsPoliciesResponse.
type AuditFileSystemsPoliciesResponse struct {
	// Items A list of audit policy objects.
	Items *[]AuditFileSystemsPolicy `json:"items,omitempty"`
}

// AuditFileSystemsPolicy defines model for AuditFileSystemsPolicy.
type AuditFileSystemsPolicy struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// LogTargets List of targets which will be utilized for audit log storage.
	// These may either be file system targets or remote syslog server targets.
	LogTargets *[]Reference `json:"log_targets,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// AuditFileSystemsPolicyNoContext defines model for AuditFileSystemsPolicyNoContext.
type AuditFileSystemsPolicyNoContext struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// LogTargets List of targets which will be utilized for audit log storage.
	// These may either be file system targets or remote syslog server targets.
	LogTargets *[]Reference `json:"log_targets,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// AuditGetResponse defines model for AuditGetResponse.
type AuditGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string  `json:"continuation_token,omitempty"`
	Items             *[]Audit `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// AuditResponse defines model for AuditResponse.
type AuditResponse struct {
	Items *[]Audit `json:"items,omitempty"`
}

// Blade defines model for Blade.
type Blade struct {
	Details *string `json:"details,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name        *string  `json:"name,omitempty"`
	Progress    *float32 `json:"progress,omitempty"`
	RawCapacity *int64   `json:"raw_capacity,omitempty"`

	// Status Valid values are `critical`, `evacuated`, `evacuating`, `healthy`,
	// `identifying`, `unhealthy`, `unknown`, and `unused`.
	Status *string `json:"status,omitempty"`
	Target *string `json:"target,omitempty"`
}

// BladeGetResponse defines model for BladeGetResponse.
type BladeGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of blade objects.
	Items *[]Blade `json:"items,omitempty"`
	Total *struct {
		Details *string `json:"details,omitempty"`

		// Id A non-modifiable, globally unique ID chosen by the system.
		Id *string `json:"id,omitempty"`

		// Name Name of the object (e.g., a file system or snapshot).
		Name        *string  `json:"name,omitempty"`
		Progress    *float32 `json:"progress,omitempty"`
		RawCapacity *int64   `json:"raw_capacity,omitempty"`

		// Status Valid values are `critical`, `evacuated`, `evacuating`, `healthy`,
		// `identifying`, `unhealthy`, `unknown`, and `unused`.
		Status *string `json:"status,omitempty"`
		Target *string `json:"target,omitempty"`
	} `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// Bucket defines model for Bucket.
type Bucket struct {
	Account *FixedReference `json:"account,omitempty"`

	// BucketType The bucket type for the bucket.
	BucketType *string `json:"bucket_type,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the object.
	Created *int64 `json:"created,omitempty"`

	// Destroyed Is the bucket destroyed?
	Destroyed         *bool                    `json:"destroyed,omitempty"`
	EradicationConfig *BucketEradicationConfig `json:"eradication_config,omitempty"`

	// HardLimitEnabled If set to `true`, the bucket's size, as defined by `quota_limit`,
	// is used as a hard limit quota.
	// If set to `false`, a hard limit quota will not be applied to the
	// bucket, but soft quota alerts will still be sent if the bucket has
	// a value set for `quota_limit`.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// ObjectCount The count of objects within the bucket.
	ObjectCount      *int64                    `json:"object_count,omitempty"`
	ObjectLockConfig *ObjectLockConfigResponse `json:"object_lock_config,omitempty"`

	// PublicAccessConfig Configuration settings related to public access.
	PublicAccessConfig *PublicAccessConfig `json:"public_access_config,omitempty"`

	// PublicStatus Bucket's public status. Valid values include `bucket-and-objects-not-public`,
	// `only-authorized-users-of-this-account` and `public`.
	PublicStatus *string `json:"public_status,omitempty"`

	// QuotaLimit The effective quota limit applied against the size of the bucket, displayed in bytes.
	// If unset, the bucket is unlimited in size.
	QuotaLimit *int `json:"quota_limit,omitempty"`

	// RetentionLock If set to `ratcheted`, then `object_lock_config.default_retention_mode`
	// cannot be changed if set to `compliance`. In this case, the value of
	// `object_lock_config.default_retention` can only be increased and
	// `object_lock_config.default_retention_mode` cannot be changed once set
	// to `compliance`.
	// Valid values are `unlocked` and `ratcheted`.
	// Contact Pure Technical Services to change `ratcheted` to `unlocked`.
	RetentionLock *string `json:"retention_lock,omitempty"`

	// Space The space specification of the bucket.
	Space *Space `json:"space,omitempty"`

	// TimeRemaining Time in milliseconds before the bucket is eradicated.
	// `null` if not destroyed or legal hold was found or the remaining time
	// until eradication is not known yet.
	TimeRemaining *int64 `json:"time_remaining,omitempty"`

	// TimeRemainingStatus Status of the `time_remaining` field.
	// `calculating` means the bucket is `retention-based`, has been destroyed and the
	// `time_remaining` is being calculated by a background process
	// `legal-hold` means the bucket is `retention-based`, has been destroyed and will never be
	// eradicated, because an object with legal hold status was found inside.
	// null otherwise, i.e. when either the bucket is not destroyed or it's destroyed and the
	// `time_remaining` has been determined.
	TimeRemainingStatus *string `json:"time_remaining_status,omitempty"`

	// Versioning The versioning state for objects within the bucket.
	// Valid values are `none`, `enabled`, and `suspended`.
	Versioning *string `json:"versioning,omitempty"`
}

// BucketAccessPolicy defines model for BucketAccessPolicy.
type BucketAccessPolicy struct {
	// Bucket The bucket to which this policy belongs.
	Bucket *FixedReference `json:"bucket,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string                   `json:"policy_type,omitempty"`
	Rules      *[]BucketAccessPolicyRule `json:"rules,omitempty"`
}

// BucketAccessPolicyGetResponse defines model for BucketAccessPolicyGetResponse.
type BucketAccessPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of bucket policy objects.
	Items *[]BucketAccessPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// BucketAccessPolicyPost defines model for BucketAccessPolicyPost.
type BucketAccessPolicyPost struct {
	Rules *[]BucketAccessPolicyRuleBulkManage `json:"rules,omitempty"`
}

// BucketAccessPolicyResponse defines model for BucketAccessPolicyResponse.
type BucketAccessPolicyResponse struct {
	// Items A list of bucket policy objects.
	Items *[]BucketAccessPolicy `json:"items,omitempty"`
}

// BucketAccessPolicyRule defines model for BucketAccessPolicyRule.
type BucketAccessPolicyRule struct {
	// Actions The list of actions granted by this rule. Each included action may
	// restrict other properties of the rule.
	// The only currently supported action is `s3:GetObject`.
	Actions *[]string `json:"actions,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// The only currently supported effect is `allow`.
	Effect *string `json:"effect,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Principals The principals to which this rule applies. Currently, only all principals are supported.
	Principals *BucketAccessPolicyRulePrincipal `json:"principals,omitempty"`

	// Resources The list of resources which this rule applies to.
	// The only currently supported resource is all objects in a bucket to which
	// the parent policy belongs.
	Resources *[]string `json:"resources,omitempty"`
}

// BucketAccessPolicyRuleBulkManage defines model for BucketAccessPolicyRuleBulkManage.
type BucketAccessPolicyRuleBulkManage struct {
	// Actions The list of actions granted by this rule. Each included action may
	// restrict other properties of the rule.
	// The only currently supported action is `s3:GetObject`.
	Actions *[]string `json:"actions,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// The only currently supported effect is `allow`.
	Effect *string `json:"effect,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Principals The principals to which this rule applies. Currently, only all principals are supported.
	Principals *BucketAccessPolicyRulePrincipal `json:"principals,omitempty"`

	// Resources The list of resources which this rule applies to.
	// The only currently supported resource is all objects in a bucket to which
	// the parent policy belongs.
	Resources *[]string `json:"resources,omitempty"`
}

// BucketAccessPolicyRuleGetResponse defines model for BucketAccessPolicyRuleGetResponse.
type BucketAccessPolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors        `json:"errors,omitempty"`
	Items  *[]BucketAccessPolicyRuleWithContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// BucketAccessPolicyRulePost defines model for BucketAccessPolicyRulePost.
type BucketAccessPolicyRulePost struct {
	// Actions The list of actions granted by this rule. Each included action may
	// restrict other properties of the rule.
	// The only currently supported action is `s3:GetObject`.
	Actions *[]string `json:"actions,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// The only currently supported effect is `allow`.
	Effect *string `json:"effect,omitempty"`

	// Principals The principals to which this rule applies. Currently, only all principals are supported.
	Principals *BucketAccessPolicyRulePrincipal `json:"principals,omitempty"`

	// Resources The list of resources which this rule applies to.
	// The only currently supported resource is all objects in a bucket to which
	// the parent policy belongs.
	Resources *[]string `json:"resources,omitempty"`
}

// BucketAccessPolicyRulePrincipal defines model for BucketAccessPolicyRulePrincipal.
type BucketAccessPolicyRulePrincipal struct {
	// All If `true`, the rule will apply to all object store users regardless of their
	// origin or principal.
	All *bool `json:"all,omitempty"`
}

// BucketAccessPolicyRuleResponse defines model for BucketAccessPolicyRuleResponse.
type BucketAccessPolicyRuleResponse struct {
	Items *[]BucketAccessPolicyRuleWithContext `json:"items,omitempty"`
}

// BucketAccessPolicyRuleWithContext defines model for BucketAccessPolicyRuleWithContext.
type BucketAccessPolicyRuleWithContext struct {
	// Actions The list of actions granted by this rule. Each included action may
	// restrict other properties of the rule.
	// The only currently supported action is `s3:GetObject`.
	Actions *[]string `json:"actions,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// The only currently supported effect is `allow`.
	Effect *string `json:"effect,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Principals The principals to which this rule applies. Currently, only all principals are supported.
	Principals *BucketAccessPolicyRulePrincipal `json:"principals,omitempty"`

	// Resources The list of resources which this rule applies to.
	// The only currently supported resource is all objects in a bucket to which
	// the parent policy belongs.
	Resources *[]string `json:"resources,omitempty"`
}

// BucketGetResponse defines model for BucketGetResponse.
type BucketGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of bucket objects.
	Items *[]Bucket `json:"items,omitempty"`
	Total *Bucket   `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// BucketPatch defines model for BucketPatch.
type BucketPatch struct {
	// Destroyed Is the bucket destroyed?
	Destroyed *bool `json:"destroyed,omitempty"`

	// EradicationConfig Configuration settings related to bucket eradication.
	EradicationConfig *BucketEradicationConfig `json:"eradication_config,omitempty"`

	// HardLimitEnabled If set to `true`, the bucket's size, as defined by `quota_limit`,
	// is used as a hard limit quota.
	// If set to `false`, a hard limit quota will not be applied to the
	// bucket, but soft quota alerts will still be sent if the bucket has
	// a value set for `quota_limit`.
	HardLimitEnabled *bool                        `json:"hard_limit_enabled,omitempty"`
	ObjectLockConfig *ObjectLockConfigRequestBody `json:"object_lock_config,omitempty"`

	// PublicAccessConfig Configuration settings related to public access.
	PublicAccessConfig *PublicAccessConfig `json:"public_access_config,omitempty"`

	// QuotaLimit The effective quota limit applied against the size of the bucket, displayed in bytes.
	// If set to an empty string (`""`), the bucket is unlimited in size.
	QuotaLimit *string `json:"quota_limit,omitempty"`

	// RetentionLock If set to `ratcheted`, then `object_lock_config.default_retention_mode`
	// cannot be changed if set to `compliance`. In this case, the value of
	// `object_lock_config.default_retention` can only be increased and
	// `object_lock_config.default_retention_mode` cannot be changed once set
	// to `compliance`.
	// Valid values are `unlocked` and `ratcheted`.
	// Contact Pure Technical Services to change `ratcheted` to `unlocked`.
	RetentionLock *string `json:"retention_lock,omitempty"`

	// Versioning The versioning state for objects within the bucket.
	// Valid values are `none`, `enabled`, and `suspended`.
	Versioning *string `json:"versioning,omitempty"`
}

// BucketPerformance defines model for BucketPerformance.
type BucketPerformance struct {
	// BytesPerOp Average operation size (read bytes+write bytes/read ops+write ops).
	BytesPerOp *float64 `json:"bytes_per_op,omitempty"`

	// BytesPerRead Average read size in bytes per read operation.
	BytesPerRead *float64 `json:"bytes_per_read,omitempty"`

	// BytesPerWrite Average write size in bytes per write operation.
	BytesPerWrite *float64 `json:"bytes_per_write,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadBytesPerSec Bytes read per second.
	ReadBytesPerSec *float64 `json:"read_bytes_per_sec,omitempty"`

	// ReadsPerSec Read requests processed per second.
	ReadsPerSec *float64 `json:"reads_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadOp Average time, measured in microseconds, it takes the array to process
	// a read request.
	UsecPerReadOp *float64 `json:"usec_per_read_op,omitempty"`

	// UsecPerWriteOp Average time, measured in microseconds, it takes the array to process
	// a write request.
	UsecPerWriteOp *float64 `json:"usec_per_write_op,omitempty"`

	// WriteBytesPerSec Bytes written per second.
	WriteBytesPerSec *float64 `json:"write_bytes_per_sec,omitempty"`

	// WritesPerSec Write requests processed per second.
	WritesPerSec *float64 `json:"writes_per_sec,omitempty"`
}

// BucketPerformanceGetResponse defines model for BucketPerformanceGetResponse.
type BucketPerformanceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of bucket performance objects.
	Items *[]BucketPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]BucketPerformance `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// BucketPost defines model for BucketPost.
type BucketPost struct {
	// Account The account name for bucket creation.
	Account *ReferenceWritable `json:"account,omitempty"`

	// BucketType The bucket type for the bucket. Valid values are `classic`, and `multi-site-writable`.
	// Default value is `multi-site-writable`.
	BucketType *string `json:"bucket_type,omitempty"`

	// EradicationConfig Configuration settings related to bucket eradication.
	EradicationConfig *BucketEradicationConfig `json:"eradication_config,omitempty"`

	// HardLimitEnabled If set to `true`, the bucket's size, as defined by `quota_limit`,
	// is used as a hard limit quota.
	// If set to `false`, a hard limit quota will not be applied to the
	// bucket, but soft quota alerts will still be sent if the bucket has
	// a value set for `quota_limit`.
	// If not specified, defaults to the value
	// of `bucket_defaults.hard_limit_enabled` of the object store account this
	// bucket is associated with.
	HardLimitEnabled *bool                        `json:"hard_limit_enabled,omitempty"`
	ObjectLockConfig *ObjectLockConfigRequestBody `json:"object_lock_config,omitempty"`

	// QuotaLimit The effective quota limit applied against the size of the bucket, displayed in bytes.
	// If set to an empty string (`""`), the bucket is unlimited in size. If not specified,
	// defaults to the value of `bucket_defaults.quota_limit` of the object
	// store account this bucket is associated with.
	QuotaLimit *string `json:"quota_limit,omitempty"`

	// RetentionLock If set to `ratcheted`, then `object_lock_config.default_retention_mode`
	// cannot be changed if set to `compliance`. In this case, the value of
	// `object_lock_config.default_retention` can only be increased and
	// `object_lock_config.default_retention_mode` cannot be changed once set
	// to `compliance`.
	// Valid values are `unlocked` and `ratcheted`.
	// If not specified, defaults to `unlocked`.
	RetentionLock *string `json:"retention_lock,omitempty"`
}

// BucketReplicaLink defines model for BucketReplicaLink.
type BucketReplicaLink struct {
	// CascadingEnabled If set to `true`, objects replicated to this bucket via a replica
	// link from another array will also be replicated by this link to
	// the remote bucket.
	// Defaults to `false`.
	CascadingEnabled *bool `json:"cascading_enabled,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Direction The direction of replication. Valid values are `inbound` and
	// `outbound`.
	Direction *Direction `json:"direction,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Lag Duration in milliseconds that represents how far
	// behind the replication target is from the source.
	// This is the time difference between current time and `recovery_point`.
	Lag *int64 `json:"lag,omitempty"`

	// LocalBucket Reference to a local bucket.
	LocalBucket *FixedReference `json:"local_bucket,omitempty"`

	// ObjectBacklog The number of pending operations and their size that are currently in the backlog.
	ObjectBacklog *ObjectBacklog `json:"object_backlog,omitempty"`

	// Paused Is the replica link paused?
	Paused *bool `json:"paused,omitempty"`

	// RecoveryPoint Time, in milliseconds since UNIX epoch, where all object changes before this time are
	// guaranteed to have been replicated. Changes after this time may have been replicated.
	RecoveryPoint *int64 `json:"recovery_point,omitempty"`

	// Remote Reference to the associated remote, which can either be a `target` or remote `array`.
	// If it is an `array`, then the `resource-type` field will not be populated.
	Remote *FixedReference `json:"remote,omitempty"`

	// RemoteBucket Reference to a remote bucket.
	RemoteBucket *FixedReferenceNameOnly `json:"remote_bucket,omitempty"`

	// RemoteCredentials Reference to a remote-credentials object to access the remote bucket.
	RemoteCredentials *ReferenceWritable `json:"remote_credentials,omitempty"`

	// Status Status of the replica link.
	// Values include `replicating`, `paused`, and `unhealthy`.
	Status *string `json:"status,omitempty"`

	// StatusDetails Detailed information about the status of the replica link when it is
	// unhealthy.
	StatusDetails *string `json:"status_details,omitempty"`
}

// BucketReplicaLinkGetResponse defines model for BucketReplicaLinkGetResponse.
type BucketReplicaLinkGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of object store bucket replica link objects.
	Items *[]BucketReplicaLink `json:"items,omitempty"`

	// Total If `total_only` query param is `true`, then it will be a total of
	// all records after filtering and no items will be returned.
	// If `total_only` is `false`, then it will be a total of all records
	// on this page.
	Total *BucketReplicaLink `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// BucketReplicaLinkPost defines model for BucketReplicaLinkPost.
type BucketReplicaLinkPost struct {
	// CascadingEnabled If set to `true`, objects replicated to this bucket via a replica
	// link from another array will also be replicated by this link to
	// the remote bucket.
	// Defaults to `false`.
	CascadingEnabled *bool `json:"cascading_enabled,omitempty"`

	// Paused Create link in the paused state? Defaults to `false`.
	Paused *bool `json:"paused,omitempty"`
}

// BucketReplicaLinkResponse defines model for BucketReplicaLinkResponse.
type BucketReplicaLinkResponse struct {
	// Items A list of object store bucket replica link objects.
	Items *[]BucketReplicaLink `json:"items,omitempty"`

	// Total If `total_only` query param is `true`, then it will be a total of
	// all records after filtering and no items will be returned.
	// If `total_only` is `false`, then it will be a total of all records
	// on this page.
	Total *BucketReplicaLink `json:"total,omitempty"`
}

// BucketResponse defines model for BucketResponse.
type BucketResponse struct {
	// Items A list of bucket objects.
	Items *[]Bucket `json:"items,omitempty"`
}

// BucketS3SpecificPerformance defines model for BucketS3SpecificPerformance.
type BucketS3SpecificPerformance struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadBucketsPerSec Read buckets requests processed per second.
	ReadBucketsPerSec *float64 `json:"read_buckets_per_sec,omitempty"`

	// ReadObjectsPerSec Read object requests processed per second.
	ReadObjectsPerSec *float64 `json:"read_objects_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadBucketOp Average time, measured in microseconds, it takes the array to process
	// a read bucket request.
	UsecPerReadBucketOp *float64 `json:"usec_per_read_bucket_op,omitempty"`

	// UsecPerReadObjectOp Average time, measured in microseconds, it takes the array to process
	// a read object request.
	UsecPerReadObjectOp *float64 `json:"usec_per_read_object_op,omitempty"`

	// UsecPerWriteBucketOp Average time, measured in microseconds, it takes the array to process
	// a write bucket request.
	UsecPerWriteBucketOp *float64 `json:"usec_per_write_bucket_op,omitempty"`

	// UsecPerWriteObjectOp Average time, measured in microseconds, it takes the array to process
	// a write object request.
	UsecPerWriteObjectOp *float64 `json:"usec_per_write_object_op,omitempty"`

	// WriteBucketsPerSec Write buckets requests processed per second.
	WriteBucketsPerSec *float64 `json:"write_buckets_per_sec,omitempty"`

	// WriteObjectsPerSec Write object requests processed per second.
	WriteObjectsPerSec *float64 `json:"write_objects_per_sec,omitempty"`
}

// BucketS3SpecificPerformanceGetResp defines model for BucketS3SpecificPerformanceGetResp.
type BucketS3SpecificPerformanceGetResp struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of S3 specific bucket performance metrics objects.
	Items *[]BucketS3SpecificPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]BucketS3SpecificPerformance `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// Certificate defines model for Certificate.
type Certificate struct {
	// Certificate The text of the certificate.
	Certificate *string `json:"certificate,omitempty"`

	// CertificateType The type of certificate. Possible values are `appliance` and
	// `external`.
	// Certificates of type `appliance` are used by the array to verify
	// its identity to clients. Certificates of type `external` are used
	// by the array to identify external servers to which it is configured
	// to communicate.
	CertificateType *string `json:"certificate_type,omitempty"`

	// CommonName FQDN or management IP address of the current array.
	CommonName *string `json:"common_name,omitempty"`

	// Country The country field listed in the certificate.
	Country *string `json:"country,omitempty"`

	// Email The email field listed in the certificate.
	Email *string `json:"email,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IntermediateCertificate Intermediate certificate chains.
	IntermediateCertificate *string `json:"intermediate_certificate,omitempty"`

	// IssuedBy Who issued this certificate.
	IssuedBy *string `json:"issued_by,omitempty"`

	// IssuedTo Who this certificate was issued to.
	IssuedTo *string `json:"issued_to,omitempty"`

	// KeySize The size of the private key for this certificate in bits.
	KeySize *int32 `json:"key_size,omitempty"`

	// Locality The locality field listed in the certificate.
	Locality *string `json:"locality,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Organization The organization field listed in the certificate.
	Organization *string `json:"organization,omitempty"`

	// OrganizationalUnit The organizational unit field listed in the certificate.
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`

	// State The state/province field listed in the certificate.
	State *string `json:"state,omitempty"`

	// Status The type of certificate.
	// Valid values are `self-signed` and `imported`.
	Status *string `json:"status,omitempty"`

	// SubjectAlternativeNames The alternative names that are secured by this certificate.
	// Alternative names may be IP addresses, DNS names, or URIs.
	SubjectAlternativeNames *[]string `json:"subject_alternative_names,omitempty"`

	// ValidFrom The start date of when this certificate is valid.
	ValidFrom *string `json:"valid_from,omitempty"`

	// ValidTo The end date of when this certificate is valid.
	ValidTo *string `json:"valid_to,omitempty"`
}

// CertificateCertificateGroupGetResp defines model for CertificateCertificateGroupGetResp.
type CertificateCertificateGroupGetResp struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of certificate and certificate group relationships.
	Items *[]Member `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CertificateCertificateGroupResponse defines model for CertificateCertificateGroupResponse.
type CertificateCertificateGroupResponse struct {
	// Items A list of certificate and certificate group relationships.
	Items *[]Member `json:"items,omitempty"`
}

// CertificateGetResponse defines model for CertificateGetResponse.
type CertificateGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of certificate objects.
	Items *[]Certificate `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CertificateGroup defines model for CertificateGroup.
type CertificateGroup = BuiltIn

// CertificateGroupCertificateGetResp defines model for CertificateGroupCertificateGetResp.
type CertificateGroupCertificateGetResp struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of certificate and certificate group relationships.
	Items *[]Member `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CertificateGroupCertificateResponse defines model for CertificateGroupCertificateResponse.
type CertificateGroupCertificateResponse struct {
	// Items A list of certificate and certificate group relationships.
	Items *[]Member `json:"items,omitempty"`
}

// CertificateGroupGetResponse defines model for CertificateGroupGetResponse.
type CertificateGroupGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of certificate group objects.
	Items *[]CertificateGroup `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CertificateGroupResponse defines model for CertificateGroupResponse.
type CertificateGroupResponse struct {
	// Items A list of certificate group objects.
	Items *[]CertificateGroup `json:"items,omitempty"`
}

// CertificateGroupUse defines model for CertificateGroupUse.
type CertificateGroupUse struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Use A reference to an object using this certificate group.
	Use *FixedReferenceWithRemote `json:"use,omitempty"`
}

// CertificateGroupUseGetResponse defines model for CertificateGroupUseGetResponse.
type CertificateGroupUseGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of certificate group use objects.
	Items *[]CertificateGroupUse `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CertificatePatch defines model for CertificatePatch.
type CertificatePatch struct {
	// Certificate The text of the certificate.
	Certificate *string `json:"certificate,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IntermediateCertificate Intermediate certificate chains.
	IntermediateCertificate *string `json:"intermediate_certificate,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Passphrase The passphrase used to encrypt `private_key`.
	Passphrase *string `json:"passphrase,omitempty"`

	// PrivateKey The private key used to sign the certificate.
	PrivateKey *string `json:"private_key,omitempty"`
}

// CertificatePost defines model for CertificatePost.
type CertificatePost struct {
	// Certificate The text of the certificate.
	Certificate *string `json:"certificate,omitempty"`

	// CertificateType The type of certificate. Possible values are `appliance` and
	// `external`.
	// Certificates of type `appliance` are used by the array to verify
	// its identity to clients. Certificates of type `external` are used
	// by the array to identify external servers to which it is configured
	// to communicate.
	CertificateType *string `json:"certificate_type,omitempty"`

	// CommonName FQDN or management IP address of the current array.
	CommonName *string `json:"common_name,omitempty"`

	// Country The country field listed in the certificate.
	Country *string `json:"country,omitempty"`

	// Email The email field listed in the certificate.
	Email *string `json:"email,omitempty"`

	// IntermediateCertificate Intermediate certificate chains.
	IntermediateCertificate *string `json:"intermediate_certificate,omitempty"`

	// IssuedBy Who issued this certificate.
	IssuedBy *string `json:"issued_by,omitempty"`

	// IssuedTo Who this certificate was issued to.
	IssuedTo *string `json:"issued_to,omitempty"`

	// KeySize The size of the private key for this certificate in bits.
	KeySize *int32 `json:"key_size,omitempty"`

	// Locality The locality field listed in the certificate.
	Locality *string `json:"locality,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Organization The organization field listed in the certificate.
	Organization *string `json:"organization,omitempty"`

	// OrganizationalUnit The organizational unit field listed in the certificate.
	OrganizationalUnit *string `json:"organizational_unit,omitempty"`

	// Passphrase The passphrase used to encrypt `private_key`.
	Passphrase *string `json:"passphrase,omitempty"`

	// PrivateKey The private key used to sign the certificate.
	PrivateKey *string `json:"private_key,omitempty"`

	// State The state/province field listed in the certificate.
	State *string `json:"state,omitempty"`

	// Status The type of certificate.
	// Valid values are `self-signed` and `imported`.
	Status *string `json:"status,omitempty"`

	// ValidFrom The start date of when this certificate is valid.
	ValidFrom *string `json:"valid_from,omitempty"`

	// ValidTo The end date of when this certificate is valid.
	ValidTo *string `json:"valid_to,omitempty"`
}

// CertificateResponse defines model for CertificateResponse.
type CertificateResponse struct {
	// Items A list of certificate objects.
	Items *[]Certificate `json:"items,omitempty"`
}

// CertificateUse defines model for CertificateUse.
type CertificateUse struct {
	// Group A reference to a certificate group that is being used, if any, where
	// this certificate is a member of the certificate-group. This field is
	// `null` if the referenced use object is not using a group, but is rather
	// using this certificate directly.
	Group *FixedReference `json:"group,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Use A reference to an object using this certificate.
	Use *FixedReferenceWithRemote `json:"use,omitempty"`
}

// CertificateUseGetResponse defines model for CertificateUseGetResponse.
type CertificateUseGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of certificate use objects.
	Items *[]CertificateUse `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ClientPerformance defines model for ClientPerformance.
type ClientPerformance struct {
	// BytesPerOp Average operation size (read bytes+write bytes/read ops+write ops).
	BytesPerOp *int64 `json:"bytes_per_op,omitempty"`

	// BytesPerRead Average read size in bytes per read operation.
	BytesPerRead *int64 `json:"bytes_per_read,omitempty"`

	// BytesPerWrite Average write size in bytes per write operation.
	BytesPerWrite *int64 `json:"bytes_per_write,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *int64 `json:"others_per_sec,omitempty"`

	// ReadBytesPerSec Bytes read per second.
	ReadBytesPerSec *int64 `json:"read_bytes_per_sec,omitempty"`

	// ReadsPerSec Read requests processed per second.
	ReadsPerSec *int64 `json:"reads_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the client to process
	// other operations.
	UsecPerOtherOp *int64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadOp Average time, measured in microseconds, it takes the client to process
	// a read request.
	UsecPerReadOp *int64 `json:"usec_per_read_op,omitempty"`

	// UsecPerWriteOp Average time, measured in microseconds, it takes the client to process
	// a write request.
	UsecPerWriteOp *int64 `json:"usec_per_write_op,omitempty"`

	// WriteBytesPerSec Bytes written per second.
	WriteBytesPerSec *int64 `json:"write_bytes_per_sec,omitempty"`

	// WritesPerSec Write requests processed per second.
	WritesPerSec *int64 `json:"writes_per_sec,omitempty"`
}

// ClientPerformanceGetResponse defines model for ClientPerformanceGetResponse.
type ClientPerformanceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of client performance metrics objects.
	Items *[]ClientPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]ClientPerformance `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ConnectionRelationshipPerformanceReplication defines model for ConnectionRelationshipPerformanceReplication.
type ConnectionRelationshipPerformanceReplication struct {
	// Aggregate Total bytes transmitted or received per second for all types of
	// replication.
	Aggregate *ReplicationPerformance `json:"aggregate,omitempty"`

	// Continuous Object backlog information and total bytes transmitted or received
	// per second for continuous replication. Continuous replication
	// includes object replication.
	Continuous *ContinuousReplicationPerformance `json:"continuous,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Periodic Total bytes transmitted or received per second for periodic
	// replication. Periodic replication includes file system replication,
	// which is snapshot based.
	Periodic *ReplicationPerformance `json:"periodic,omitempty"`

	// Remote Reference to a remote array.
	Remote *FixedReferenceNoResourceType `json:"remote,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`
}

// ConnectionRelationshipPerformanceReplicationGetResp defines model for ConnectionRelationshipPerformanceReplicationGetResp.
type ConnectionRelationshipPerformanceReplicationGetResp struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string                                         `json:"continuation_token,omitempty"`
	Items             *[]ConnectionRelationshipPerformanceReplication `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]ConnectionRelationshipPerformanceReplication `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CrossOriginResourceSharingPolicy defines model for CrossOriginResourceSharingPolicy.
type CrossOriginResourceSharingPolicy struct {
	// Bucket The bucket to which this policy belongs.
	Bucket *FixedReference `json:"bucket,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string                                            `json:"policy_type,omitempty"`
	Rules      *[]CrossOriginResourceSharingPolicyRuleWithContext `json:"rules,omitempty"`
}

// CrossOriginResourceSharingPolicyGetResponse defines model for CrossOriginResourceSharingPolicyGetResponse.
type CrossOriginResourceSharingPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of cross origin resource sharing policy objects.
	Items *[]CrossOriginResourceSharingPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CrossOriginResourceSharingPolicyPatch defines model for CrossOriginResourceSharingPolicyPatch.
type CrossOriginResourceSharingPolicyPatch struct {
	Rules *[]CrossOriginResourceSharingPolicyRuleBulkManage `json:"rules,omitempty"`
}

// CrossOriginResourceSharingPolicyResponse defines model for CrossOriginResourceSharingPolicyResponse.
type CrossOriginResourceSharingPolicyResponse struct {
	// Items A list of cross origin resource sharing policy objects.
	Items *[]CrossOriginResourceSharingPolicy `json:"items,omitempty"`
}

// CrossOriginResourceSharingPolicyRule defines model for CrossOriginResourceSharingPolicyRule.
type CrossOriginResourceSharingPolicyRule struct {
	// AllowedHeaders A list of headers that are permitted to be included in cross-origin requests to
	// access a bucket. The only currently supported allowed header is `*`.
	AllowedHeaders *[]string `json:"allowed_headers,omitempty"`

	// AllowedMethods A list of HTTP methods that are permitted for cross-origin requests to access a bucket.
	// The only currently supported combination of allowed methods is all methods
	// `["GET", "PUT", "HEAD", "POST", "DELETE"]`.
	AllowedMethods *[]string `json:"allowed_methods,omitempty"`

	// AllowedOrigins A list of origins (domains) that are permitted to make cross-origin requests to
	// access a bucket. The only currently supported allowed origin is `*`.
	AllowedOrigins *[]string `json:"allowed_origins,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`
}

// CrossOriginResourceSharingPolicyRuleBulkManage defines model for CrossOriginResourceSharingPolicyRuleBulkManage.
type CrossOriginResourceSharingPolicyRuleBulkManage struct {
	// AllowedHeaders A list of headers that are permitted to be included in cross-origin requests to
	// access a bucket. The only currently supported allowed header is `*`.
	AllowedHeaders *[]string `json:"allowed_headers,omitempty"`

	// AllowedMethods A list of HTTP methods that are permitted for cross-origin requests to access a bucket.
	// The only currently supported combination of allowed methods is all methods
	// `["GET", "PUT", "HEAD", "POST", "DELETE"]`.
	AllowedMethods *[]string `json:"allowed_methods,omitempty"`

	// AllowedOrigins A list of origins (domains) that are permitted to make cross-origin requests to
	// access a bucket. The only currently supported allowed origin is `*`.
	AllowedOrigins *[]string `json:"allowed_origins,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// CrossOriginResourceSharingPolicyRuleGetResponse defines model for CrossOriginResourceSharingPolicyRuleGetResponse.
type CrossOriginResourceSharingPolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors                      `json:"errors,omitempty"`
	Items  *[]CrossOriginResourceSharingPolicyRuleWithContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// CrossOriginResourceSharingPolicyRulePost defines model for CrossOriginResourceSharingPolicyRulePost.
type CrossOriginResourceSharingPolicyRulePost struct {
	// AllowedHeaders A list of headers that are permitted to be included in cross-origin requests to
	// access a bucket. The only currently supported allowed header is `*`.
	AllowedHeaders *[]string `json:"allowed_headers,omitempty"`

	// AllowedMethods A list of HTTP methods that are permitted for cross-origin requests to access a bucket.
	// The only currently supported combination of allowed methods is all methods
	// `["GET", "PUT", "HEAD", "POST", "DELETE"]`.
	AllowedMethods *[]string `json:"allowed_methods,omitempty"`

	// AllowedOrigins A list of origins (domains) that are permitted to make cross-origin requests to
	// access a bucket. The only currently supported allowed origin is `*`.
	AllowedOrigins *[]string `json:"allowed_origins,omitempty"`
}

// CrossOriginResourceSharingPolicyRuleResponse defines model for CrossOriginResourceSharingPolicyRuleResponse.
type CrossOriginResourceSharingPolicyRuleResponse struct {
	Items *[]CrossOriginResourceSharingPolicyRuleWithContext `json:"items,omitempty"`
}

// CrossOriginResourceSharingPolicyRuleWithContext defines model for CrossOriginResourceSharingPolicyRuleWithContext.
type CrossOriginResourceSharingPolicyRuleWithContext struct {
	// AllowedHeaders A list of headers that are permitted to be included in cross-origin requests to
	// access a bucket. The only currently supported allowed header is `*`.
	AllowedHeaders *[]string `json:"allowed_headers,omitempty"`

	// AllowedMethods A list of HTTP methods that are permitted for cross-origin requests to access a bucket.
	// The only currently supported combination of allowed methods is all methods
	// `["GET", "PUT", "HEAD", "POST", "DELETE"]`.
	AllowedMethods *[]string `json:"allowed_methods,omitempty"`

	// AllowedOrigins A list of origins (domains) that are permitted to make cross-origin requests to
	// access a bucket. The only currently supported allowed origin is `*`.
	AllowedOrigins *[]string `json:"allowed_origins,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`
}

// DirectoryService defines model for DirectoryService.
type DirectoryService struct {
	// BaseDn Base of the Distinguished Name (DN) of the directory service groups.
	BaseDn *string `json:"base_dn,omitempty"`

	// BindPassword Obfuscated password used to query the directory.
	BindPassword *string `json:"bind_password,omitempty"`

	// BindUser Username used to query the directory.
	BindUser *string `json:"bind_user,omitempty"`

	// CaCertificate CA certificate used to validate the authenticity of the configured
	// servers.
	CaCertificate *Reference `json:"ca_certificate,omitempty"`

	// CaCertificateGroup A certificate group containing CA certificates that can be used to
	// validate the authenticity of the configured servers.
	CaCertificateGroup *Reference `json:"ca_certificate_group,omitempty"`

	// Enabled Is the directory service enabled or not?
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Management Properties specific to the management service.
	Management *DirectoryServiceManagement `json:"management,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Nfs Properties specific to the NFS service.
	Nfs *DirectoryServiceNfs `json:"nfs,omitempty"`

	// Services Services that the directory service configuration is used for.
	Services *[]string `json:"services,omitempty"`

	// Smb DEPRECATED - Properties specific to the SMB service.
	Smb *DirectoryServiceSmb `json:"smb,omitempty"`

	// Uris List of URIs for the configured directory servers.
	Uris *[]string `json:"uris,omitempty"`
}

// DirectoryServiceGetResponse defines model for DirectoryServiceGetResponse.
type DirectoryServiceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string             `json:"continuation_token,omitempty"`
	Items             *[]DirectoryService `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// DirectoryServiceResponse defines model for DirectoryServiceResponse.
type DirectoryServiceResponse struct {
	Items *[]DirectoryService `json:"items,omitempty"`
}

// DirectoryServiceRole defines model for DirectoryServiceRole.
type DirectoryServiceRole struct {
	// Group Common Name (CN) of the directory service group containing
	// users with authority level of the specified role name.
	Group *string `json:"group,omitempty"`

	// GroupBase Specifies where the configured group is located in the directory tree.
	GroupBase *string `json:"group_base,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the role mapping object.
	Name *string `json:"name,omitempty"`

	// Role A reference to the role; can be any role that exists on the system.
	Role *ReferenceWritable `json:"role,omitempty"`
}

// DirectoryServiceRolesGetResponse defines model for DirectoryServiceRolesGetResponse.
type DirectoryServiceRolesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string                 `json:"continuation_token,omitempty"`
	Items             *[]DirectoryServiceRole `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// DirectoryServiceRolesResponse defines model for DirectoryServiceRolesResponse.
type DirectoryServiceRolesResponse struct {
	Items *[]DirectoryServiceRole `json:"items,omitempty"`
}

// Dns defines model for Dns.
type Dns struct {
	// Domain Domain suffix to be appended by the appliance when performing DNS lookups.
	Domain *string `json:"domain,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Nameservers List of DNS server IP addresses.
	Nameservers *[]string `json:"nameservers,omitempty"`

	// Services The list of services utilizing the DNS configuration.
	Services *[]string `json:"services,omitempty"`

	// Sources The network interfaces used for communication with the DNS server.
	// The network interfaces must have the `services` value of `data`.
	// Clear this by setting an empty list.
	Sources *[]Reference `json:"sources,omitempty"`
}

// DnsGetResponse defines model for DnsGetResponse.
type DnsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of dns objects.
	Items *[]Dns `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// DnsPost defines model for DnsPost.
type DnsPost struct {
	// Domain Domain suffix to be appended by the appliance when performing DNS lookups.
	Domain *string `json:"domain,omitempty"`

	// Nameservers List of DNS server IP addresses.
	Nameservers *[]string `json:"nameservers,omitempty"`

	// Services The list of services utilizing the DNS configuration.
	Services *[]string `json:"services,omitempty"`

	// Sources The network interfaces used for communication with the DNS server.
	// The network interfaces must have the `services` value of `data`.
	// Clear this by setting an empty list.
	Sources *[]Reference `json:"sources,omitempty"`
}

// DnsResponse defines model for DnsResponse.
type DnsResponse struct {
	// Items A list of dns objects.
	Items *[]Dns `json:"items,omitempty"`
}

// Drive defines model for Drive.
type Drive struct {
	// Details Details about the status of the drive if not healthy.
	Details *string `json:"details,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Progress Reflects this drive's current progress toward completing a planned
	// evacuation. If a planned evacuation is not occurring, the value will
	// be `null`.
	Progress    *float32 `json:"progress,omitempty"`
	RawCapacity *int64   `json:"raw_capacity,omitempty"`

	// Status Current status of the drive. Valid values are `evacuated`,
	// `evacuating`, `healthy`, `unhealthy`, `unused`, and `updating`.
	Status *string `json:"status,omitempty"`

	// Type The type of the module. Valid values are `DFM` and `DFMe`.
	Type *string `json:"type,omitempty"`
}

// DriveGetResponse defines model for DriveGetResponse.
type DriveGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of drive objects.
	Items *[]Drive `json:"items,omitempty"`
	Total *struct {
		// Details Details about the status of the drive if not healthy.
		Details *string `json:"details,omitempty"`

		// Id A non-modifiable, globally unique ID chosen by the system.
		Id *string `json:"id,omitempty"`

		// Name Name of the object (e.g., a file system or snapshot).
		Name *string `json:"name,omitempty"`

		// Progress Reflects this drive's current progress toward completing a planned
		// evacuation. If a planned evacuation is not occurring, the value will
		// be `null`.
		Progress    *float32 `json:"progress,omitempty"`
		RawCapacity *int64   `json:"raw_capacity,omitempty"`

		// Status Current status of the drive. Valid values are `evacuated`,
		// `evacuating`, `healthy`, `unhealthy`, `unused`, and `updating`.
		Status *string `json:"status,omitempty"`

		// Type The type of the module. Valid values are `DFM` and `DFMe`.
		Type *string `json:"type,omitempty"`
	} `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// Eula defines model for Eula.
type Eula struct {
	// Agreement The End User Agreement text.
	Agreement *string        `json:"agreement,omitempty"`
	Signature *EulaSignature `json:"signature,omitempty"`
}

// EulaGetResponse defines model for EulaGetResponse.
type EulaGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`
	Items             *[]Eula `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// EulaResponse defines model for EulaResponse.
type EulaResponse struct {
	Items *[]Eula `json:"items,omitempty"`
}

// FileInfo defines model for FileInfo.
type FileInfo struct {
	// Length Length of the file (in bytes).
	Length *int `json:"length,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// FileLock defines model for FileLock.
type FileLock struct {
	// AccessType Type of access the lock provides. Valid values are `shared`,
	// `exclusive` and `no-access`.
	AccessType *string `json:"access_type,omitempty"`

	// Client Reference to the file system client that holds the lock.
	Client *FixedReferenceNoId `json:"client,omitempty"`

	// CreatedAt Creation timestamp of the lock. Measured in milliseconds since the UNIX
	// epoch.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// Inode The inode of the file where the lock is found relative to the specified
	// `source`.
	Inode *int `json:"inode,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Path Path to the file where the lock is found relative to `source`.
	// If it is longer than 1023 characters, it will be truncated and only
	// the last 1023 characters will be returned.
	// If multiple hard links exist to the file on which the lock is held,
	// only one is returned.
	// This field will be `null` if the path cannot be resolved.
	Path *string `json:"path,omitempty"`

	// Protocol The protocol utilized for obtaining and managing the lock.
	// Valid values include `NLM`, `NFSv4.1` and `SMB`.
	Protocol *string `json:"protocol,omitempty"`

	// Range The range in bytes (`offset`, `length`) the lock covers within a file.
	// If the lock reaches the end of the file, the `length` will be `null`.
	// If the lock is set for the entire file, both `offset` and `length`
	// will be `null`.
	Range *FileLockRange `json:"range,omitempty"`

	// Source Reference to location where the path/inode can be found.
	Source *FixedReference `json:"source,omitempty"`
}

// FileLockGetResponse defines model for FileLockGetResponse.
type FileLockGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of file locks.
	Items *[]FileLock `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileLockNlmReclamationResponse defines model for FileLockNlmReclamationResponse.
type FileLockNlmReclamationResponse struct {
	Items *[]FileSystemLockNlmReclamation `json:"items,omitempty"`
}

// FileLockResponse defines model for FileLockResponse.
type FileLockResponse struct {
	// Items A list of file locks.
	Items *[]FileLock `json:"items,omitempty"`
}

// FileSession defines model for FileSession.
type FileSession struct {
	// Authentication Describes how was the user authenticated.
	// Valid values include `KRB` and `NTLMv2`.
	Authentication *string `json:"authentication,omitempty"`

	// Client Client that holds the session.
	Client *FixedReferenceNameOnly `json:"client,omitempty"`

	// ConnectionTime Connection time in milliseconds since UNIX epoch.
	ConnectionTime *int64 `json:"connection_time,omitempty"`

	// IdleTime Duration in milliseconds that indicates how long
	// the session has been idle.
	IdleTime *int64 `json:"idle_time,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Opens Number of opens for the given session.
	Opens *int64 `json:"opens,omitempty"`

	// Port Port number the client is connected from.
	Port *int64 `json:"port,omitempty"`

	// Protocol The protocol utilized for obtaining and managing the session.
	// Valid values include `nfs` and `smb`.
	Protocol *string `json:"protocol,omitempty"`

	// Time Current time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// User The user who has created the session.
	User *UserNoId `json:"user,omitempty"`
}

// FileSessionGetResponse defines model for FileSessionGetResponse.
type FileSessionGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of file sessions.
	Items *[]FileSession `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSessionResponse defines model for FileSessionResponse.
type FileSessionResponse struct {
	// Items A list of file sessions.
	Items *[]FileSession `json:"items,omitempty"`
}

// FileSystem defines model for FileSystem.
type FileSystem struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the file system.
	Created *int64 `json:"created,omitempty"`

	// DefaultGroupQuota The default space quota for a group writing to this file system.
	DefaultGroupQuota *int64 `json:"default_group_quota,omitempty"`

	// DefaultUserQuota The default space quota for a user writing to this file system.
	DefaultUserQuota *int64 `json:"default_user_quota,omitempty"`

	// Destroyed Returns a value of `true` if the file system has been destroyed and is pending eradication.
	// The file system cannot be modified while it is in the destroyed state.
	// The `time_remaining` value displays the amount of time left until the destroyed
	// file system is permanently eradicated. Once eradication has begun, the file system can no
	// longer be recovered. Before the `time_remaining` period has elapsed,
	// the destroyed file system can be recovered through the PATCH method
	// by setting `destroyed=false`.
	Destroyed *bool `json:"destroyed,omitempty"`

	// EradicationConfig Configuration settings related to file system eradication.
	EradicationConfig *FileSystemEradicationConfig `json:"eradication_config,omitempty"`

	// FastRemoveDirectoryEnabled If set to `true`, the file system, when mounted, will contain a
	// directory that can be used for fast removal of other directories.
	// Directories can be moved into the fast remove directory in order
	// to have them deleted, and their space freed, more quickly than a
	// normal removal operation.
	FastRemoveDirectoryEnabled *bool `json:"fast_remove_directory_enabled,omitempty"`

	// GroupOwnership The group ownership for new files and directories in a file system.
	// Possible values are `creator` and `parent-directory`.
	// If `creator` is selected, the owning group of new files and directories
	// is the primary group of the user who creates them.
	// If `parent-directory` is selected, the owning group is the parent
	// directory group.
	// Note: Existing files and directories are unaffected by this change.
	GroupOwnership *string `json:"group_ownership,omitempty"`

	// HardLimitEnabled If set to `true`, the file system's size, as defined by `provisioned`,
	// is used as a hard limit quota.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// Http HTTP configuration.
	Http *Http `json:"http,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// MultiProtocol Multi-protocol configuration.
	MultiProtocol *MultiProtocol `json:"multi_protocol,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Nfs NFS configuration.
	Nfs *Nfs `json:"nfs,omitempty"`

	// PromotionStatus Possible values are `promoted` and `demoted`.
	// The current status of the file system with respect to replication. Changes via
	// `requested_promotion_state`. The default for new file systems is
	// `promoted`.
	PromotionStatus *string `json:"promotion_status,omitempty"`

	// Provisioned The provisioned size of the file system, displayed in bytes. If set to an
	// empty string (`""`), the file system is unlimited in size.
	Provisioned *int64 `json:"provisioned,omitempty"`

	// QosPolicy The QoS policy for the File System defines the performance controls
	// that can be applied to the aggregate performance of all the clients
	// accessing the file system.
	// If no policy is configured for a file system, then no performance
	// controls are applied to it.
	QosPolicy *FixedReference `json:"qos_policy,omitempty"`

	// RequestedPromotionState Possible values are `promoted` and `demoted`.
	// The `demoted` state is used for replication targets and is only allowed to be set
	// if the file system is in a replica-link relationship. The additional
	// query param `discard-non-snapshotted-data` must be set to `true`
	// when demoting a file system. The default for new file systems is
	// `promoted`.
	RequestedPromotionState *string `json:"requested_promotion_state,omitempty"`

	// Smb SMB configuration.
	Smb *Smb `json:"smb,omitempty"`

	// SnapshotDirectoryEnabled If set to `true`, a hidden .snapshot directory will be present in each
	// directory of the file system when it is mounted.
	// The .snapshot directory allows clients read access to the contents of
	// the snapshots that have been taken of a directory.
	// If set to `false`, the .snapshot directory will not be present in any
	// directories within a mounted file system.
	SnapshotDirectoryEnabled *bool `json:"snapshot_directory_enabled,omitempty"`

	// Source A reference to the source file system.
	Source *LocationReference `json:"source,omitempty"`

	// Space The space usage of the file system.
	Space        *Space            `json:"space,omitempty"`
	StorageClass *StorageClassInfo `json:"storage_class,omitempty"`

	// TimeRemaining Time in milliseconds before the file system is eradicated.
	// `null` if not destroyed.
	TimeRemaining *int64 `json:"time_remaining,omitempty"`

	// Writable Whether the file system is writable or not. If `false`, this overrides
	// any protocol or file permission settings and prevents changes. If `true`, then
	// the protocol and file permission settings are evaluated.
	// If not specified, defaults to `true`. Modifiable.
	Writable *bool `json:"writable,omitempty"`
}

// FileSystemClient defines model for FileSystemClient.
type FileSystemClient = BuiltInNoId

// FileSystemClientsGetResponse defines model for FileSystemClientsGetResponse.
type FileSystemClientsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of file system clients.
	Items *[]FileSystemClient `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemClientsResponse defines model for FileSystemClientsResponse.
type FileSystemClientsResponse struct {
	// Items A list of file system clients.
	Items *[]FileSystemClient `json:"items,omitempty"`
}

// FileSystemExport defines model for FileSystemExport.
type FileSystemExport struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled Returns a value of `true` if and only if the export policy that manages this
	// export is enabled AND the protocol is enabled on the file system.
	Enabled *bool `json:"enabled,omitempty"`

	// ExportName The name of the export used by clients to mount the file system.
	// Export names must be unique within the same protocol/server combination.
	ExportName *string `json:"export_name,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Member Reference to the file system the policy is applied to.
	Member *FixedReference `json:"member,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy Reference to the NFS export policy or SMB client policy.
	Policy *Reference `json:"policy,omitempty"`

	// PolicyType Policy type attached to the export. It is either SMB or NFS.
	PolicyType *string `json:"policy_type,omitempty"`

	// Server Reference to the server the export will be visible on.
	Server *FixedReference `json:"server,omitempty"`

	// SharePolicy Reference to the SMB share policy (only used for SMB).
	SharePolicy *Reference `json:"share_policy,omitempty"`

	// Status Explains why `enabled` is `false`. Valid values include `policy_disabled`
	// and `protocol_disabled`.
	Status *string `json:"status,omitempty"`
}

// FileSystemExportGetResponse defines model for FileSystemExportGetResponse.
type FileSystemExportGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of file system export objects.
	Items *[]FileSystemExport `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemExportPost defines model for FileSystemExportPost.
type FileSystemExportPost struct {
	// ExportName The name of the export to create.
	// Export names must be unique within the same protocol and server.
	ExportName *string `json:"export_name,omitempty"`

	// Server Reference to the server the export will be visible on.
	Server *Reference `json:"server,omitempty"`

	// SharePolicy Reference to the SMB share policy (only used for SMB).
	SharePolicy *Reference `json:"share_policy,omitempty"`
}

// FileSystemExportResponse defines model for FileSystemExportResponse.
type FileSystemExportResponse struct {
	// Items A list of file system export objects.
	Items *[]FileSystemExport `json:"items,omitempty"`
}

// FileSystemGetResponse defines model for FileSystemGetResponse.
type FileSystemGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of file system objects.
	Items *[]FileSystem `json:"items,omitempty"`
	Total *FileSystem   `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemGroupPerformance defines model for FileSystemGroupPerformance.
type FileSystemGroupPerformance struct {
	// BytesPerOp Average operation size (read bytes+write bytes/read ops+write ops).
	BytesPerOp *float64 `json:"bytes_per_op,omitempty"`

	// BytesPerRead Average read size in bytes per read operation.
	BytesPerRead *float64 `json:"bytes_per_read,omitempty"`

	// BytesPerWrite Average write size in bytes per write operation.
	BytesPerWrite *float64 `json:"bytes_per_write,omitempty"`

	// FileSystem The file system on which the performance was measured.
	FileSystem *FixedReference `json:"file_system,omitempty"`

	// Group The group whose performance is represented.
	Group *Group `json:"group,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadBytesPerSec Bytes read per second.
	ReadBytesPerSec *float64 `json:"read_bytes_per_sec,omitempty"`

	// ReadsPerSec Read requests processed per second.
	ReadsPerSec *float64 `json:"reads_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadOp Average time, measured in microseconds, it takes the array to process
	// a read request.
	UsecPerReadOp *float64 `json:"usec_per_read_op,omitempty"`

	// UsecPerWriteOp Average time, measured in microseconds, it takes the array to process
	// a write request.
	UsecPerWriteOp *float64 `json:"usec_per_write_op,omitempty"`

	// WriteBytesPerSec Bytes written per second.
	WriteBytesPerSec *float64 `json:"write_bytes_per_sec,omitempty"`

	// WritesPerSec Write requests processed per second.
	WritesPerSec *float64 `json:"writes_per_sec,omitempty"`
}

// FileSystemGroupsPerformanceGetResponse defines model for FileSystemGroupsPerformanceGetResponse.
type FileSystemGroupsPerformanceGetResponse struct {
	// Items A list of file system group performance objects.
	Items *[]FileSystemGroupPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]FileSystemGroupPerformance `json:"total,omitempty"`
}

// FileSystemLockNlmReclamation defines model for FileSystemLockNlmReclamation.
type FileSystemLockNlmReclamation struct {
	// End End time of the NLM reclamation in milliseconds since the UNIX epoch.
	End *int64 `json:"end,omitempty"`

	// Start Start time of the NLM reclamation in milliseconds since the UNIX epoch.
	Start *int64 `json:"start,omitempty"`
}

// FileSystemOpenFile defines model for FileSystemOpenFile.
type FileSystemOpenFile struct {
	// Client Client that has the file open.
	Client *FixedReferenceNameOnly `json:"client,omitempty"`

	// Id The unique identifier of the open file.
	Id *string `json:"id,omitempty"`

	// LockCount The number of locks on the file.
	LockCount *int32 `json:"lock_count,omitempty"`

	// Mode The mode in which the file is open: "ro" for Read-Only, "wo" for Write-Only, "rw" for
	// Read-Write or "no-access" if no read or write access was granted.
	Mode *string `json:"mode,omitempty"`

	// Path The path to the open file.
	Path *string `json:"path,omitempty"`

	// Session The name of the session with the open file.
	Session *FixedReferenceNameOnly `json:"session,omitempty"`

	// Source Reference to the file system.
	Source *FixedReference `json:"source,omitempty"`

	// User The user who has the file open.
	User *UserNoId `json:"user,omitempty"`
}

// FileSystemOpenFilesGetResponse defines model for FileSystemOpenFilesGetResponse.
type FileSystemOpenFilesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of file system open file objects.
	Items *[]FileSystemOpenFile `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemOpenFilesResponse defines model for FileSystemOpenFilesResponse.
type FileSystemOpenFilesResponse struct {
	// Items A list of file system open file objects.
	Items *[]FileSystemOpenFile `json:"items,omitempty"`
}

// FileSystemPatch defines model for FileSystemPatch.
type FileSystemPatch struct {
	// Created Creation timestamp of the file system.
	Created *int64 `json:"created,omitempty"`

	// DefaultGroupQuota The default space quota for a group writing to this file system.
	DefaultGroupQuota *int64 `json:"default_group_quota,omitempty"`

	// DefaultUserQuota The default space quota for a user writing to this file system.
	DefaultUserQuota *int64 `json:"default_user_quota,omitempty"`

	// Destroyed Returns a value of `true` if the file system has been destroyed and is pending eradication.
	// The file system cannot be modified while it is in the destroyed state.
	// The `time_remaining` value displays the amount of time left until the destroyed
	// file system is permanently eradicated. Once eradication has begun, the file system can no
	// longer be recovered. Before the `time_remaining` period has elapsed,
	// the destroyed file system can be recovered through the PATCH method
	// by setting `destroyed=false`.
	Destroyed *bool `json:"destroyed,omitempty"`

	// FastRemoveDirectoryEnabled If set to `true`, the file system, when mounted, will contain a
	// directory that can be used for fast removal of other directories.
	// Directories can be moved into the fast remove directory in order
	// to have them deleted, and their space freed, more quickly than a
	// normal removal operation.
	FastRemoveDirectoryEnabled *bool `json:"fast_remove_directory_enabled,omitempty"`

	// GroupOwnership The group ownership for new files and directories in a file system.
	// Possible values are `creator` and `parent-directory`.
	// If `creator` is selected, the owning group of new files and directories
	// is the primary group of the user who creates them.
	// If `parent-directory` is selected, the owning group is the parent
	// directory group.
	// Note: Existing files and directories are unaffected by this change.
	GroupOwnership *string `json:"group_ownership,omitempty"`

	// HardLimitEnabled If set to `true`, the file system's size, as defined by `provisioned`,
	// is used as a hard limit quota.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// Http HTTP configuration.
	Http *Http `json:"http,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// MultiProtocol Multi-protocol configuration.
	MultiProtocol *MultiProtocol `json:"multi_protocol,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Nfs NFS configuration.
	Nfs *NfsPatch `json:"nfs,omitempty"`

	// PromotionStatus Possible values are `promoted` and `demoted`.
	// The current status of the file system with respect to replication. Changes via
	// `requested_promotion_state`. The default for new file systems is
	// `promoted`.
	PromotionStatus *string `json:"promotion_status,omitempty"`

	// Provisioned The provisioned size of the file system, displayed in bytes. If set to an
	// empty string (`""`), the file system is unlimited in size.
	Provisioned *int64 `json:"provisioned,omitempty"`

	// QosPolicy The QoS policy for the File System defines the performance controls
	// that can be applied to the aggregate performance of all the clients
	// accessing the file system.
	// If no policy is configured for a file system, then no performance
	// controls are applied to it.
	// Use "" to clear an attached policy.
	QosPolicy *Reference `json:"qos_policy,omitempty"`

	// RequestedPromotionState Possible values are `promoted` and `demoted`.
	// The `demoted` state is used for replication targets and is only allowed to be set
	// if the file system is in a replica-link relationship. The additional
	// query param `discard-non-snapshotted-data` must be set to `true`
	// when demoting a file system. The default for new file systems is
	// `promoted`.
	RequestedPromotionState *string `json:"requested_promotion_state,omitempty"`

	// Smb SMB configuration.
	Smb *Smb `json:"smb,omitempty"`

	// SnapshotDirectoryEnabled If set to `true`, a hidden .snapshot directory will be present in each
	// directory of the file system when it is mounted.
	// The .snapshot directory allows clients read access to the contents of
	// the snapshots that have been taken of a directory.
	// If set to `false`, the .snapshot directory will not be present in any
	// directories within a mounted file system.
	SnapshotDirectoryEnabled *bool `json:"snapshot_directory_enabled,omitempty"`

	// Source A reference to the source file system.
	Source       *FixedLocationReference `json:"source,omitempty"`
	StorageClass *StorageClassInfo       `json:"storage_class,omitempty"`

	// TimeRemaining Time in milliseconds before the file system is eradicated.
	// `null` if not destroyed.
	TimeRemaining *int64 `json:"time_remaining,omitempty"`

	// Writable Whether the file system is writable or not. If `false`, this overrides
	// any protocol or file permission settings and prevents changes. If `true`, then
	// the protocol and file permission settings are evaluated.
	// If not specified, defaults to `true`. Modifiable.
	Writable *bool `json:"writable,omitempty"`
}

// FileSystemPerformance defines model for FileSystemPerformance.
type FileSystemPerformance struct {
	// BytesPerOp Average operation size (read bytes+write bytes/read ops+write ops).
	BytesPerOp *float64 `json:"bytes_per_op,omitempty"`

	// BytesPerRead Average read size in bytes per read operation.
	BytesPerRead *float64 `json:"bytes_per_read,omitempty"`

	// BytesPerWrite Average write size in bytes per write operation.
	BytesPerWrite *float64 `json:"bytes_per_write,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadBytesPerSec Bytes read per second.
	ReadBytesPerSec *float64 `json:"read_bytes_per_sec,omitempty"`

	// ReadsPerSec Read requests processed per second.
	ReadsPerSec *float64 `json:"reads_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadOp Average time, measured in microseconds, it takes the array to process
	// a read request.
	UsecPerReadOp *float64 `json:"usec_per_read_op,omitempty"`

	// UsecPerWriteOp Average time, measured in microseconds, it takes the array to process
	// a write request.
	UsecPerWriteOp *float64 `json:"usec_per_write_op,omitempty"`

	// WriteBytesPerSec Bytes written per second.
	WriteBytesPerSec *float64 `json:"write_bytes_per_sec,omitempty"`

	// WritesPerSec Write requests processed per second.
	WritesPerSec *float64 `json:"writes_per_sec,omitempty"`
}

// FileSystemPerformanceGetResponse defines model for FileSystemPerformanceGetResponse.
type FileSystemPerformanceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of file system performance objects.
	Items *[]FileSystemPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]FileSystemPerformance `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemPost defines model for FileSystemPost.
type FileSystemPost struct {
	// DefaultGroupQuota The default space quota for a group writing to this file system.
	DefaultGroupQuota *int64 `json:"default_group_quota,omitempty"`

	// DefaultUserQuota The default space quota for a user writing to this file system.
	DefaultUserQuota *int64 `json:"default_user_quota,omitempty"`

	// EradicationConfig Configuration settings related to file system eradication.
	EradicationConfig *FileSystemEradicationConfig `json:"eradication_config,omitempty"`

	// FastRemoveDirectoryEnabled If set to `true`, the file system, when mounted, will contain a
	// directory that can be used for fast removal of other directories.
	// Directories can be moved into the fast remove directory in order
	// to have them deleted, and their space freed, more quickly than a
	// normal removal operation.
	// If not specified, defaults to `false`.
	FastRemoveDirectoryEnabled *bool `json:"fast_remove_directory_enabled,omitempty"`

	// GroupOwnership The group ownership for new files and directories in a file system.
	// Possible values are `creator` and `parent-directory`.
	// If `creator` is selected, the owning group of new files and directories
	// is the primary group of the user who creates them.
	// If `parent-directory` is selected, the owning group is the parent
	// directory group.
	// Note: Existing files and directories are unaffected by this change.
	// If not specified, defaults to `creator`.
	GroupOwnership *string `json:"group_ownership,omitempty"`

	// HardLimitEnabled If set to `true`, the file system's size, as defined by `provisioned`,
	// is used as a hard limit quota. If not specified, defaults to `false`.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// Http HTTP configuration.
	Http *Http `json:"http,omitempty"`

	// MultiProtocol Multi-protocol configuration.
	MultiProtocol *MultiProtocolPost `json:"multi_protocol,omitempty"`

	// Nfs NFS configuration.
	Nfs *Nfs `json:"nfs,omitempty"`

	// Provisioned The provisioned size of the file system, displayed in bytes. If set to an
	// empty string (`""`), the file system is unlimited in size.
	// If not specified, defaults to unlimited.
	Provisioned *int64 `json:"provisioned,omitempty"`

	// QosPolicy The QoS policy for the File System defines the performance controls
	// that can be applied to the aggregate performance of all the clients
	// accessing the file system.
	// If no policy is set here, no explicit performance controls are applied
	// to the file system beyond the system's default fairness.
	QosPolicy *Reference `json:"qos_policy,omitempty"`

	// RequestedPromotionState Possible values are `promoted` and `demoted`.
	// The `demoted` state is used for replication targets and is only allowed to be set
	// if the file system is in a replica-link relationship. The additional
	// query param `discard-non-snapshotted-data` must be set to `true`
	// when demoting a file system. The default for new file systems is
	// `promoted`.
	RequestedPromotionState *string `json:"requested_promotion_state,omitempty"`

	// Smb SMB configuration.
	Smb *SmbPost `json:"smb,omitempty"`

	// SnapshotDirectoryEnabled If set to `true`, a hidden .snapshot directory will be present in each
	// directory of the file system when it is mounted.
	// The .snapshot directory allows clients read access to the contents of
	// the snapshots that have been taken of a directory.
	// If set to `false`, the .snapshot directory will not be present in any
	// directories within a mounted file system. If not specified, defaults to `true`.
	SnapshotDirectoryEnabled *bool `json:"snapshot_directory_enabled,omitempty"`

	// Source The source snapshot whose data is copied to the file system specified.
	Source *Reference `json:"source,omitempty"`

	// Writable Whether the file system is writable or not. If `false`, this overrides
	// any protocol or file permission settings and prevents changes. If `true`, then
	// the protocol and file permission settings are evaluated.
	// If not specified, defaults to `true`. Modifiable.
	Writable *bool `json:"writable,omitempty"`
}

// FileSystemReplicaLink defines model for FileSystemReplicaLink.
type FileSystemReplicaLink struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Direction The direction of replication. Valid values are `inbound` and
	// `outbound`.
	Direction *Direction `json:"direction,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Lag Duration in milliseconds that represents how far
	// behind the replication target is from the source.
	// This is the time difference between current time and `recovery_point`.
	Lag *int64 `json:"lag,omitempty"`

	// LinkType Type of the replica link.
	// Values include `full-replica`, and `partial-replica`.
	LinkType *string `json:"link_type,omitempty"`

	// LocalFileSystem Reference to a local file system.
	LocalFileSystem *FixedReference      `json:"local_file_system,omitempty"`
	Policies        *[]LocationReference `json:"policies,omitempty"`

	// RecoveryPoint Time when the last replicated snapshot was created, in milliseconds
	// since UNIX epoch. I.e. the recovery point if the file system is promoted.
	RecoveryPoint *int64 `json:"recovery_point,omitempty"`

	// Remote Reference to a remote array.
	Remote *FixedReferenceNoResourceType `json:"remote,omitempty"`

	// RemoteFileSystem Reference to a remote file system.
	RemoteFileSystem *FixedReferenceNoResourceType `json:"remote_file_system,omitempty"`

	// Status Status of the replica link.
	// Values include `replicating`, `idle`, and `unhealthy`.
	Status *string `json:"status,omitempty"`

	// StatusDetails Detailed information about the status of the replica link when it is
	// unhealthy.
	StatusDetails *string `json:"status_details,omitempty"`
}

// FileSystemReplicaLinkGetResponse defines model for FileSystemReplicaLinkGetResponse.
type FileSystemReplicaLinkGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of file system replica link objects.
	Items *[]FileSystemReplicaLink `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemReplicaLinkResponse defines model for FileSystemReplicaLinkResponse.
type FileSystemReplicaLinkResponse struct {
	// Items A list of file system replica link objects.
	Items *[]FileSystemReplicaLink `json:"items,omitempty"`
}

// FileSystemResponse defines model for FileSystemResponse.
type FileSystemResponse struct {
	// Items A list of file system objects.
	Items *[]FileSystem `json:"items,omitempty"`
}

// FileSystemSnapshot defines model for FileSystemSnapshot.
type FileSystemSnapshot struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the object.
	Created *int64 `json:"created,omitempty"`

	// Destroyed Is the file system snapshot destroyed? If not specified, defaults to
	// `false`.
	Destroyed *bool `json:"destroyed,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Owner A reference to the file system that owns this snapshot.
	// If the owner is destroyed, this will be destroyed.
	Owner *FixedReference `json:"owner,omitempty"`

	// OwnerDestroyed Is the owning file system destroyed?
	OwnerDestroyed *bool `json:"owner_destroyed,omitempty"`

	// Policies An array of references to the associated policies.
	Policies *[]FixedLocationReference `json:"policies,omitempty"`

	// Policy A reference to the associated policy that drives the behavior of the
	// snapshot.
	Policy *FixedLocationReference `json:"policy,omitempty"`

	// Source A reference to the file system that was the source of the data in
	// this snapshot. Normally this is the same as the owner, but if
	// the snapshot is replicated, the source is the original file system.
	Source *FixedLocationReference `json:"source,omitempty"`

	// Suffix The suffix of the snapshot, e.g., `snap1`.
	Suffix *string `json:"suffix,omitempty"`

	// TimeRemaining Time in milliseconds before the file system snapshot is eradicated.
	// `null` if not destroyed.
	TimeRemaining *int64 `json:"time_remaining,omitempty"`
}

// FileSystemSnapshotGetResponse defines model for FileSystemSnapshotGetResponse.
type FileSystemSnapshotGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of file system snapshot objects.
	Items *[]FileSystemSnapshot `json:"items,omitempty"`

	// Total If `total_only` query param is `true`, then it will be a total of
	// all records after filtering and no items will be returned.
	// If `total_only` is `false`, then it will be a total of all records
	// on this page.
	Total *FileSystemSnapshot `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemSnapshotGetTransferResponse defines model for FileSystemSnapshotGetTransferResponse.
type FileSystemSnapshotGetTransferResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of file system snapshot objects.
	Items *[]FileSystemSnapshotTransfer `json:"items,omitempty"`

	// Total If `total_only` query param is `true`, then it will be a total of
	// all records after filtering and no items will be returned.
	// If `total_only` is `false`, then it will be a total of all records
	// on this page.
	Total *FileSystemSnapshotTransfer `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FileSystemSnapshotPost defines model for FileSystemSnapshotPost.
type FileSystemSnapshotPost struct {
	// Suffix The suffix of the snapshot, e.g., `snap1`.
	Suffix *string `json:"suffix,omitempty"`
}

// FileSystemSnapshotResponse defines model for FileSystemSnapshotResponse.
type FileSystemSnapshotResponse struct {
	// Items A list of file system snapshot objects.
	Items *[]FileSystemSnapshot `json:"items,omitempty"`
}

// FileSystemSnapshotTransfer defines model for FileSystemSnapshotTransfer.
type FileSystemSnapshotTransfer struct {
	// Completed A timestamp at which the replication of the snapshot completed.
	Completed *int64 `json:"completed,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// DataTransferred The amount of data transferred to the target, in bytes.
	DataTransferred *int64 `json:"data_transferred,omitempty"`

	// Direction The direction of replication. Valid values are `inbound` and
	// `outbound`.
	Direction *Direction `json:"direction,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// LocalSnapshot A reference to the associated local file system snapshot.
	LocalSnapshot *FixedReferenceNoResourceType `json:"local_snapshot,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Progress A percentage that indicates
	// how much progress has been made on the transfer.
	Progress *float64 `json:"progress,omitempty"`

	// Remote The array where the remote file system snapshot is located.
	Remote *FixedReferenceNoResourceType `json:"remote,omitempty"`

	// RemoteSnapshot A reference to the associated remote file system snapshot.
	RemoteSnapshot *FixedReferenceNoResourceType `json:"remote_snapshot,omitempty"`

	// Started A timestamp at which the replication of the snapshot started.
	Started *int64 `json:"started,omitempty"`

	// Status The status of current replication.
	// Valid values are `completed`, `in-progress`, and `queued`.
	Status *string `json:"status,omitempty"`
}

// FileSystemSnapshotTransferResponse defines model for FileSystemSnapshotTransferResponse.
type FileSystemSnapshotTransferResponse struct {
	// Items A list of file system snapshot objects.
	Items *[]FileSystemSnapshotTransfer `json:"items,omitempty"`
}

// FileSystemUserPerformance defines model for FileSystemUserPerformance.
type FileSystemUserPerformance struct {
	// BytesPerOp Average operation size (read bytes+write bytes/read ops+write ops).
	BytesPerOp *float64 `json:"bytes_per_op,omitempty"`

	// BytesPerRead Average read size in bytes per read operation.
	BytesPerRead *float64 `json:"bytes_per_read,omitempty"`

	// BytesPerWrite Average write size in bytes per write operation.
	BytesPerWrite *float64 `json:"bytes_per_write,omitempty"`

	// FileSystem The file system on which the performance was measured.
	FileSystem *FixedReference `json:"file_system,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OthersPerSec Other operations processed per second.
	OthersPerSec *float64 `json:"others_per_sec,omitempty"`

	// ReadBytesPerSec Bytes read per second.
	ReadBytesPerSec *float64 `json:"read_bytes_per_sec,omitempty"`

	// ReadsPerSec Read requests processed per second.
	ReadsPerSec *float64 `json:"reads_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// UsecPerOtherOp Average time, measured in microseconds, it takes the array to process
	// other operations.
	UsecPerOtherOp *float64 `json:"usec_per_other_op,omitempty"`

	// UsecPerReadOp Average time, measured in microseconds, it takes the array to process
	// a read request.
	UsecPerReadOp *float64 `json:"usec_per_read_op,omitempty"`

	// UsecPerWriteOp Average time, measured in microseconds, it takes the array to process
	// a write request.
	UsecPerWriteOp *float64 `json:"usec_per_write_op,omitempty"`

	// User The user whose performance is represented.
	User *User `json:"user,omitempty"`

	// WriteBytesPerSec Bytes written per second.
	WriteBytesPerSec *float64 `json:"write_bytes_per_sec,omitempty"`

	// WritesPerSec Write requests processed per second.
	WritesPerSec *float64 `json:"writes_per_sec,omitempty"`
}

// FileSystemUsersPerformanceGetResponse defines model for FileSystemUsersPerformanceGetResponse.
type FileSystemUsersPerformanceGetResponse struct {
	// Items A list of file system user performance objects.
	Items *[]FileSystemUserPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]FileSystemUserPerformance `json:"total,omitempty"`
}

// Fleet defines model for Fleet.
type Fleet struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal If set to `true`, the current array is a member of the fleet.
	IsLocal *bool `json:"is_local,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`
}

// FleetGetResponse defines model for FleetGetResponse.
type FleetGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items Returns a list of all items after filtering.
	// If applicable, the values are displayed for each name.
	Items *[]Fleet `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FleetKey defines model for FleetKey.
type FleetKey struct {
	// Created Creation time in milliseconds since UNIX epoch.
	Created *int64 `json:"created,omitempty"`

	// Expires Expiration time in milliseconds since UNIX epoch.
	Expires *int64 `json:"expires,omitempty"`

	// FleetKey Fleet key, used for fleet connections.
	// After creation, listing will only show ****.
	FleetKey *string `json:"fleet_key,omitempty"`
}

// FleetKeyGetResponse defines model for FleetKeyGetResponse.
type FleetKeyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string     `json:"continuation_token,omitempty"`
	Items             *[]FleetKey `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FleetKeyResponse defines model for FleetKeyResponse.
type FleetKeyResponse struct {
	Items *[]FleetKey `json:"items,omitempty"`
}

// FleetMember defines model for FleetMember.
type FleetMember struct {
	Fleet  *FixedReferenceWithIsLocal `json:"fleet,omitempty"`
	Member *FixedReferenceWithIsLocal `json:"member,omitempty"`

	// Status Current fleet membership status.
	// Valid values include: `joining`, `joined`, or `removing`.
	// A status of `joining` indicates that the member is attempting to join the fleet.
	// A status of `joined` indicates that the member has joined the fleet.
	// A status of `removing` indicates that the member is being removed from the fleet.
	Status *string `json:"status,omitempty"`

	// StatusDetails Describes the error, if any.
	StatusDetails *string `json:"status_details,omitempty"`
}

// FleetMemberGetResponse defines model for FleetMemberGetResponse.
type FleetMemberGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items Returns a list of all items after filtering.
	// If applicable, the values are displayed for each name.
	Items *[]FleetMember `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// FleetMemberPost defines model for FleetMemberPost.
type FleetMemberPost struct {
	// Members Info about the members being added to fleet.
	Members *[]FleetMemberPostMembers `json:"members,omitempty"`
}

// FleetMemberResponse defines model for FleetMemberResponse.
type FleetMemberResponse struct {
	// Items Returns a list of all items after filtering.
	// If applicable, the values are displayed for each name.
	Items *[]FleetMember `json:"items,omitempty"`
}

// FleetPatch defines model for FleetPatch.
type FleetPatch struct {
	// Name The new name for the resource.
	Name *string `json:"name,omitempty"`
}

// FleetResponse defines model for FleetResponse.
type FleetResponse struct {
	// Items Returns a list of all items after filtering.
	// If applicable, the values are displayed for each name.
	Items *[]Fleet `json:"items,omitempty"`
}

// GroupQuota defines model for GroupQuota.
type GroupQuota struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context    *Reference      `json:"context,omitempty"`
	FileSystem *FixedReference `json:"file_system,omitempty"`

	// FileSystemDefaultQuota File system's default group quota (in bytes). If it is `0`, it means
	// there is no default quota. This will be the effective group quota if
	// the group doesn't have an individual quota. This default quota is set
	// through the `file-systems` endpoint.
	FileSystemDefaultQuota *int64 `json:"file_system_default_quota,omitempty"`

	// Group The group on which this quota is enforced.
	Group *Group `json:"group,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Quota The space limit of the quota (in bytes) for the specified group, cannot
	// be `0`. If specified, this value will override the file system's default
	// group quota.
	Quota *int64 `json:"quota,omitempty"`

	// Usage The usage of the file system (in bytes) by the specified group.
	Usage *int64 `json:"usage,omitempty"`
}

// GroupQuotaGetResponse defines model for GroupQuotaGetResponse.
type GroupQuotaGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of quota objects.
	Items *[]GroupQuota `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// GroupQuotaPatch defines model for GroupQuotaPatch.
type GroupQuotaPatch = GroupQuotaPost

// GroupQuotaPost defines model for GroupQuotaPost.
type GroupQuotaPost struct {
	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Quota The space limit of the quota (in bytes) for the specified group, cannot
	// be `0`. If specified, this value will override the file system's default
	// group quota.
	Quota int64 `json:"quota"`
}

// GroupQuotaResponse defines model for GroupQuotaResponse.
type GroupQuotaResponse struct {
	// Items A list of quota objects.
	Items *[]GroupQuota `json:"items,omitempty"`
}

// Hardware defines model for Hardware.
type Hardware struct {
	// DataMac Ethernet (data) MAC address
	DataMac *string `json:"data_mac,omitempty"`

	// Details Details about the status of the component if not healthy.
	Details *string `json:"details,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IdentifyEnabled State of an LED used to visually identify the component.
	IdentifyEnabled *bool `json:"identify_enabled,omitempty"`

	// Index Number that identifies the relative position of a hardware component
	// within the array.
	Index *int32 `json:"index,omitempty"`

	// ManagementMac Hardware component (burned-in) MAC address
	ManagementMac *string `json:"management_mac,omitempty"`

	// Model Model number of the hardware component.
	Model *string `json:"model,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PartNumber Part number of the hardware component.
	PartNumber *string `json:"part_number,omitempty"`

	// Serial Serial number of the hardware component.
	Serial *string `json:"serial,omitempty"`

	// Slot Slot number occupied by the PCI Express card that hosts the component.
	Slot *int32 `json:"slot,omitempty"`

	// Speed The maximum speed (in b/s) at which the component is capable of operating.
	Speed *int64 `json:"speed,omitempty"`

	// Status Component status.
	// Valid values are `critical`, `healthy`, `identifying`, `unhealthy`,
	// `unknown`, and `unused`.
	Status *string `json:"status,omitempty"`

	// Temperature Temperature (in degrees celsius) reported by the component.
	Temperature *int32 `json:"temperature,omitempty"`

	// Type Type of hardware component.
	// Valid values are `bay`, `ch`, `eth`, `fan`, `fb`, `fm`, `pwr`, and `xfm`.
	Type *string `json:"type,omitempty"`
}

// HardwareConnector defines model for HardwareConnector.
type HardwareConnector struct {
	// ConnectorType Form-factor of the interface.
	// Valid values include `QSFP` and `RJ-45`.
	ConnectorType *string `json:"connector_type,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// LaneSpeed Configured speed of each lane in the connector in bits-per-second.
	LaneSpeed *int64 `json:"lane_speed,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PortCount Configured number of ports in the connector (1/2/4 for QSFP).
	PortCount *int64 `json:"port_count,omitempty"`

	// PortSpeed Configured speed of each port in the connector in bits-per-second.
	PortSpeed *int64 `json:"port_speed,omitempty"`

	// TransceiverType Details about the transceiver which is plugged into the connector port.
	// Transceiver type will be read-only for pureuser. If nothing is plugged
	// into QSFP port, value will be `Unused` and type cannot be auto-detected,
	// and internal user has not specified a type - value will be `Unknown`.
	// If transceiver is plugged in, and type is auto-detected, and/or type
	// has been explicitly set by internal user - that value will be shown.
	// Transceiver type is not applicable for RJ-45 connectors.
	TransceiverType *string `json:"transceiver_type,omitempty"`
}

// HardwareConnectorGetResponse defines model for HardwareConnectorGetResponse.
type HardwareConnectorGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of connector objects.
	Items *[]HardwareConnector `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// HardwareConnectorPerformance defines model for HardwareConnectorPerformance.
type HardwareConnectorPerformance struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// LinkAggregationGroup The link aggregation group which this entity belongs to.
	LinkAggregationGroup *FixedReference `json:"link_aggregation_group,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OtherErrorsPerSec The sum of unspecified reception and transmission errors per second.
	OtherErrorsPerSec *int64 `json:"other_errors_per_sec,omitempty"`

	// ReceivedBytesPerSec Bytes received per second.
	ReceivedBytesPerSec *int64 `json:"received_bytes_per_sec,omitempty"`

	// ReceivedCrcErrorsPerSec Reception CRC errors per second.
	ReceivedCrcErrorsPerSec *int64 `json:"received_crc_errors_per_sec,omitempty"`

	// ReceivedFrameErrorsPerSec Received packet frame errors per second.
	ReceivedFrameErrorsPerSec *int64 `json:"received_frame_errors_per_sec,omitempty"`

	// ReceivedPacketsPerSec Packets received per second.
	ReceivedPacketsPerSec *int64 `json:"received_packets_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// TotalErrorsPerSec The sum of all reception and transmission errors per second.
	TotalErrorsPerSec *int64 `json:"total_errors_per_sec,omitempty"`

	// TransmittedBytesPerSec Bytes transmitted per second.
	TransmittedBytesPerSec *int64 `json:"transmitted_bytes_per_sec,omitempty"`

	// TransmittedCarrierErrorsPerSec Transmission carrier errors per second.
	TransmittedCarrierErrorsPerSec *int64 `json:"transmitted_carrier_errors_per_sec,omitempty"`

	// TransmittedDroppedErrorsPerSec Transmitted packets dropped per second.
	TransmittedDroppedErrorsPerSec *int64 `json:"transmitted_dropped_errors_per_sec,omitempty"`

	// TransmittedPacketsPerSec Packets transmitted per second.
	TransmittedPacketsPerSec *int64 `json:"transmitted_packets_per_sec,omitempty"`
}

// HardwareConnectorPerformanceGetResponse defines model for HardwareConnectorPerformanceGetResponse.
type HardwareConnectorPerformanceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of hardware connector performance objects.
	Items *[]HardwareConnectorPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no individual items will be returned.
	Total *[]HardwareConnectorPerformance `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// HardwareConnectorResponse defines model for HardwareConnectorResponse.
type HardwareConnectorResponse struct {
	// Items A list of connector objects.
	Items *[]HardwareConnector `json:"items,omitempty"`
}

// HardwareGetResponse defines model for HardwareGetResponse.
type HardwareGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of hardware component objects.
	Items *[]Hardware `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// HardwareResponse defines model for HardwareResponse.
type HardwareResponse struct {
	// Items A list of hardware component objects.
	Items *[]Hardware `json:"items,omitempty"`
}

// Keytab defines model for Keytab.
type Keytab struct {
	// EncryptionType The encryption type used by the Kerberos key distribution center to
	// generate the keytab.
	EncryptionType *string `json:"encryption_type,omitempty"`

	// Fqdn The fully qualified domain name to which the keytab was issued.
	Fqdn *string `json:"fqdn,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Kvno The key version number of the key used to generate the keytab.
	Kvno *int64 `json:"kvno,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Prefix The prefix in the name of the keytab object. This is the same for
	// all keytab objects created from a single keytab file. The name of
	// a keytab entry is created in the format `<prefix>.<suffix>` for all
	// entries.
	Prefix *string `json:"prefix,omitempty"`

	// Principal The service name for which the keytab was issued.
	Principal *string `json:"principal,omitempty"`

	// Realm The Kerberos realm that issued the keytab.
	Realm *string `json:"realm,omitempty"`

	// Server The server where the keytab is used.
	Server *FixedReference `json:"server,omitempty"`

	// Source A reference to the Active Directory configuration for the computer account
	// that was used to create this keytab. If this keytab was uploaded from a
	// file, all fields in the reference possess `null` values.
	Source *FixedReference `json:"source,omitempty"`

	// Suffix The suffix in the name of the keytab object, determined at creation
	// time using the slot number of the keytab entry in a file and the
	// number of existing entries with the same prefix. The name of a
	// keytab entry is created in the format `<prefix>.<suffix>` for all
	// entries.
	Suffix *int64 `json:"suffix,omitempty"`
}

// KeytabFileResponse A Kerberos keytab file.
type KeytabFileResponse = openapi_types.File

// KeytabGetResponse defines model for KeytabGetResponse.
type KeytabGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of Kerberos keytab objects.
	Items *[]Keytab `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// KeytabPost defines model for KeytabPost.
type KeytabPost struct {
	// Source A reference to the Active Directory configuration for the computer account
	// whose keys will be rotated in order to create new keytabs for all of its
	// registered service principal names.
	Source *Reference `json:"source,omitempty"`
}

// KeytabResponse defines model for KeytabResponse.
type KeytabResponse struct {
	// Items A list of Kerberos keytab objects.
	Items *[]Keytab `json:"items,omitempty"`
}

// KeytabFile The keytab file to upload.
type KeytabFile = string

// KmipServer defines model for KmipServer.
type KmipServer struct {
	// CaCertificate CA certificate used to validate the authenticity of the configured servers.
	CaCertificate *Reference `json:"ca_certificate,omitempty"`

	// CaCertificateGroup A certificate group containing CA certificates that can be used to
	// validate the authenticity of the configured servers.
	CaCertificateGroup *Reference `json:"ca_certificate_group,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Uris List of URIs for the configured KMIP servers in the format [protocol://]hostname:port.
	Uris *[]string `json:"uris,omitempty"`
}

// KmipServerResponse defines model for KmipServerResponse.
type KmipServerResponse struct {
	Items *[]KmipServer `json:"items,omitempty"`
}

// LegalHold defines model for LegalHold.
type LegalHold struct {
	// Description The description of the legal hold instance.
	Description *string `json:"description,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// LegalHoldHeldEntity defines model for LegalHoldHeldEntity.
type LegalHoldHeldEntity struct {
	// FileSystem Reference to the file system that the legal hold is applied to.
	FileSystem *FixedReference `json:"file_system,omitempty"`

	// LegalHold Reference to the legal hold.
	LegalHold *FixedReference `json:"legal_hold,omitempty"`

	// Path The path of the file or directory being held.
	Path *string `json:"path,omitempty"`

	// Status The status of the legal hold with respect to the held entity.
	// Valid values include:
	// `applied` for holds that are actively applied,
	// `applying` for holds that are being recursively applied but have not yet completed,
	// `releasing` for holds that are being released recursively but have not yet completed.
	// Entities that are releasing will no longer be held once this operation completes.
	Status *string `json:"status,omitempty"`
}

// LegalHoldsGetResponse defines model for LegalHoldsGetResponse.
type LegalHoldsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of legal hold instances.
	Items *[]LegalHold `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// LegalHoldsHeldEntitiesGetResponse defines model for LegalHoldsHeldEntitiesGetResponse.
type LegalHoldsHeldEntitiesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of held entities for legal holds.
	Items *[]LegalHoldHeldEntity `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// LegalHoldsHeldEntitiesResponse defines model for LegalHoldsHeldEntitiesResponse.
type LegalHoldsHeldEntitiesResponse struct {
	// Items A list of held entities for legal holds.
	Items *[]LegalHoldHeldEntity `json:"items,omitempty"`
}

// LegalHoldsResponse defines model for LegalHoldsResponse.
type LegalHoldsResponse struct {
	// Items A list of legal hold instances.
	Items *[]LegalHold `json:"items,omitempty"`
}

// LifecycleRule defines model for LifecycleRule.
type LifecycleRule struct {
	// AbortIncompleteMultipartUploadsAfter Duration of time after which incomplete multipart uploads will be aborted.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	AbortIncompleteMultipartUploadsAfter *int64 `json:"abort_incomplete_multipart_uploads_after,omitempty"`

	// Bucket The bucket which this lifecycle rule is targeting.
	Bucket *FixedReference `json:"bucket,omitempty"`

	// CleanupExpiredObjectDeleteMarker Returns a value of `true` if the expired object delete markers will be removed.
	CleanupExpiredObjectDeleteMarker *bool `json:"cleanup_expired_object_delete_marker,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If set to `true`, this rule will be enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// KeepCurrentVersionFor Time after which current versions will be marked expired.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	KeepCurrentVersionFor *int64 `json:"keep_current_version_for,omitempty"`

	// KeepCurrentVersionUntil Time after which current versions will be marked expired.
	// Measured in milliseconds, time since epoch.
	// Must be a valid date, accurate to day.
	KeepCurrentVersionUntil *int64 `json:"keep_current_version_until,omitempty"`

	// KeepPreviousVersionFor Time after which previous versions will be marked expired.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	KeepPreviousVersionFor *int64 `json:"keep_previous_version_for,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Prefix Object key prefix identifying one or more objects in the bucket.
	// Can have a maximum length of 1024 characters.
	Prefix *string `json:"prefix,omitempty"`

	// RuleId Unique identifier for the rule.
	// Can have a maximum length of 255 characters.
	RuleId *string `json:"rule_id,omitempty"`
}

// LifecycleRuleGetResponse defines model for LifecycleRuleGetResponse.
type LifecycleRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of lifecycle rule objects.
	Items *[]LifecycleRule `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// LifecycleRulePatch defines model for LifecycleRulePatch.
type LifecycleRulePatch struct {
	// AbortIncompleteMultipartUploadsAfter Duration of time after which incomplete multipart uploads will be aborted.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	AbortIncompleteMultipartUploadsAfter *int64 `json:"abort_incomplete_multipart_uploads_after,omitempty"`

	// Enabled If set to `true`, this rule will be enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// KeepCurrentVersionFor Time after which current versions will be marked expired.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	KeepCurrentVersionFor *int64 `json:"keep_current_version_for,omitempty"`

	// KeepCurrentVersionUntil Time after which current versions will be marked expired.
	// Measured in milliseconds, time since epoch.
	// Must be a valid date, accurate to day.
	KeepCurrentVersionUntil *int64 `json:"keep_current_version_until,omitempty"`

	// KeepPreviousVersionFor Time after which previous versions will be marked expired.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	KeepPreviousVersionFor *int64 `json:"keep_previous_version_for,omitempty"`

	// Prefix Object key prefix identifying one or more objects in the bucket.
	// Can have a maximum length of 1024 characters.
	Prefix *string `json:"prefix,omitempty"`
}

// LifecycleRulePost defines model for LifecycleRulePost.
type LifecycleRulePost struct {
	// AbortIncompleteMultipartUploadsAfter Duration of time after which incomplete multipart uploads will be aborted.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	AbortIncompleteMultipartUploadsAfter *int64 `json:"abort_incomplete_multipart_uploads_after,omitempty"`

	// Bucket The bucket name for lifecycle rule creation.
	Bucket *ReferenceWritable `json:"bucket,omitempty"`

	// KeepCurrentVersionFor Time after which current versions will be marked expired.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	KeepCurrentVersionFor *int64 `json:"keep_current_version_for,omitempty"`

	// KeepCurrentVersionUntil Time after which current versions will be marked expired.
	// Measured in milliseconds, time since epoch.
	// Must be a valid date, accurate to day.
	KeepCurrentVersionUntil *int64 `json:"keep_current_version_until,omitempty"`

	// KeepPreviousVersionFor Time after which previous versions will be marked expired.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	KeepPreviousVersionFor *int64 `json:"keep_previous_version_for,omitempty"`

	// Prefix Object key prefix identifying one or more objects in the bucket.
	// Can have a maximum length of 1024 characters.
	Prefix *string `json:"prefix,omitempty"`

	// RuleId Identifier for the rule that is unique to the bucket
	// that it applies to.
	// Can have a maximum length of 255 characters.
	// If not specified, an id unique to the bucket will be generated in the
	// format `fbRuleId<number>` where number increments, starting at 1.
	RuleId *string `json:"rule_id,omitempty"`
}

// LifecycleRuleResponse defines model for LifecycleRuleResponse.
type LifecycleRuleResponse struct {
	// Items A list of lifecycle rule objects.
	Items *[]LifecycleRule `json:"items,omitempty"`
}

// LinkAggregationGroup defines model for LinkAggregationGroup.
type LinkAggregationGroup struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// LagSpeed Combined speed of all ports in the LAG in bits-per-second.
	LagSpeed *int64 `json:"lag_speed,omitempty"`

	// MacAddress Unique MAC address assigned to the LAG.
	MacAddress *string `json:"mac_address,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PortSpeed Configured speed of each port in the LAG in bits-per-second.
	PortSpeed *int64 `json:"port_speed,omitempty"`

	// Ports Ports associated with the LAG.
	Ports *[]FixedReference `json:"ports,omitempty"`

	// Status Health status of the LAG.
	// Valid values are `critical`, `healthy`, `identifying`, `unclaimed`,
	// `unhealthy`, `unrecognized`, and `unused`.
	Status *string `json:"status,omitempty"`
}

// LinkAggregationGroupGetResponse defines model for LinkAggregationGroupGetResponse.
type LinkAggregationGroupGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of lag objects.
	Items *[]LinkAggregationGroup `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// LinkAggregationGroupResponse defines model for LinkAggregationGroupResponse.
type LinkAggregationGroupResponse struct {
	// Items A list of lag objects.
	Items *[]LinkAggregationGroup `json:"items,omitempty"`
}

// Login defines model for Login.
type Login struct {
	// Username The username of the user.
	Username *string `json:"username,omitempty"`
}

// LoginBannerGetResponse defines model for LoginBannerGetResponse.
type LoginBannerGetResponse struct {
	// LoginBanner The string to show as login banner.
	LoginBanner *string `json:"login_banner,omitempty"`
}

// LogsAsync defines model for LogsAsync.
type LogsAsync struct {
	// AvailableFiles All of the available files ready for download.
	AvailableFiles *[]FileInfo `json:"available_files,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	// start_time and end_time determine the number of hours for which the logs are prepared for.
	// At most 6 hours of logs can be prepared in one request.
	// start_time and end_time are truncated to hour boundaries.
	EndTime *int64 `json:"end_time,omitempty"`

	// HardwareComponents All of the hardware components for which logs are being processed.
	HardwareComponents *[]FixedReference `json:"hardware_components,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// LastRequestTime The last time log preparation was requested (in milliseconds since epoch).
	LastRequestTime *int64 `json:"last_request_time,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Processing Returns a value of `true` if the logs are being prepared.
	Processing *bool `json:"processing,omitempty"`

	// Progress A representation of log preparation progress. Ranges from 0 to 1.0.
	Progress *float32 `json:"progress,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	// start_time and end_time determine the number of hours for which the logs are prepared for.
	// At most 6 hours of logs can be prepared in one request.
	// start_time and end_time are truncated to hour boundaries.
	StartTime *int64 `json:"start_time,omitempty"`
}

// LogsAsyncGetResponse defines model for LogsAsyncGetResponse.
type LogsAsyncGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string      `json:"continuation_token,omitempty"`
	Items             *[]LogsAsync `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// LogsAsyncResponse defines model for LogsAsyncResponse.
type LogsAsyncResponse struct {
	Items *[]LogsAsync `json:"items,omitempty"`
}

// MaintenanceWindow defines model for MaintenanceWindow.
type MaintenanceWindow struct {
	// Created The maintenance window start time, measured in milliseconds since the UNIX epoch.
	Created *int64 `json:"created,omitempty"`

	// Expires The maintenance window end time, measured in milliseconds since the UNIX epoch.
	Expires *int64 `json:"expires,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// MaintenanceWindowPost defines model for MaintenanceWindowPost.
type MaintenanceWindowPost struct {
	// Timeout Duration of a maintenance window measured in milliseconds.
	// The `names` and `timeout` parameters must be set together, and the `names` parameter
	// must be set to `array`.
	Timeout *int32 `json:"timeout,omitempty"`
}

// MaintenanceWindowsGetResponse defines model for MaintenanceWindowsGetResponse.
type MaintenanceWindowsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string              `json:"continuation_token,omitempty"`
	Items             *[]MaintenanceWindow `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// MaintenanceWindowsResponse defines model for MaintenanceWindowsResponse.
type MaintenanceWindowsResponse struct {
	Items *[]MaintenanceWindow `json:"items,omitempty"`
}

// Member defines model for Member.
type Member struct {
	// Group A reference to a group object that has the referenced member object
	// as a member.
	Group *Reference `json:"group,omitempty"`

	// Member A reference to an object that is a member of the referenced group.
	Member *Reference `json:"member,omitempty"`
}

// NetworkAccessPolicy defines model for NetworkAccessPolicy.
type NetworkAccessPolicy struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Rules All of the rules that are part of this policy. The order is the
	// evaluation order.
	// If a client does not match any rule in the policy for the interface that
	// they are attempting to access, the default is to deny access.
	Rules *[]NetworkAccessPolicyRuleInPolicy `json:"rules,omitempty"`

	// Version A hash of the other properties of this resource. This can be used when
	// updating the resource to ensure there aren't any updates since the
	// resource was read.
	Version *string `json:"version,omitempty"`
}

// NetworkAccessPolicyGetResponse defines model for NetworkAccessPolicyGetResponse.
type NetworkAccessPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string                `json:"continuation_token,omitempty"`
	Items             *[]NetworkAccessPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NetworkAccessPolicyResponse defines model for NetworkAccessPolicyResponse.
type NetworkAccessPolicyResponse struct {
	Items *[]NetworkAccessPolicy `json:"items,omitempty"`
}

// NetworkAccessPolicyRule defines model for NetworkAccessPolicyRule.
type NetworkAccessPolicyRule struct {
	// Client Specifies the clients that will be permitted or denied access to the interface.
	// Accepted notations include a single IP address, subnet in CIDR notation,
	// or all clients (specified as `*`).
	// The default value is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Effect If set to `allow`, the specified client will be permitted to access the specified
	// interfaces. If set to `deny`, the specified client will be denied access to them.
	// Valid values include `allow` and `deny`.
	Effect *string `json:"effect,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	// NOTE: It is recommended to use the query param `before_rule_id` to do reordering to
	// avoid concurrency issues, but changing `index` is also supported. `index` can not be
	// changed if `before_rule_id` or `before_rule_name` are specified.
	Index *int32 `json:"index,omitempty"`

	// Interfaces Specifies which product interfaces this rule applies to, whether it is
	// permitting or denying access. Valid values include `management-ssh`,
	// `management-rest-api`, `management-web-ui`, `snmp`, and
	// `local-network-superuser-password-access`.
	Interfaces *[]string `json:"interfaces,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`
}

// NetworkAccessPolicyRuleBase defines model for NetworkAccessPolicyRuleBase.
type NetworkAccessPolicyRuleBase struct {
	// Client Specifies the clients that will be permitted or denied access to the interface.
	// Accepted notations include a single IP address, subnet in CIDR notation,
	// or all clients (specified as `*`).
	// The default value is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Effect If set to `allow`, the specified client will be permitted to access the specified
	// interfaces. If set to `deny`, the specified client will be denied access to them.
	// Valid values include `allow` and `deny`.
	Effect *string `json:"effect,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Interfaces Specifies which product interfaces this rule applies to, whether it is
	// permitting or denying access. Valid values include `management-ssh`,
	// `management-rest-api`, `management-web-ui`, `snmp`, and
	// `local-network-superuser-password-access`.
	Interfaces *[]string `json:"interfaces,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`
}

// NetworkAccessPolicyRuleGetResponse defines model for NetworkAccessPolicyRuleGetResponse.
type NetworkAccessPolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items Displays a list of all items after filtering.
	Items *[]NetworkAccessPolicyRule `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NetworkAccessPolicyRuleInPolicy defines model for NetworkAccessPolicyRuleInPolicy.
type NetworkAccessPolicyRuleInPolicy struct {
	// Client Specifies the clients that will be permitted or denied access to the interface.
	// Accepted notations include a single IP address, subnet in CIDR notation,
	// or all clients (specified as `*`).
	// The default value is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Effect If set to `allow`, the specified client will be permitted to access the specified
	// interfaces. If set to `deny`, the specified client will be denied access to them.
	// Valid values include `allow` and `deny`.
	Effect *string `json:"effect,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	Index *int32 `json:"index,omitempty"`

	// Interfaces Specifies which product interfaces this rule applies to, whether it is
	// permitting or denying access. Valid values include `management-ssh`,
	// `management-rest-api`, `management-web-ui`, `snmp`, and
	// `local-network-superuser-password-access`.
	Interfaces *[]string `json:"interfaces,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`
}

// NetworkAccessPolicyRulePost defines model for NetworkAccessPolicyRulePost.
type NetworkAccessPolicyRulePost struct {
	// Client Specifies the clients that will be permitted or denied access to the interface.
	// Accepted notations include a single IP address, subnet in CIDR notation,
	// or all clients (specified as `*`).
	// The default value is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Effect If set to `allow`, the specified client will be permitted to access the specified
	// interfaces. If set to `deny`, the specified client will be denied access to them.
	// Valid values include `allow` and `deny`.
	// The default value is `allow` if not specified.
	Effect *string `json:"effect,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	// NOTE: It is recommended to use the query param `before_rule_id` to do reordering to
	// avoid concurrency issues, but changing `index` is also supported. `index` can not be
	// changed if `before_rule_id` or `before_rule_name` are specified.
	Index *int32 `json:"index,omitempty"`

	// Interfaces Specifies which product interfaces this rule applies to, whether it is
	// permitting or denying access. Valid values include `management-ssh`,
	// `management-rest-api`, `management-web-ui`, `snmp`, and
	// `local-network-superuser-password-access`.
	Interfaces *[]string `json:"interfaces,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// NetworkAccessPolicyRulePostBase defines model for NetworkAccessPolicyRulePostBase.
type NetworkAccessPolicyRulePostBase struct {
	// Client Specifies the clients that will be permitted or denied access to the interface.
	// Accepted notations include a single IP address, subnet in CIDR notation,
	// or all clients (specified as `*`).
	// The default value is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Effect If set to `allow`, the specified client will be permitted to access the specified
	// interfaces. If set to `deny`, the specified client will be denied access to them.
	// Valid values include `allow` and `deny`.
	// The default value is `allow` if not specified.
	Effect *string `json:"effect,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Interfaces Specifies which product interfaces this rule applies to, whether it is
	// permitting or denying access. Valid values include `management-ssh`,
	// `management-rest-api`, `management-web-ui`, `snmp`, and
	// `local-network-superuser-password-access`.
	Interfaces *[]string `json:"interfaces,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// NetworkAccessPolicyRuleResponse defines model for NetworkAccessPolicyRuleResponse.
type NetworkAccessPolicyRuleResponse struct {
	// Items Displays a list of all items after filtering.
	Items *[]NetworkAccessPolicyRule `json:"items,omitempty"`
}

// NetworkInterface defines model for NetworkInterface.
type NetworkInterface struct {
	// Address The IPv4 or IPv6 address to be associated with the specified network
	// interface.
	Address *string `json:"address,omitempty"`

	// Enabled Indicates if the specified network interface is enabled (`true`) or
	// disabled (`false`). If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Gateway Derived from `subnet.gateway`.
	Gateway *string `json:"gateway,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Mtu Derived from `subnet.mtu`.
	Mtu *int32 `json:"mtu,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Netmask Derived from `subnet.prefix`.
	Netmask *string `json:"netmask,omitempty"`

	// Server The server that is using this interface for data ingress.
	// Will be null if `services` does not include `data`.
	// Defaults to _array_server when `services` does include `data`.
	Server *Reference `json:"server,omitempty"`

	// Services Services and protocols that are enabled on the interface.
	Services *[]string `json:"services,omitempty"`
	Subnet   *struct {
		// Id A non-modifiable, globally unique ID chosen by the system.
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`

		// ResourceType Type of the object (full name of the endpoint).
		// Valid values are the unique part of the resource's REST endpoint.
		// For example, a reference to a file system would have a
		// `resource_type` of `file-systems`.
		ResourceType *string `json:"resource_type,omitempty"`
	} `json:"subnet,omitempty"`

	// Type The only valid value is `vip`.
	Type *string `json:"type,omitempty"`

	// Vlan Derived from `subnet.vlan`.
	Vlan *int32 `json:"vlan,omitempty"`
}

// NetworkInterfaceGetResponse defines model for NetworkInterfaceGetResponse.
type NetworkInterfaceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of network interface objects.
	Items *[]NetworkInterface `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NetworkInterfacePatch defines model for NetworkInterfacePatch.
type NetworkInterfacePatch struct {
	// Address The IPv4 or IPv6 address to be associated with the specified network
	// interface.
	Address *string `json:"address,omitempty"`

	// Server The server that is using this interface for data ingress.
	// Will be null if `services` does not include `data`.
	// Defaults to _array_server when `services` does include `data`.
	Server *Reference `json:"server,omitempty"`

	// Services Services and protocols that are enabled on the interface.
	Services *[]string `json:"services,omitempty"`
}

// NetworkInterfacePing Output from running the linux command 'ping' directly
// on the array with start and end location information.
type NetworkInterfacePing struct {
	// ComponentName Name of the component running the check.
	ComponentName *string `json:"component_name,omitempty"`

	// Destination The destination address or hostname provided in the request that the operation is run against.
	Destination *string `json:"destination,omitempty"`

	// Details Giant text block that contains raw output of the operation and a client needs to parse.
	Details *string `json:"details,omitempty"`

	// Source The address where the check starts. Can be a subnet or IP inside the subnet.
	Source *string `json:"source,omitempty"`
}

// NetworkInterfacePingGetResponse defines model for NetworkInterfacePingGetResponse.
type NetworkInterfacePingGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of network ping run result.
	Items *[]NetworkInterfacePing `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NetworkInterfacePingResponse defines model for NetworkInterfacePingResponse.
type NetworkInterfacePingResponse struct {
	// Items A list of network ping run result.
	Items *[]NetworkInterfacePing `json:"items,omitempty"`
}

// NetworkInterfaceResponse defines model for NetworkInterfaceResponse.
type NetworkInterfaceResponse struct {
	// Items A list of network interface objects.
	Items *[]NetworkInterface `json:"items,omitempty"`
}

// NetworkInterfaceTrace Output from running the linux command 'traceroute' directly
// on the array with start and end location information.
type NetworkInterfaceTrace struct {
	// ComponentName Name of the component running the check.
	ComponentName *string `json:"component_name,omitempty"`

	// Destination The destination address or hostname provided in the request that the operation is run against.
	Destination *string `json:"destination,omitempty"`

	// Details Giant text block that contains raw output of the operation and a client needs to parse.
	Details *string `json:"details,omitempty"`

	// Source The address where the check starts. Can be a subnet or IP inside the subnet.
	Source *string `json:"source,omitempty"`
}

// NetworkInterfaceTraceGetResponse defines model for NetworkInterfaceTraceGetResponse.
type NetworkInterfaceTraceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of network trace run result.
	Items *[]NetworkInterfaceTrace `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NetworkInterfaceTraceResponse defines model for NetworkInterfaceTraceResponse.
type NetworkInterfaceTraceResponse struct {
	// Items A list of network trace run result.
	Items *[]NetworkInterfaceTrace `json:"items,omitempty"`
}

// NetworkInterfacesConnectorsGetResponse defines model for NetworkInterfacesConnectorsGetResponse.
type NetworkInterfacesConnectorsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of network connector objects.
	Items *[]HardwareConnector `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NetworkInterfacesConnectorsPerformance defines model for NetworkInterfacesConnectorsPerformance.
type NetworkInterfacesConnectorsPerformance struct {
	// FlowControlReceivedCongestionPacketsPerSec Number of congestion control packets received per second.
	FlowControlReceivedCongestionPacketsPerSec *int64 `json:"flow_control_received_congestion_packets_per_sec,omitempty"`

	// FlowControlReceivedDiscardedPacketsPerSec Number of received packets that were physically discarded
	// per second due to errors or other reasons.
	FlowControlReceivedDiscardedPacketsPerSec *int64 `json:"flow_control_received_discarded_packets_per_sec,omitempty"`

	// FlowControlReceivedLosslessBytesPerSec Bytes received per second with lossless flow control settings.
	FlowControlReceivedLosslessBytesPerSec *int64 `json:"flow_control_received_lossless_bytes_per_sec,omitempty"`

	// FlowControlReceivedPauseFramesPerSec Received pause frames per second.
	FlowControlReceivedPauseFramesPerSec *int64 `json:"flow_control_received_pause_frames_per_sec,omitempty"`

	// FlowControlTransmittedCongestionPacketsPerSec Number of congestion control packets transmitted per second.
	FlowControlTransmittedCongestionPacketsPerSec *int64 `json:"flow_control_transmitted_congestion_packets_per_sec,omitempty"`

	// FlowControlTransmittedDiscardedPacketsPerSec Number of transmitted packets that were physically discarded by
	// the NIC per second due to errors or other reasons.
	FlowControlTransmittedDiscardedPacketsPerSec *int64 `json:"flow_control_transmitted_discarded_packets_per_sec,omitempty"`

	// FlowControlTransmittedLosslessBytesPerSec Bytes transmitted per second with lossless flow control settings.
	FlowControlTransmittedLosslessBytesPerSec *int64 `json:"flow_control_transmitted_lossless_bytes_per_sec,omitempty"`

	// FlowControlTransmittedPauseFramesPerSec Transmitted pause frames per second.
	FlowControlTransmittedPauseFramesPerSec *int64 `json:"flow_control_transmitted_pause_frames_per_sec,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// LinkAggregationGroup The link aggregation group which this entity belongs to.
	LinkAggregationGroup *FixedReference `json:"link_aggregation_group,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// OtherErrorsPerSec The sum of unspecified reception and transmission errors per second.
	OtherErrorsPerSec *int64 `json:"other_errors_per_sec,omitempty"`

	// RdmaReceivedReqCqeErrorsPerSec The number of times port detected RDMA CQEs with error per second.
	RdmaReceivedReqCqeErrorsPerSec *int64 `json:"rdma_received_req_cqe_errors_per_sec,omitempty"`

	// RdmaReceivedSequenceErrorsPerSec The number of received RDMA packet sequence errors per second.
	RdmaReceivedSequenceErrorsPerSec *int64 `json:"rdma_received_sequence_errors_per_sec,omitempty"`

	// RdmaTransmittedLocalAckTimeoutErrorsPerSec The number of times RDMA ack timer expired for QPs per second.
	RdmaTransmittedLocalAckTimeoutErrorsPerSec *int64 `json:"rdma_transmitted_local_ack_timeout_errors_per_sec,omitempty"`

	// ReceivedBytesPerSec Bytes received per second.
	ReceivedBytesPerSec *int64 `json:"received_bytes_per_sec,omitempty"`

	// ReceivedCrcErrorsPerSec Reception CRC errors per second.
	ReceivedCrcErrorsPerSec *int64 `json:"received_crc_errors_per_sec,omitempty"`

	// ReceivedFrameErrorsPerSec Received packet frame errors per second.
	ReceivedFrameErrorsPerSec *int64 `json:"received_frame_errors_per_sec,omitempty"`

	// ReceivedPacketsPerSec Packets received per second.
	ReceivedPacketsPerSec *int64 `json:"received_packets_per_sec,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`

	// TotalErrorsPerSec The sum of all reception and transmission errors per second.
	TotalErrorsPerSec *int64 `json:"total_errors_per_sec,omitempty"`

	// TransmittedBytesPerSec Bytes transmitted per second.
	TransmittedBytesPerSec *int64 `json:"transmitted_bytes_per_sec,omitempty"`

	// TransmittedCarrierErrorsPerSec Transmission carrier errors per second.
	TransmittedCarrierErrorsPerSec *int64 `json:"transmitted_carrier_errors_per_sec,omitempty"`

	// TransmittedDroppedErrorsPerSec Transmitted packets dropped per second.
	TransmittedDroppedErrorsPerSec *int64 `json:"transmitted_dropped_errors_per_sec,omitempty"`

	// TransmittedPacketsPerSec Packets transmitted per second.
	TransmittedPacketsPerSec *int64 `json:"transmitted_packets_per_sec,omitempty"`
}

// NetworkInterfacesConnectorsPerformanceGetResponse defines model for NetworkInterfacesConnectorsPerformanceGetResponse.
type NetworkInterfacesConnectorsPerformanceGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of network connector performance objects.
	Items *[]NetworkInterfacesConnectorsPerformance `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no individual items will be returned.
	Total *[]NetworkInterfacesConnectorsPerformance `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NetworkInterfacesConnectorsResponse defines model for NetworkInterfacesConnectorsResponse.
type NetworkInterfacesConnectorsResponse struct {
	// Items A list of network connector objects.
	Items *[]HardwareConnector `json:"items,omitempty"`
}

// NetworkInterfacesConnectorsSetting defines model for NetworkInterfacesConnectorsSetting.
type NetworkInterfacesConnectorsSetting struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Roce RoCE(RDMA over Converged Ethernet) configuration for network connectors.
	Roce *NetworkInterfacesConnectorsSettingRoce `json:"roce,omitempty"`
}

// NetworkInterfacesConnectorsSettingRoce defines model for NetworkInterfacesConnectorsSettingRoce.
type NetworkInterfacesConnectorsSettingRoce struct {
	// DefaultEcn The default ECN(Explicit Congestion Notification) setting for network connectors.
	DefaultEcn *NetworkInterfacesConnectorsSettingRoceEcn `json:"default_ecn,omitempty"`

	// DefaultPfc The default PFC(Priority Flow Control) setting for network connectors.
	DefaultPfc *NetworkInterfacesConnectorsSettingRocePfc `json:"default_pfc,omitempty"`

	// Enabled If `true`, then RoCE networking is enabled. Otherwise, it is disabled.
	Enabled *bool `json:"enabled,omitempty"`

	// NetworkCongestionMode The RoCE network mode to be used. Valid values include `lossy` and `lossless`.
	// For lossy mode, only Explicit Congestion Notification (ECN) is enabled.
	// For lossless mode, both ECN and Priority Flow Control (PFC) are enabled.
	NetworkCongestionMode *string `json:"network_congestion_mode,omitempty"`

	// TrustMode The trust mode of the RoCE network. Valid values include `pcp` and `dscp`.
	TrustMode *string `json:"trust_mode,omitempty"`
}

// NetworkInterfacesConnectorsSettingRoceEcn defines model for NetworkInterfacesConnectorsSettingRoceEcn.
type NetworkInterfacesConnectorsSettingRoceEcn struct {
	// MarkingProbability The ECN marking probability when min ECN marked threshold is reached.
	MarkingProbability *float32 `json:"marking_probability,omitempty"`

	// MaxEcnMarkedThreshold The maximum threshold value in bytes at which the packets start being marked with ECN
	// at the highest probability or dropped.
	MaxEcnMarkedThreshold *int32 `json:"max_ecn_marked_threshold,omitempty"`

	// MinEcnMarkedThreshold The minimum threshold value in bytes at which the packets start being marked with ECN.
	MinEcnMarkedThreshold *int32 `json:"min_ecn_marked_threshold,omitempty"`
}

// NetworkInterfacesConnectorsSettingRocePfc defines model for NetworkInterfacesConnectorsSettingRocePfc.
type NetworkInterfacesConnectorsSettingRocePfc struct {
	// PortBuffer The buffer size in bytes reserved to absorb in-flight packets after XOFF threshold
	// is reached.
	PortBuffer *int32 `json:"port_buffer,omitempty"`

	// XoffThreshold The PFC XOFF threshold value in bytes. When the buffer for a particular traffic class
	// reaches this threshold, the pause frame(XOFF) will be transimitted to the sender,
	// requesting it to stop sending packets for that class.
	XoffThreshold *int32 `json:"xoff_threshold,omitempty"`

	// XonThreshold The PFC XON threshold value in bytes. When the buffer for a particular traffic class
	// drops below this threshold, the un-pause frame(XON) will be transmitted to the sender,
	// requesting it to resume sending packets for that class.
	XonThreshold *int32 `json:"xon_threshold,omitempty"`
}

// NetworkInterfacesConnectorsSettingsGetResponse defines model for NetworkInterfacesConnectorsSettingsGetResponse.
type NetworkInterfacesConnectorsSettingsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of global network settings for network connectors.
	Items *[]NetworkInterfacesConnectorsSetting `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NfsExportPolicy defines model for NfsExportPolicy.
type NfsExportPolicy struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Rules All of the rules that are part of this policy. The order is the evaluation order.
	Rules *[]NfsExportPolicyRuleInPolicy `json:"rules,omitempty"`

	// Version A hash of the other properties of this resource. This can be used when
	// updating the resource to ensure there aren't any updates since the
	// resource was read.
	Version *string `json:"version,omitempty"`
}

// NfsExportPolicyGetResponse defines model for NfsExportPolicyGetResponse.
type NfsExportPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of NFS export policy objects.
	Items *[]NfsExportPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NfsExportPolicyPost defines model for NfsExportPolicyPost.
type NfsExportPolicyPost struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Rules All of the rules that are part of this policy. The order is the evaluation order.
	Rules *[]NfsExportPolicyRuleInPolicy `json:"rules,omitempty"`
}

// NfsExportPolicyResponse defines model for NfsExportPolicyResponse.
type NfsExportPolicyResponse struct {
	// Items A list of NFS export policy objects.
	Items *[]NfsExportPolicy `json:"items,omitempty"`
}

// NfsExportPolicyRule defines model for NfsExportPolicyRule.
type NfsExportPolicyRule struct {
	// Access Specifies access control for the export. Valid values are `root-squash`, `all-squash`, and
	// `no-squash`.
	// `root-squash` prevents client users and groups with root privilege from mapping their
	// root privilege to a file system. All users with UID 0 will have their UID mapped to anonuid.
	// All users with GID 0 will have their GID mapped to anongid.
	// `all-squash` maps all UIDs (including root) to anonuid and all GIDs (including root) to
	// anongid.
	// `no-squash` allows users and groups to access the file system with their UIDs and GIDs.
	// The default is `root-squash` if not specified.
	Access *string `json:"access,omitempty"`

	// Anongid Any user whose GID is affected by an `access` of `root_squash` or `all_squash` will have
	// their GID mapped to `anongid`. The default `anongid` is null, which means 65534.
	// Use "" to clear.
	Anongid *string `json:"anongid,omitempty"`

	// Anonuid Any user whose UID is affected by an `access` of `root_squash` or `all_squash` will have
	// their UID mapped to `anonuid`. The default `anonuid` is null, which means 65534.
	// Use "" to clear.
	Anonuid *string `json:"anonuid,omitempty"`

	// Atime If `true`, after a read operation has occurred, the inode access time is updated only if any
	// of the following conditions is true: the previous access time is less than the inode modify
	// time, the previous access time is less than the inode change time, or the previous access
	// time is more than 24 hours ago.
	// If `false`, disables the update of inode access times after read operations.
	// Defaults to `true`.
	Atime *bool `json:"atime,omitempty"`

	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation, netgroup,
	// hostname (see RFC-1123 part 2.1), fully qualified domain name
	// (see RFC-1123 part 2.1, RFC 2181 part 11), wildcards with fully qualified domain name
	// or hostname, or anonymous (`*`).
	// The default is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Fileid32bit Whether the file id is 32 bits or not. Defaults to `false`.
	Fileid32bit *bool `json:"fileid_32bit,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	// NOTE: It is recommended to use the query param `before_rule_id` to do reordering to
	// avoid concurrency issues, but changing `index` is also supported. `index` can not be
	// changed if `before_rule_id` or `before_rule_name` are specified.
	Index *int32 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`. The default is `ro` if not specified.
	Permission *string `json:"permission,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`

	// Secure If `true`, prevents NFS access to client connections coming from non-reserved ports. Applies
	// to NFSv3, NFSv4.1, and auxiliary protocols MOUNT and NLM.
	// If `false`, allows NFS access to client connections coming from non-reserved ports. Applies
	// to NFSv3, NFSv4.1, and auxiliary protocols MOUNT and NLM.
	// The default is `false` if not specified.
	Secure *bool `json:"secure,omitempty"`

	// Security The security flavors to use for accessing files on this mount point.  If the server does not
	// support the requested flavor, the mount operation fails.
	// If `sys`, trusts the client to specify user's identity.
	// If `krb5`, provides cryptographic proof of a user's identity in each RPC request. This
	// provides  strong verification of the identity of users accessing data on the server.
	// Note that additional configuration besides adding this mount option is required in order to
	// enable Kerberos security.
	// If `krb5i`, adds integrity checking to krb5, to ensure the data has not been tampered with.
	// If `krb5p`, adds integrity checking and encryption to krb5. This is the most secure setting,
	// but it also involves the most performance overhead.
	// The default is `sys` if not specified.
	Security *[]string `json:"security,omitempty"`
}

// NfsExportPolicyRuleBase defines model for NfsExportPolicyRuleBase.
type NfsExportPolicyRuleBase struct {
	// Access Specifies access control for the export. Valid values are `root-squash`, `all-squash`, and
	// `no-squash`.
	// `root-squash` prevents client users and groups with root privilege from mapping their
	// root privilege to a file system. All users with UID 0 will have their UID mapped to anonuid.
	// All users with GID 0 will have their GID mapped to anongid.
	// `all-squash` maps all UIDs (including root) to anonuid and all GIDs (including root) to
	// anongid.
	// `no-squash` allows users and groups to access the file system with their UIDs and GIDs.
	// The default is `root-squash` if not specified.
	Access *string `json:"access,omitempty"`

	// Anongid Any user whose GID is affected by an `access` of `root_squash` or `all_squash` will have
	// their GID mapped to `anongid`. The default `anongid` is null, which means 65534.
	// Use "" to clear.
	Anongid *string `json:"anongid,omitempty"`

	// Anonuid Any user whose UID is affected by an `access` of `root_squash` or `all_squash` will have
	// their UID mapped to `anonuid`. The default `anonuid` is null, which means 65534.
	// Use "" to clear.
	Anonuid *string `json:"anonuid,omitempty"`

	// Atime If `true`, after a read operation has occurred, the inode access time is updated only if any
	// of the following conditions is true: the previous access time is less than the inode modify
	// time, the previous access time is less than the inode change time, or the previous access
	// time is more than 24 hours ago.
	// If `false`, disables the update of inode access times after read operations.
	// Defaults to `true`.
	Atime *bool `json:"atime,omitempty"`

	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation, netgroup,
	// hostname (see RFC-1123 part 2.1), fully qualified domain name
	// (see RFC-1123 part 2.1, RFC 2181 part 11), wildcards with fully qualified domain name
	// or hostname, or anonymous (`*`).
	// The default is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Fileid32bit Whether the file id is 32 bits or not. Defaults to `false`.
	Fileid32bit *bool `json:"fileid_32bit,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`. The default is `ro` if not specified.
	Permission *string `json:"permission,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`

	// Secure If `true`, prevents NFS access to client connections coming from non-reserved ports. Applies
	// to NFSv3, NFSv4.1, and auxiliary protocols MOUNT and NLM.
	// If `false`, allows NFS access to client connections coming from non-reserved ports. Applies
	// to NFSv3, NFSv4.1, and auxiliary protocols MOUNT and NLM.
	// The default is `false` if not specified.
	Secure *bool `json:"secure,omitempty"`

	// Security The security flavors to use for accessing files on this mount point.  If the server does not
	// support the requested flavor, the mount operation fails.
	// If `sys`, trusts the client to specify user's identity.
	// If `krb5`, provides cryptographic proof of a user's identity in each RPC request. This
	// provides  strong verification of the identity of users accessing data on the server.
	// Note that additional configuration besides adding this mount option is required in order to
	// enable Kerberos security.
	// If `krb5i`, adds integrity checking to krb5, to ensure the data has not been tampered with.
	// If `krb5p`, adds integrity checking and encryption to krb5. This is the most secure setting,
	// but it also involves the most performance overhead.
	// The default is `sys` if not specified.
	Security *[]string `json:"security,omitempty"`
}

// NfsExportPolicyRuleGetResponse defines model for NfsExportPolicyRuleGetResponse.
type NfsExportPolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items Displays a list of all items after filtering.
	Items *[]NfsExportPolicyRule `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// NfsExportPolicyRuleInPolicy defines model for NfsExportPolicyRuleInPolicy.
type NfsExportPolicyRuleInPolicy struct {
	// Access Specifies access control for the export. Valid values are `root-squash`, `all-squash`, and
	// `no-squash`.
	// `root-squash` prevents client users and groups with root privilege from mapping their
	// root privilege to a file system. All users with UID 0 will have their UID mapped to anonuid.
	// All users with GID 0 will have their GID mapped to anongid.
	// `all-squash` maps all UIDs (including root) to anonuid and all GIDs (including root) to
	// anongid.
	// `no-squash` allows users and groups to access the file system with their UIDs and GIDs.
	// The default is `root-squash` if not specified.
	Access *string `json:"access,omitempty"`

	// Anongid Any user whose GID is affected by an `access` of `root_squash` or `all_squash` will have
	// their GID mapped to `anongid`. The default `anongid` is null, which means 65534.
	// Use "" to clear.
	Anongid *string `json:"anongid,omitempty"`

	// Anonuid Any user whose UID is affected by an `access` of `root_squash` or `all_squash` will have
	// their UID mapped to `anonuid`. The default `anonuid` is null, which means 65534.
	// Use "" to clear.
	Anonuid *string `json:"anonuid,omitempty"`

	// Atime If `true`, after a read operation has occurred, the inode access time is updated only if any
	// of the following conditions is true: the previous access time is less than the inode modify
	// time, the previous access time is less than the inode change time, or the previous access
	// time is more than 24 hours ago.
	// If `false`, disables the update of inode access times after read operations.
	// Defaults to `true`.
	Atime *bool `json:"atime,omitempty"`

	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation, netgroup,
	// hostname (see RFC-1123 part 2.1), fully qualified domain name
	// (see RFC-1123 part 2.1, RFC 2181 part 11), wildcards with fully qualified domain name
	// or hostname, or anonymous (`*`).
	// The default is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Fileid32bit Whether the file id is 32 bits or not. Defaults to `false`.
	Fileid32bit *bool `json:"fileid_32bit,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	Index *int32 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`. The default is `ro` if not specified.
	Permission *string `json:"permission,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`

	// Secure If `true`, prevents NFS access to client connections coming from non-reserved ports. Applies
	// to NFSv3, NFSv4.1, and auxiliary protocols MOUNT and NLM.
	// If `false`, allows NFS access to client connections coming from non-reserved ports. Applies
	// to NFSv3, NFSv4.1, and auxiliary protocols MOUNT and NLM.
	// The default is `false` if not specified.
	Secure *bool `json:"secure,omitempty"`

	// Security The security flavors to use for accessing files on this mount point.  If the server does not
	// support the requested flavor, the mount operation fails.
	// If `sys`, trusts the client to specify user's identity.
	// If `krb5`, provides cryptographic proof of a user's identity in each RPC request. This
	// provides  strong verification of the identity of users accessing data on the server.
	// Note that additional configuration besides adding this mount option is required in order to
	// enable Kerberos security.
	// If `krb5i`, adds integrity checking to krb5, to ensure the data has not been tampered with.
	// If `krb5p`, adds integrity checking and encryption to krb5. This is the most secure setting,
	// but it also involves the most performance overhead.
	// The default is `sys` if not specified.
	Security *[]string `json:"security,omitempty"`
}

// NfsExportPolicyRuleResponse defines model for NfsExportPolicyRuleResponse.
type NfsExportPolicyRuleResponse struct {
	// Items Displays a list of all items after filtering.
	Items *[]NfsExportPolicyRule `json:"items,omitempty"`
}

// OauthGrantType The method by which the access token will be obtained.
// The Pure Storage REST API supports the OAuth 2.0 "token exchange" grant type,
// which indicates that a token exchange is being performed.
// Set `grant_type` to `urn:ietf:params:oauth:grant-type:token-exchange`.
type OauthGrantType = string

// OauthSubjectToken An encoded security ID Token representing the identity of the party on behalf of
// whom the request is being made. The token must be issued by a trusted
// identity provider which must be either a registered application in Pure1
// or an enabled API client on the array. The token must be a JSON Web Token
// and must contain the following claims:
//
// > | JWT claim | Location | API Client Field | Description | Required By |
//
// > |-|-|-|-|-|
//
// > | kid | Header | key_id | Key ID of the API client that issues the identity token. | FlashArray
// and FlashBlade only. |
//
// > | aud | Payload | id | Client ID of the API client that issues the identity token. | FlashArray
// and FlashBlade only. |
//
// > | sub | Payload | | Login name of the array user for whom the token should be issued.
// This must be a valid user in the system. | FlashArray and FlashBlade only. |
//
// > | iss | Payload | issuer | Application ID for the Pure1 or API client's trusted identity
// issuer on the array. | All products. |
//
// > | iat | Payload | | Timestamp of when the identity token was issued.
// Measured in milliseconds since the UNIX epoch. | All products. |
//
// > | exp | Payload | | Timestamp of when the identity token will expire.
// Measured in milliseconds since the UNIX epoch. | All products. |
//
// Each token must also be signed with the private key that is paired with the
// API client's public key.
type OauthSubjectToken = string

// OauthSubjectTokenType An identifier that indicates the type of security token specifed in the `subject_token` parameter.
// The Pure Storage REST API supports the JSON Web Token (JWT)
// as the means for requesting the access token.
// Set `subject_token_type` to `urn:ietf:params:oauth:token-type:jwt`.
type OauthSubjectTokenType = string

// ObjectStoreAccessKey defines model for ObjectStoreAccessKey.
type ObjectStoreAccessKey struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the object.
	Created *int64 `json:"created,omitempty"`

	// Enabled Is the access key enabled? If not specified, defaults to `false`.
	Enabled *bool `json:"enabled,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// SecretAccessKey The secret access key, only populated on creation if it is not
	// imported from another FlashBlade.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`

	// User Reference of the associated user.
	User *FixedReference `json:"user,omitempty"`
}

// ObjectStoreAccessKeyGetResponse defines model for ObjectStoreAccessKeyGetResponse.
type ObjectStoreAccessKeyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of object store access key objects.
	Items *[]ObjectStoreAccessKey `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreAccessKeyPost defines model for ObjectStoreAccessKeyPost.
type ObjectStoreAccessKeyPost struct {
	// SecretAccessKey The secret access key to import from another FlashBlade.
	// To import a set of credentials, this field must be specified
	// with the `names` query parameter. If both of these not
	// specified, the system will generate a new set of credentials.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
	User            *struct {
		// Id A non-modifiable, globally unique ID chosen by the system.
		Id *string `json:"id,omitempty"`

		// Name A name chosen by the user. Can be changed. Must be locally unique.
		Name *string `json:"name,omitempty"`

		// ResourceType Type of the object (full name of the endpoint).
		// Valid values are the unique part of the resource's REST endpoint.
		// For example, a reference to a file system would have a
		// `resource_type` of `file-systems`.
		ResourceType *string `json:"resource_type,omitempty"`
	} `json:"user,omitempty"`
}

// ObjectStoreAccessKeyResponse defines model for ObjectStoreAccessKeyResponse.
type ObjectStoreAccessKeyResponse struct {
	// Items A list of object store access key objects.
	Items *[]ObjectStoreAccessKey `json:"items,omitempty"`
}

// ObjectStoreAccessPolicy defines model for ObjectStoreAccessPolicy.
type ObjectStoreAccessPolicy struct {
	// Account Reference of the associated account. If the policy is not associated
	// with an account, all fields in the reference possess `null` values.
	Account *FixedReference `json:"account,omitempty"`

	// Arn Amazon Resource Name of the policy. Used when referencing the policy via
	// S3 APIs.
	Arn *string `json:"arn,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the object.
	Created *int64 `json:"created,omitempty"`

	// Description A description of the policy, optionally specified when the policy is
	// created. Cannot be modified for an existing policy.
	Description *string `json:"description,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string                   `json:"policy_type,omitempty"`
	Rules      *[]PolicyRuleObjectAccess `json:"rules,omitempty"`

	// Updated The last updated timestamp of the object.
	Updated *int64 `json:"updated,omitempty"`
}

// ObjectStoreAccessPolicyAction defines model for ObjectStoreAccessPolicyAction.
type ObjectStoreAccessPolicyAction struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Description A description of the action.
	Description *string `json:"description,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// ObjectStoreAccessPolicyActionGetResponse defines model for ObjectStoreAccessPolicyActionGetResponse.
type ObjectStoreAccessPolicyActionGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors    `json:"errors,omitempty"`
	Items  *[]ObjectStoreAccessPolicyAction `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreAccessPolicyActionResponse defines model for ObjectStoreAccessPolicyActionResponse.
type ObjectStoreAccessPolicyActionResponse struct {
	Items *[]ObjectStoreAccessPolicyAction `json:"items,omitempty"`
}

// ObjectStoreAccessPolicyGetResponse defines model for ObjectStoreAccessPolicyGetResponse.
type ObjectStoreAccessPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]ObjectStoreAccessPolicy    `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreAccessPolicyPatch defines model for ObjectStoreAccessPolicyPatch.
type ObjectStoreAccessPolicyPatch struct {
	Rules *[]PolicyRuleObjectAccessBulkManage `json:"rules,omitempty"`
}

// ObjectStoreAccessPolicyPost defines model for ObjectStoreAccessPolicyPost.
type ObjectStoreAccessPolicyPost struct {
	// Description A description of the policy, optionally specified when the policy is
	// created. Cannot be modified for an existing policy.
	Description *string                             `json:"description,omitempty"`
	Rules       *[]PolicyRuleObjectAccessBulkManage `json:"rules,omitempty"`
}

// ObjectStoreAccessPolicyResponse defines model for ObjectStoreAccessPolicyResponse.
type ObjectStoreAccessPolicyResponse struct {
	Items *[]ObjectStoreAccessPolicy `json:"items,omitempty"`
}

// ObjectStoreAccessPolicyRuleGetResponse defines model for ObjectStoreAccessPolicyRuleGetResponse.
type ObjectStoreAccessPolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]PolicyRuleObjectAccess     `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreAccessPolicyRuleResponse defines model for ObjectStoreAccessPolicyRuleResponse.
type ObjectStoreAccessPolicyRuleResponse struct {
	Items *[]PolicyRuleObjectAccess `json:"items,omitempty"`
}

// ObjectStoreAccount defines model for ObjectStoreAccount.
type ObjectStoreAccount struct {
	// BucketDefaults Default settings to be applied to newly created buckets associated with
	// this account. Values here will be used in bucket creation requests which
	// do not specify their own values for corresponding fields.
	BucketDefaults *BucketDefaultsReadonly `json:"bucket_defaults,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the object.
	Created *int64 `json:"created,omitempty"`

	// HardLimitEnabled If set to `true`, the account's size, as defined by `quota_limit`,
	// is used as a hard limit quota.
	// If set to `false`, a hard limit quota will not be applied to the
	// account, but soft quota alerts will still be sent if the account has
	// a value set for `quota_limit`.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// ObjectCount The count of objects within the account.
	ObjectCount *int64 `json:"object_count,omitempty"`

	// PublicAccessConfig Configuration settings related to public access.
	PublicAccessConfig *PublicAccessConfig `json:"public_access_config,omitempty"`

	// QuotaLimit The effective quota limit applied against the size of the account, displayed in bytes.
	// If unset, the account is unlimited in size.
	QuotaLimit *int `json:"quota_limit,omitempty"`

	// Space The space specification of the object store account.
	Space *Space `json:"space,omitempty"`
}

// ObjectStoreAccountGetResponse defines model for ObjectStoreAccountGetResponse.
type ObjectStoreAccountGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of object store account objects.
	Items *[]ObjectStoreAccount `json:"items,omitempty"`

	// Total If `total_only` query param is `true`, then this field will be a total of
	// all records after filtering and no items will be returned.
	// If `total_only` is `false`, then it will be a total of all records
	// on this page.
	Total *ObjectStoreAccount `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreAccountPatch defines model for ObjectStoreAccountPatch.
type ObjectStoreAccountPatch struct {
	// BucketDefaults Default settings to be applied to newly created buckets associated with
	// this account. Values here will be used in bucket creation requests which
	// do not specify their own values for corresponding fields.
	BucketDefaults *BucketDefaults `json:"bucket_defaults,omitempty"`

	// HardLimitEnabled If set to `true`, the account's size, as defined by `quota_limit`,
	// is used as a hard limit quota.
	// If set to `false`, a hard limit quota will not be applied to the
	// account, but soft quota alerts will still be sent if the account has
	// a value set for `quota_limit`.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// PublicAccessConfig Configuration settings related to public access.
	PublicAccessConfig *PublicAccessConfig `json:"public_access_config,omitempty"`

	// QuotaLimit The effective quota limit to be applied against the size of the account, displayed in bytes.
	// If set to an empty string (`""`), the account is unlimited in size.
	QuotaLimit *string `json:"quota_limit,omitempty"`
}

// ObjectStoreAccountPost defines model for ObjectStoreAccountPost.
type ObjectStoreAccountPost struct {
	// BucketDefaults Default settings to be applied to newly created buckets associated with
	// this account. Values here will be used in bucket creation requests which
	// do not specify their own values for corresponding fields.
	BucketDefaults *BucketDefaults `json:"bucket_defaults,omitempty"`

	// HardLimitEnabled If set to `true`, the account's size, as defined by `quota_limit`,
	// is used as a hard limit quota.
	// If set to `false`, a hard limit quota will not be applied to the
	// account, but soft quota alerts will still be sent if the account has
	// a value set for `quota_limit`.
	// If not specified, defaults to `false`.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// QuotaLimit The effective quota limit to be applied against the size of the account, displayed in bytes.
	// If set to an empty string (`""`), the account is unlimited in size. If not specified,
	// defaults to unlimited.
	QuotaLimit *string `json:"quota_limit,omitempty"`
}

// ObjectStoreAccountResponse defines model for ObjectStoreAccountResponse.
type ObjectStoreAccountResponse struct {
	// Items A list of object store account objects.
	Items *[]ObjectStoreAccount `json:"items,omitempty"`
}

// ObjectStoreRemoteCredentialGetResp defines model for ObjectStoreRemoteCredentialGetResp.
type ObjectStoreRemoteCredentialGetResp struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of object store remote credentials.
	Items *[]ObjectStoreRemoteCredentials `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreRemoteCredentials defines model for ObjectStoreRemoteCredentials.
type ObjectStoreRemoteCredentials struct {
	// AccessKeyId Access Key ID to be used when connecting to a remote object store.
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Remote Reference to the associated remote, which can either be a `target` or remote `array`.
	// If it is an `array`, then the `resource-type` field will not be populated.
	Remote *FixedReference `json:"remote,omitempty"`

	// SecretAccessKey Secret Access Key to be used when connecting to a remote object store.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}

// ObjectStoreRemoteCredentialsPost defines model for ObjectStoreRemoteCredentialsPost.
type ObjectStoreRemoteCredentialsPost struct {
	// AccessKeyId Access Key ID to be used when connecting to a remote object store.
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// SecretAccessKey Secret Access Key to be used when connecting to a remote object store.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}

// ObjectStoreRemoteCredentialsResp defines model for ObjectStoreRemoteCredentialsResp.
type ObjectStoreRemoteCredentialsResp struct {
	// Items A list of object store remote credentials.
	Items *[]ObjectStoreRemoteCredentials `json:"items,omitempty"`
}

// ObjectStoreRole defines model for ObjectStoreRole.
type ObjectStoreRole struct {
	// Account Reference of the associated account.
	Account *FixedReference `json:"account,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the object.
	Created *int64 `json:"created,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// MaxSessionDuration The maximum session duration for the role in milliseconds
	MaxSessionDuration *int `json:"max_session_duration,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Prn Pure Resource Name of the role
	Prn *string `json:"prn,omitempty"`

	// TrustedEntities List of trusted entities
	TrustedEntities *[]FixedReference `json:"trusted_entities,omitempty"`
}

// ObjectStoreRoleGetResponse defines model for ObjectStoreRoleGetResponse.
type ObjectStoreRoleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of object store roles.
	Items *[]ObjectStoreRole `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreRolePost defines model for ObjectStoreRolePost.
type ObjectStoreRolePost struct {
	// MaxSessionDuration Maximum session duration in milliseconds.
	// If not provided when creating the role, defaults to 1h, minimum is 1h, maximum is 12h.
	MaxSessionDuration *int `json:"max_session_duration,omitempty"`
}

// ObjectStoreRoleResponse defines model for ObjectStoreRoleResponse.
type ObjectStoreRoleResponse struct {
	// Items A list of object store roles.
	Items *[]ObjectStoreRole `json:"items,omitempty"`
}

// ObjectStoreTrustPolicy defines model for ObjectStoreTrustPolicy.
type ObjectStoreTrustPolicy struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Role Object Store Role to which the Trust Policy applies.
	Role *FixedReference `json:"role,omitempty"`

	// Rules List of rules establishing the trust policy
	Rules *[]TrustPolicyRule `json:"rules,omitempty"`
}

// ObjectStoreTrustPolicyGetResponse defines model for ObjectStoreTrustPolicyGetResponse.
type ObjectStoreTrustPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]ObjectStoreTrustPolicy     `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreTrustPolicyIam Trust policy document in the AWS IAM format.
type ObjectStoreTrustPolicyIam = string

// ObjectStoreTrustPolicyResponse defines model for ObjectStoreTrustPolicyResponse.
type ObjectStoreTrustPolicyResponse struct {
	Items *[]ObjectStoreTrustPolicy `json:"items,omitempty"`
}

// ObjectStoreTrustPolicyRuleGetResponse defines model for ObjectStoreTrustPolicyRuleGetResponse.
type ObjectStoreTrustPolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]TrustPolicyRuleWithContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreTrustPolicyRuleResponse defines model for ObjectStoreTrustPolicyRuleResponse.
type ObjectStoreTrustPolicyRuleResponse struct {
	Items *[]TrustPolicyRuleWithContext `json:"items,omitempty"`
}

// ObjectStoreUser defines model for ObjectStoreUser.
type ObjectStoreUser struct {
	// AccessKeys References of the user's access keys.
	AccessKeys *[]FixedReference `json:"access_keys,omitempty"`

	// Account Reference of the associated account.
	Account *FixedReference `json:"account,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the object.
	Created *int64 `json:"created,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// ObjectStoreUserGetResponse defines model for ObjectStoreUserGetResponse.
type ObjectStoreUserGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of object store user objects.
	Items *[]ObjectStoreUser `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreUserResponse defines model for ObjectStoreUserResponse.
type ObjectStoreUserResponse struct {
	// Items A list of object store user objects.
	Items *[]ObjectStoreUser `json:"items,omitempty"`
}

// ObjectStoreVirtualHost defines model for ObjectStoreVirtualHost.
type ObjectStoreVirtualHost struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A hostname by which the array can be addressed for
	// virtual hosted-style S3 requests.
	Name *string `json:"name,omitempty"`
}

// ObjectStoreVirtualHostGetResponse defines model for ObjectStoreVirtualHostGetResponse.
type ObjectStoreVirtualHostGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of object store virtual host objects.
	Items *[]ObjectStoreVirtualHost `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ObjectStoreVirtualHostResponse defines model for ObjectStoreVirtualHostResponse.
type ObjectStoreVirtualHostResponse struct {
	// Items A list of object store virtual host objects.
	Items *[]ObjectStoreVirtualHost `json:"items,omitempty"`
}

// OidcSso defines model for OidcSso.
type OidcSso struct {
	// Enabled If set to `true`, the OIDC SSO configuration is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Idp Identity Provider
	Idp *OidcSsoPostIdp `json:"idp,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Prn Pure Resource Name of the identity provider
	Prn *string `json:"prn,omitempty"`

	// Services Services that the OIDC SSO authentication is used for.
	// Valid values: `object`.
	Services *[]string `json:"services,omitempty"`
}

// OidcSsoGetResponse defines model for OidcSsoGetResponse.
type OidcSsoGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string    `json:"continuation_token,omitempty"`
	Items             *[]OidcSso `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// OidcSsoPatch defines model for OidcSsoPatch.
type OidcSsoPatch struct {
	// Enabled If set to `true`, the OIDC SSO configuration is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Idp Identity Provider
	Idp *OidcSsoPostIdp `json:"idp,omitempty"`

	// Name A new name for the provider
	Name *string `json:"name,omitempty"`

	// Prn Pure Resource Name of the identity provider
	Prn *string `json:"prn,omitempty"`

	// Services Services that the OIDC SSO authentication is used for.
	// Valid values: `object`.
	Services *[]string `json:"services,omitempty"`
}

// OidcSsoPost defines model for OidcSsoPost.
type OidcSsoPost struct {
	// Enabled If set to `true`, the OIDC SSO configuration is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Idp Identity Provider
	Idp *OidcSsoPostIdp `json:"idp,omitempty"`

	// Prn Pure Resource Name of the identity provider
	Prn *string `json:"prn,omitempty"`

	// Services Services that the OIDC SSO authentication is used for.
	// Valid values: `object`.
	Services *[]string `json:"services,omitempty"`
}

// OidcSsoResponse defines model for OidcSsoResponse.
type OidcSsoResponse struct {
	Items *[]OidcSso `json:"items,omitempty"`
}

// PageInfo defines model for PageInfo.
type PageInfo struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PasswordPoliciesGetResponse defines model for PasswordPoliciesGetResponse.
type PasswordPoliciesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items Returns a list of all items after filtering.
	// If applicable, the values are displayed for each name.
	Items *[]PasswordPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PasswordPoliciesResponse defines model for PasswordPoliciesResponse.
type PasswordPoliciesResponse struct {
	// Items Returns a list of all items after filtering.
	// If applicable, the values are displayed for each name.
	Items *[]PasswordPolicy `json:"items,omitempty"`
}

// PasswordPolicy defines model for PasswordPolicy.
type PasswordPolicy struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// EnforceDictionaryCheck If `true`, test password against dictionary of known leaked passwords.
	// Requires passwords longer than 6 characters.
	EnforceDictionaryCheck *bool `json:"enforce_dictionary_check,omitempty"`

	// EnforceUsernameCheck If `true`, the username cannot be a substring of the password.
	// Only applies to usernames of 4 characters and longer.
	EnforceUsernameCheck *bool `json:"enforce_username_check,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// LockoutDuration The lockout duration, in milliseconds, if a user is locked out after reaching the maximum
	// number of login attempts. Ranges from 1 second to 90 days.
	LockoutDuration *int64 `json:"lockout_duration,omitempty"`

	// MaxLoginAttempts Maximum number of failed login attempts allowed before the user is locked out.
	MaxLoginAttempts *int32 `json:"max_login_attempts,omitempty"`

	// MinCharacterGroups The minimum number of character groups ([a-z], [A-Z], [0-9], other) required to be present
	// in a password.
	MinCharacterGroups *int32 `json:"min_character_groups,omitempty"`

	// MinCharactersPerGroup The minimum number of characters per group to count the group as present.
	MinCharactersPerGroup *int32 `json:"min_characters_per_group,omitempty"`

	// MinPasswordAge The minimum age, in milliseconds, of password before password change is allowed.
	// Ranges from 0 ms to 7 days with precision to 1 hour.
	MinPasswordAge *int64 `json:"min_password_age,omitempty"`

	// MinPasswordLength Minimum password length. If not specified, defaults to 1.
	MinPasswordLength *int32 `json:"min_password_length,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PasswordHistory The number of passwords tracked to prevent reuse of passwords.
	PasswordHistory *int32 `json:"password_history,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// Policy defines model for Policy.
type Policy struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// RetentionLock If retention lock is locked, then the the policy can not be removed
	// from the associated file systems and the rules may not be changed.
	// Valid values are `locked` and `unlocked`.
	// Contact Pure Technical Services to change `locked` to `unlocked`.
	RetentionLock *string       `json:"retention_lock,omitempty"`
	Rules         *[]PolicyRule `json:"rules,omitempty"`
}

// PolicyBase defines model for PolicyBase.
type PolicyBase struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// PolicyBaseContext defines model for PolicyBaseContext.
type PolicyBaseContext struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// PolicyBaseGetResponse defines model for PolicyBaseGetResponse.
type PolicyBaseGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of basic policy objects.
	Items *[]PolicyBaseContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PolicyBaseRenameable defines model for PolicyBaseRenameable.
type PolicyBaseRenameable struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// PolicyBaseResponse defines model for PolicyBaseResponse.
type PolicyBaseResponse struct {
	// Items A list of basic policy objects.
	Items *[]PolicyBaseContext `json:"items,omitempty"`
}

// PolicyFileSystemSnapshot defines model for PolicyFileSystemSnapshot.
type PolicyFileSystemSnapshot struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Member Reference to the resource the policy is applied to.
	Member *FixedReference `json:"member,omitempty"`

	// Policy Reference to the policy.
	Policy *LocationReference `json:"policy,omitempty"`
}

// PolicyFileSystemSnapshotGetResponse defines model for PolicyFileSystemSnapshotGetResponse.
type PolicyFileSystemSnapshotGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of members for policies.
	Items *[]PolicyFileSystemSnapshot `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PolicyFileSystemSnapshotResponse defines model for PolicyFileSystemSnapshotResponse.
type PolicyFileSystemSnapshotResponse struct {
	// Items A list of members for policies.
	Items *[]PolicyFileSystemSnapshot `json:"items,omitempty"`
}

// PolicyGetResponse defines model for PolicyGetResponse.
type PolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of policy objects.
	Items *[]Policy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PolicyMember defines model for PolicyMember.
type PolicyMember struct {
	// Member Reference to the resource the policy is applied to.
	Member *FixedReference `json:"member,omitempty"`

	// Policy Reference to the policy.
	Policy *FixedReference `json:"policy,omitempty"`
}

// PolicyMemberContext defines model for PolicyMemberContext.
type PolicyMemberContext struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Member Reference to the resource the policy is applied to.
	Member *FixedReference `json:"member,omitempty"`

	// Policy Reference to the policy.
	Policy *FixedReference `json:"policy,omitempty"`
}

// PolicyMemberContextGetResponse defines model for PolicyMemberContextGetResponse.
type PolicyMemberContextGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of members for policies.
	Items *[]PolicyMemberContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PolicyMemberContextResponse defines model for PolicyMemberContextResponse.
type PolicyMemberContextResponse struct {
	// Items A list of members for policies.
	Items *[]PolicyMemberContext `json:"items,omitempty"`
}

// PolicyMemberGetResponse defines model for PolicyMemberGetResponse.
type PolicyMemberGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of members for policies.
	Items *[]PolicyMember `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PolicyMemberResponse defines model for PolicyMemberResponse.
type PolicyMemberResponse struct {
	// Items A list of members for policies.
	Items *[]PolicyMember `json:"items,omitempty"`
}

// PolicyMemberWithRemote defines model for PolicyMemberWithRemote.
type PolicyMemberWithRemote struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Link Only populated if the `member` is a file system replica link. Contains additional
	// information about the link.
	Link *MemberLink `json:"link,omitempty"`

	// Member Reference to the resource the policy is applied to.
	Member *FixedReference `json:"member,omitempty"`

	// Policy Reference to the policy.
	Policy *LocationReference `json:"policy,omitempty"`
}

// PolicyMemberWithRemoteGetResponse defines model for PolicyMemberWithRemoteGetResponse.
type PolicyMemberWithRemoteGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of members for policies.
	Items *[]PolicyMemberWithRemote `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PolicyMemberWithRemoteResponse defines model for PolicyMemberWithRemoteResponse.
type PolicyMemberWithRemoteResponse struct {
	// Items A list of members for policies.
	Items *[]PolicyMemberWithRemote `json:"items,omitempty"`
}

// PolicyPatch defines model for PolicyPatch.
type PolicyPatch struct {
	AddRules *[]PolicyRule `json:"add_rules,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType  *string       `json:"policy_type,omitempty"`
	RemoveRules *[]PolicyRule `json:"remove_rules,omitempty"`

	// RetentionLock If retention lock is locked, then the the policy can not be removed
	// from the associated file systems and the rules may not be changed.
	// Valid values are `locked` and `unlocked`.
	// Contact Pure Technical Services to change `locked` to `unlocked`.
	RetentionLock *string       `json:"retention_lock,omitempty"`
	Rules         *[]PolicyRule `json:"rules,omitempty"`
}

// PolicyResponse defines model for PolicyResponse.
type PolicyResponse struct {
	// Items A list of policy objects.
	Items *[]Policy `json:"items,omitempty"`
}

// PolicyRuleObjectAccess defines model for PolicyRuleObjectAccess.
type PolicyRuleObjectAccess struct {
	// Actions The list of actions granted by this rule. Each included action may
	// restrict other properties of the rule.
	// Supported actions are returned by the
	// `/object-store-access-policy-actions` endpoint.
	Actions *[]string `json:"actions,omitempty"`

	// Conditions Conditions used to limit the scope which this rule applies to.
	Conditions *PolicyRuleObjectAccessCondition `json:"conditions,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// When `deny`, the rule disallows performing the given actions on the given
	// resources, subject to the given condition. This takes precedence over any
	// matching `allow` rules.
	// Valid values include `allow` and `deny`.
	Effect *string `json:"effect,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Resources The list of resources which this rule applies to. Each resource can
	// include a bucket component, optionally followed by an object component.
	// The choice of which components a resource can include is dictated by
	// which actions are included in the rule. For further details, see the
	// Object Store Access Policy Actions section of the User Guide.
	Resources *[]string `json:"resources,omitempty"`
}

// PolicyRuleObjectAccessBulkManage defines model for PolicyRuleObjectAccessBulkManage.
type PolicyRuleObjectAccessBulkManage struct {
	// Actions The list of actions granted by this rule. Each included action may
	// restrict other properties of the rule.
	// Supported actions are returned by the
	// `/object-store-access-policy-actions` endpoint.
	Actions *[]string `json:"actions,omitempty"`

	// Conditions Conditions used to limit the scope which this rule applies to.
	Conditions *PolicyRuleObjectAccessCondition `json:"conditions,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// When `deny`, the rule disallows performing the given actions on the given
	// resources, subject to the given condition. This takes precedence over any
	// matching `allow` rules.
	// Valid values include `allow` and `deny`.
	Effect *string `json:"effect,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Resources The list of resources which this rule applies to. Each resource can
	// include a bucket component, optionally followed by an object component.
	// The choice of which components a resource can include is dictated by
	// which actions are included in the rule. For further details, see the
	// Object Store Access Policy Actions section of the User Guide.
	Resources *[]string `json:"resources,omitempty"`
}

// PolicyRuleObjectAccessPost defines model for PolicyRuleObjectAccessPost.
type PolicyRuleObjectAccessPost struct {
	// Actions The list of actions granted by this rule. Each included action may
	// restrict other properties of the rule.
	// Supported actions are returned by the
	// `/object-store-access-policy-actions` endpoint.
	Actions *[]string `json:"actions,omitempty"`

	// Conditions Conditions used to limit the scope which this rule applies to.
	Conditions *PolicyRuleObjectAccessCondition `json:"conditions,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// When `deny`, the rule disallows performing the given actions on the given
	// resources, subject to the given condition. This takes precedence over any
	// matching `allow` rules.
	// Valid values include `allow` and `deny`.
	Effect *string `json:"effect,omitempty"`

	// Resources The list of resources which this rule applies to. Each resource can
	// include a bucket component, optionally followed by an object component.
	// The choice of which components a resource can include is dictated by
	// which actions are included in the rule. For further details, see the
	// Object Store Access Policy Actions section of the User Guide.
	Resources *[]string `json:"resources,omitempty"`
}

// PublicKey defines model for PublicKey.
type PublicKey struct {
	// Algorithm The cryptographic algorithm used by the key.
	// Valid values include `rsa`, `rsassa-pss`, `dsa`, `ec`, and `ed25519`.
	Algorithm *string `json:"algorithm,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// KeySize The size of the public key in bits.
	KeySize *int32 `json:"key_size,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PublicKey The text of the public key. May be PEM-formatted or OpenSSH-formatted at the time of input.
	PublicKey *string `json:"public_key,omitempty"`
}

// PublicKeyGetResponse defines model for PublicKeyGetResponse.
type PublicKeyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of public key objects.
	Items *[]PublicKey `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PublicKeyPost A public key configuration, defining a key used for cryptographic signature verification.
type PublicKeyPost struct {
	// PublicKey The text of the public key. May be PEM-formatted or OpenSSH-formatted at the time of input.
	PublicKey *string `json:"public_key,omitempty"`
}

// PublicKeyResponse defines model for PublicKeyResponse.
type PublicKeyResponse struct {
	// Items A list of public key objects.
	Items *[]PublicKey `json:"items,omitempty"`
}

// PublicKeyUse defines model for PublicKeyUse.
type PublicKeyUse struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Use A reference to an object using this public key.
	Use *FixedReference `json:"use,omitempty"`
}

// PublicKeyUseGetResponse defines model for PublicKeyUseGetResponse.
type PublicKeyUseGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of public key use objects.
	Items *[]PublicKeyUse `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// PublicKeyUseResponse defines model for PublicKeyUseResponse.
type PublicKeyUseResponse struct {
	// Items A list of public key use objects.
	Items *[]PublicKeyUse `json:"items,omitempty"`
}

// QosPoliciesGetResponse defines model for QosPoliciesGetResponse.
type QosPoliciesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of QoS policy objects.
	Items *[]QosPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// QosPoliciesResponse defines model for QosPoliciesResponse.
type QosPoliciesResponse struct {
	// Items A list of QoS policy objects.
	Items *[]QosPolicy `json:"items,omitempty"`
}

// QosPolicy defines model for QosPolicy.
type QosPolicy struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// MaxTotalBytesPerSec The maximum allowed bytes/s totaled across all the clients.
	// Throttling occurs when the total bandwidth exceeds this limit.
	// Minimum limit is 1MB/s and maximum limit is 512GB/s.
	// If not specified at creation time, defaults to `null` to indicate no limit.
	MaxTotalBytesPerSec *int64 `json:"max_total_bytes_per_sec,omitempty"`

	// MaxTotalOpsPerSec The maximum allowed operations/s totaled across all the clients.
	// Throttling occurs when the total IOPs exceeds this limit.
	// Minimum limit is 100 IOPs/s and maximum limit is 100M IOPs/s.
	// If not specified at creation time, defaults to `null` to indicate no limit.
	MaxTotalOpsPerSec *int64 `json:"max_total_ops_per_sec,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// QuotaSetting defines model for QuotaSetting.
type QuotaSetting struct {
	// Contact The contact information that will be provided in any notifications
	// sent directly to users and groups. This can be an email, a phone
	// number, a name, or some other form of contact information.
	Contact *string `json:"contact,omitempty"`

	// DirectNotificationsEnabled Are notifications regarding space usage and quotas being sent directly
	// to user and group emails?
	DirectNotificationsEnabled *bool `json:"direct_notifications_enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// QuotaSettingGetResponse defines model for QuotaSettingGetResponse.
type QuotaSettingGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of quota settings objects.
	Items *[]QuotaSetting `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// QuotaSettingResponse defines model for QuotaSettingResponse.
type QuotaSettingResponse struct {
	// Items A list of quota settings objects.
	Items *[]QuotaSetting `json:"items,omitempty"`
}

// RapidDataLocking defines model for RapidDataLocking.
type RapidDataLocking struct {
	// Enabled `True` if the Rapid Data Locking feature is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// KmipServer The KMIP server configuration associated with RDL.
	KmipServer *Reference `json:"kmip_server,omitempty"`
}

// RapidDataLockingResponse defines model for RapidDataLockingResponse.
type RapidDataLockingResponse struct {
	Items *[]RapidDataLocking `json:"items,omitempty"`
}

// RelationshipPerformanceReplication defines model for RelationshipPerformanceReplication.
type RelationshipPerformanceReplication struct {
	// Aggregate Total bytes transmitted or received per second for all types of
	// replication.
	Aggregate *ReplicationPerformance `json:"aggregate,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Continuous Object backlog information and total bytes transmitted or received
	// per second for continuous replication. Continuous replication
	// includes object replication.
	Continuous *ContinuousReplicationPerformance `json:"continuous,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Periodic Total bytes transmitted or received per second for periodic
	// replication. Periodic replication includes file system replication,
	// which is snapshot based.
	Periodic *ReplicationPerformance `json:"periodic,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`
}

// RemoteArray defines model for RemoteArray.
type RemoteArray struct {
	Fleet *FixedReferenceWithIsLocal `json:"fleet,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal If set to `true`, this array is the current array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Model Specifies the array model.
	Model *string `json:"model,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Os Specifies the operating system. Valid values are Purity, Purity//FA, and Purity//FB.
	Os *string `json:"os,omitempty"`

	// Version Specifies the operating system version.
	Version *string `json:"version,omitempty"`
}

// RemoteArraysResponse defines model for RemoteArraysResponse.
type RemoteArraysResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items Returns a list of all items after filtering.
	// The values are displayed for each name where meaningful.
	Items *[]RemoteArray `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ResourcePerformanceReplication defines model for ResourcePerformanceReplication.
type ResourcePerformanceReplication struct {
	// Aggregate Total bytes transmitted or received per second for all types of
	// replication.
	Aggregate *ReplicationPerformance `json:"aggregate,omitempty"`

	// Continuous Object backlog information and total bytes transmitted or received
	// per second for continuous replication. Continuous replication
	// includes object replication.
	Continuous *ContinuousReplicationPerformance `json:"continuous,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Periodic Total bytes transmitted or received per second for periodic
	// replication. Periodic replication includes file system replication,
	// which is snapshot based.
	Periodic *ReplicationPerformance `json:"periodic,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`
}

// ResourcePerformanceReplicationGetResponse defines model for ResourcePerformanceReplicationGetResponse.
type ResourcePerformanceReplicationGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string                           `json:"continuation_token,omitempty"`
	Items             *[]ResourcePerformanceReplication `json:"items,omitempty"`

	// Total Total of all records after filtering.
	// If `total_only` query param is `true`, then no items will be returned.
	Total *[]ResourcePerformanceReplication `json:"total,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// Role defines model for Role.
type Role struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permissions A list of permissions that the role can perform.
	Permissions *[]Permission `json:"permissions,omitempty"`
}

// RoleGetResponse defines model for RoleGetResponse.
type RoleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`
	Items             *[]Role `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// Saml2Sso defines model for Saml2Sso.
type Saml2Sso struct {
	// ArrayUrl The URL of the array.
	ArrayUrl *string `json:"array_url,omitempty"`

	// Binding SAML2 binding to use for the request from Flashblade to the Identity
	// Provider.
	// Valid values: `http-redirect`, `none`.
	// Defaults to `http-redirect`.
	Binding *string `json:"binding,omitempty"`

	// Enabled If set to `true`, the SAML2 SSO configuration is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Idp Properties specific to the identity provider.
	Idp *Saml2SsoIdp `json:"idp,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Prn Pure Resource Name of the identity provider
	Prn *string `json:"prn,omitempty"`

	// Services Services that the SAML2 SSO authentication is used for.
	// Valid values: `management`, `object`.
	// Defaults to `management`.
	Services *[]string   `json:"services,omitempty"`
	Sp       *Saml2SsoSp `json:"sp,omitempty"`
}

// Saml2SsoGetResponse defines model for Saml2SsoGetResponse.
type Saml2SsoGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string     `json:"continuation_token,omitempty"`
	Items             *[]Saml2Sso `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// Saml2SsoPost defines model for Saml2SsoPost.
type Saml2SsoPost struct {
	// ArrayUrl The URL of the array.
	ArrayUrl *string `json:"array_url,omitempty"`

	// Binding SAML2 binding to use for the request from Flashblade to the Identity
	// Provider.
	// Valid values: `http-redirect`, `none`.
	// Defaults to `http-redirect`.
	Binding *string `json:"binding,omitempty"`

	// Enabled If set to `true`, the SAML2 SSO configuration is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Idp Properties specific to the identity provider.
	Idp *Saml2SsoIdp `json:"idp,omitempty"`

	// Prn Pure Resource Name of the identity provider
	Prn *string `json:"prn,omitempty"`

	// Services Services that the SAML2 SSO authentication is used for.
	// Valid values: `management`, `object`.
	// Defaults to `management`.
	Services *[]string   `json:"services,omitempty"`
	Sp       *Saml2SsoSp `json:"sp,omitempty"`
}

// Saml2SsoResponse defines model for Saml2SsoResponse.
type Saml2SsoResponse struct {
	Items *[]Saml2Sso `json:"items,omitempty"`
}

// Server defines model for Server.
type Server struct {
	// Created Creation timestamp of the server.
	Created *int64 `json:"created,omitempty"`

	// DirectoryServices The directory service config to be used by this server.
	DirectoryServices *[]Reference `json:"directory_services,omitempty"`

	// Dns The DNS config to be used by this server.
	Dns *[]Reference `json:"dns,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`
}

// ServerContext defines model for ServerContext.
type ServerContext struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Created Creation timestamp of the server.
	Created *int64 `json:"created,omitempty"`

	// DirectoryServices The directory service config to be used by this server.
	DirectoryServices *[]Reference `json:"directory_services,omitempty"`

	// Dns The DNS config to be used by this server.
	Dns *[]Reference `json:"dns,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`
}

// ServerGetResponse defines model for ServerGetResponse.
type ServerGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of server objects.
	Items *[]ServerContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// ServerPost defines model for ServerPost.
type ServerPost struct {
	// DirectoryServices The directory service config to be used by this server.
	DirectoryServices *[]Reference `json:"directory_services,omitempty"`

	// Dns The DNS config to be used by this server.
	Dns *[]Reference `json:"dns,omitempty"`
}

// ServerResponse defines model for ServerResponse.
type ServerResponse struct {
	// Items A list of server objects.
	Items *[]Server `json:"items,omitempty"`
}

// ServerResponseContext defines model for ServerResponseContext.
type ServerResponseContext struct {
	// Items A list of server objects.
	Items *[]ServerContext `json:"items,omitempty"`
}

// Session defines model for Session.
type Session struct {
	// EndTime Date and time the user logged out of the Purity//FB interface in
	// milliseconds since UNIX epoch. Set to 0 if the session is still active.
	EndTime *int64 `json:"end_time,omitempty"`

	// Event Description of session events. Valid values include
	// `failed authentication`, `user session`, `login`,
	// `logout`, `API token obtained`, and `request without session`.
	Event *string `json:"event,omitempty"`

	// EventCount Number of session events.
	EventCount *int32 `json:"event_count,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IdentifyingDetails Additional details, depending on the authentication method used,
	// which are necessary to uniquely identify who authenticated as
	// a user. `null` if no additional details are needed.
	IdentifyingDetails *string `json:"identifying_details,omitempty"`

	// Location IP address of the user client connecting to the array or console if connected through local
	// console.
	Location *string `json:"location,omitempty"`

	// Method Method by which the user attempted to log in.
	// Valid values include `API token`, `password`, `ssh certificate`,
	// and `public key`.
	Method *string `json:"method,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// StartTime Date and time the user logged in to the Purity//FB interface
	// in milliseconds since UNIX epoch.
	StartTime *int64 `json:"start_time,omitempty"`

	// User Username of the Purity//FB user who triggered the user session event.
	User *string `json:"user,omitempty"`

	// UserInterface The user interface through which the user session event was performed.
	// Valid values include `CLI`, `GUI`, and `REST`.
	UserInterface *string `json:"user_interface,omitempty"`
}

// SessionGetResponse defines model for SessionGetResponse.
type SessionGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string    `json:"continuation_token,omitempty"`
	Items             *[]Session `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SmbClientPolicy defines model for SmbClientPolicy.
type SmbClientPolicy struct {
	// AccessBasedEnumerationEnabled If set to `true`, enables access based enumeration on the policy.
	// When access based enumeration is enabled on a policy,
	// files and folders within exports that are attached to the policy
	// will be hidden from users who do not have permission to view them.
	// If not specified, defaults to `false`.
	AccessBasedEnumerationEnabled *bool `json:"access_based_enumeration_enabled,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Rules All of the rules that are part of this policy. The order is the
	// evaluation order.
	Rules *[]SmbClientPolicyRuleInPolicy `json:"rules,omitempty"`

	// Version A hash of the other properties of this resource. This can be used when
	// updating the resource to ensure there aren't any updates since the
	// resource was read.
	Version *string `json:"version,omitempty"`
}

// SmbClientPolicyGetResponse defines model for SmbClientPolicyGetResponse.
type SmbClientPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of SMB Client policy objects.
	Items *[]SmbClientPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SmbClientPolicyPost defines model for SmbClientPolicyPost.
type SmbClientPolicyPost struct {
	// AccessBasedEnumerationEnabled If set to `true`, enables access based enumeration on the policy.
	// When access based enumeration is enabled on a policy,
	// files and folders within exports that are attached to the policy
	// will be hidden from users who do not have permission to view them.
	// If not specified, defaults to `false`.
	AccessBasedEnumerationEnabled *bool `json:"access_based_enumeration_enabled,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Rules All of the rules that are part of this policy. The order is the
	// evaluation order.
	Rules *[]SmbClientPolicyRulePostInPolicy `json:"rules,omitempty"`
}

// SmbClientPolicyResponse defines model for SmbClientPolicyResponse.
type SmbClientPolicyResponse struct {
	// Items A list of SMB Client policy objects.
	Items *[]SmbClientPolicy `json:"items,omitempty"`
}

// SmbClientPolicyRule defines model for SmbClientPolicyRule.
type SmbClientPolicyRule struct {
	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation,
	// or anonymous (`*`).
	Client *string `json:"client,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Encryption Specifies whether the remote client is required to use SMB encryption. Valid values are
	// `required`, `disabled`, and `optional`.
	Encryption *string `json:"encryption,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	// NOTE: It is recommended to use the query param `before_rule_id` to do reordering to
	// avoid concurrency issues, but changing `index` is also supported. `index` can not be
	// changed if `before_rule_id` or `before_rule_name` are specified.
	Index *int32 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`.
	Permission *string `json:"permission,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`
}

// SmbClientPolicyRuleBase defines model for SmbClientPolicyRuleBase.
type SmbClientPolicyRuleBase struct {
	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation,
	// or anonymous (`*`).
	Client *string `json:"client,omitempty"`

	// Encryption Specifies whether the remote client is required to use SMB encryption. Valid values are
	// `required`, `disabled`, and `optional`.
	Encryption *string `json:"encryption,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`.
	Permission *string `json:"permission,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`
}

// SmbClientPolicyRuleGetResponse defines model for SmbClientPolicyRuleGetResponse.
type SmbClientPolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]SmbClientPolicyRule        `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SmbClientPolicyRuleInPolicy defines model for SmbClientPolicyRuleInPolicy.
type SmbClientPolicyRuleInPolicy struct {
	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation,
	// or anonymous (`*`).
	Client *string `json:"client,omitempty"`

	// Encryption Specifies whether the remote client is required to use SMB encryption. Valid values are
	// `required`, `disabled`, and `optional`.
	Encryption *string `json:"encryption,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	Index *int32 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`.
	Permission *string `json:"permission,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// PolicyVersion The policy's version. This can be used when updating the
	// resource to ensure there aren't any updates to the policy since the resource was read.
	PolicyVersion *string `json:"policy_version,omitempty"`
}

// SmbClientPolicyRulePost defines model for SmbClientPolicyRulePost.
type SmbClientPolicyRulePost struct {
	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation,
	// or anonymous (`*`).
	// The default is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Encryption Specifies whether the remote client is required to use SMB encryption. Valid values are
	// `required`, `disabled`, and `optional`. If not specified, defaults to `optional`.
	Encryption *string `json:"encryption,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	// NOTE: It is recommended to use the query param `before_rule_id` to do reordering to
	// avoid concurrency issues, but changing `index` is also supported. `index` can not be
	// changed if `before_rule_id` or `before_rule_name` are specified.
	Index *int32 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`. The default is `ro` if not specified.
	Permission *string `json:"permission,omitempty"`
}

// SmbClientPolicyRulePostBase defines model for SmbClientPolicyRulePostBase.
type SmbClientPolicyRulePostBase struct {
	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation,
	// or anonymous (`*`).
	// The default is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Encryption Specifies whether the remote client is required to use SMB encryption. Valid values are
	// `required`, `disabled`, and `optional`. If not specified, defaults to `optional`.
	Encryption *string `json:"encryption,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`. The default is `ro` if not specified.
	Permission *string `json:"permission,omitempty"`
}

// SmbClientPolicyRulePostInPolicy defines model for SmbClientPolicyRulePostInPolicy.
type SmbClientPolicyRulePostInPolicy struct {
	// Client Specifies the clients that will be permitted to access the export.
	// Accepted notation is a single IP address, subnet in CIDR notation,
	// or anonymous (`*`).
	// The default is `*` if not specified.
	Client *string `json:"client,omitempty"`

	// Encryption Specifies whether the remote client is required to use SMB encryption. Valid values are
	// `required`, `disabled`, and `optional`. If not specified, defaults to `optional`.
	Encryption *string `json:"encryption,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	Index *int32 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Permission Specifies which read-write client access permissions are allowed for the export.
	// Valid values are `rw` and `ro`. The default is `ro` if not specified.
	Permission *string `json:"permission,omitempty"`
}

// SmbClientPolicyRuleResponse defines model for SmbClientPolicyRuleResponse.
type SmbClientPolicyRuleResponse struct {
	Items *[]SmbClientPolicyRule `json:"items,omitempty"`
}

// SmbSharePolicy defines model for SmbSharePolicy.
type SmbSharePolicy struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Rules All of the rules that are part of this policy.
	Rules *[]SmbSharePolicyRule `json:"rules,omitempty"`
}

// SmbSharePolicyGetResponse defines model for SmbSharePolicyGetResponse.
type SmbSharePolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of SMB Share policy objects.
	Items *[]SmbSharePolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SmbSharePolicyPost defines model for SmbSharePolicyPost.
type SmbSharePolicyPost struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// Rules All of the rules that are part of this policy.
	Rules *[]SmbSharePolicyRulePost `json:"rules,omitempty"`
}

// SmbSharePolicyResponse defines model for SmbSharePolicyResponse.
type SmbSharePolicyResponse struct {
	// Items A list of SMB Share policy objects.
	Items *[]SmbSharePolicy `json:"items,omitempty"`
}

// SmbSharePolicyRule defines model for SmbSharePolicyRule.
type SmbSharePolicyRule struct {
	// Change The state of the principal's Change access permission.
	// Valid values are `allow` and `deny`. When not set, value is `null`.
	// When allowed, includes all access granted by the Read permission. Users
	// can also change data within files and add or delete files and folders.
	// When denied, these operations are explicitly blocked.
	// If not set for any applicable rule on any applicable policy, acts as an
	// implicit deny.
	// If set to `allow`, implicitly sets the Read permission to `allow`. This
	// is incompatible with explicitly setting any permission to `deny`.
	// If set to `deny`, implicitly sets the Read permission to `deny`, and
	// clears the Full Control permission if it is currently `allow`. This is
	// incompatible with explicitly setting any permission to `allow`.
	// If set to an empty string (`""`), the value (and implicitly the Full
	// Control permission) will be cleared. This is incompatible with
	// explicitly setting the Full Control permission to `allow` or `deny`.
	Change *string `json:"change,omitempty"`

	// FullControl The state of the principal's Full Control access permission.
	// Valid values are `allow` and `deny`. When not set, value is `null`.
	// When allowed, includes all access granted by the Change permission. Users
	// can also change the permissions for files and folders.
	// When denied, these operations are explicitly blocked.
	// If not set for any applicable rule on any applicable policy, acts as an
	// implicit deny.
	// If set to `allow`, implicitly sets the Change and Read permissions to
	// `allow`. This is incompatible with explicitly setting any permission to
	// `deny`.
	// If set to `deny`, implicitly sets the Change and Read permissions to
	// `deny`. This is incompatible with explicitly setting any permission to
	// `allow`.
	// If set to an empty string (`""`), the value will be cleared.
	FullControl *string `json:"full_control,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Principal The user or group who is the subject of this rule, and their domain.
	// If modifying this value, providing the domain is optional. If no domain
	// is provided, it will be derived if possible.
	// For example, `PURESTORAGE\Administrator`, `samplegroup@PureStorage`, or
	// `sampleuser`.
	Principal *string `json:"principal,omitempty"`

	// Read The state of the principal's Read access permission.
	// Valid values are `allow` and `deny`.
	// When allowed, users can view file names, read the data in those files, and
	// run some programs.
	// When denied, these operations are explicitly blocked.
	// If set to `allow`, implicitly clears the Full Control and Change
	// permissions if they are currently `deny`. This is incompatible with
	// explicitly setting any permission to `deny`.
	// If set to `deny`, implicitly clears the Full Control and Change
	// permissions if they are currently `allow`. This is incompatible with
	// explicitly setting any permission to `allow`.
	Read *string `json:"read,omitempty"`
}

// SmbSharePolicyRuleGetResponse defines model for SmbSharePolicyRuleGetResponse.
type SmbSharePolicyRuleGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of SMB Share policy rule objects.
	Items *[]SmbSharePolicyRuleWithContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SmbSharePolicyRulePost defines model for SmbSharePolicyRulePost.
type SmbSharePolicyRulePost struct {
	// Change The state of the principal's Change access permission.
	// Valid values are `allow` and `deny`. When not set, value is `null`.
	// When allowed, includes all access granted by the Read permission. Users
	// can also change data within files and add or delete files and folders.
	// When denied, these operations are explicitly blocked.
	// If not set for any applicable rule on any applicable policy, acts as an
	// implicit deny.
	// If set to `allow`, implicitly sets the Read permission to `allow`. This
	// is incompatible with explicitly setting any permission to `deny`.
	// If set to `deny`, implicitly sets the Read permission to `deny`. This is
	// incompatible with explicitly setting any permission to `allow`.
	// Defaults to `null`.
	Change *string `json:"change,omitempty"`

	// FullControl The state of the principal's Full Control access permission.
	// Valid values are `allow` and `deny`. When not set, value is `null`.
	// When allowed, includes all access granted by the Change permission. Users
	// can also change the permissions for files and folders.
	// When denied, these operations are explicitly blocked.
	// If not set for any applicable rule on any applicable policy, acts as an
	// implicit deny.
	// If set to `allow`, implicitly sets the Change and Read permissions to
	// `allow`. This is incompatible with explicitly setting any permission to
	// `deny`.
	// If set to `deny`, implicitly sets the Change and Read permissions to
	// `deny`. This is incompatible with explicitly setting any permission to
	// `allow`.
	// Defaults to `null`.
	FullControl *string `json:"full_control,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Principal The user or group who is the subject of this rule, and optionally their
	// domain. If no domain is provided, it will be derived if possible.
	// For example, `PURESTORAGE\Administrator`, `samplegroup@PureStorage`, or
	// `sampleuser`.
	Principal *string `json:"principal,omitempty"`

	// Read The state of the principal's Read access permission.
	// Valid values are `allow` and `deny`.
	// When allowed, users can view file names, read the data in those files, and
	// run some programs.
	// When denied, these operations are explicitly blocked.
	// When setting to `allow`, cannot explicitly set any permission to `deny`.
	// When setting to `deny`, cannot explicitly set any permission to `allow`.
	Read *string `json:"read,omitempty"`
}

// SmbSharePolicyRuleResponse defines model for SmbSharePolicyRuleResponse.
type SmbSharePolicyRuleResponse struct {
	// Items A list of SMB Share policy rule objects.
	Items *[]SmbSharePolicyRuleWithContext `json:"items,omitempty"`
}

// SmbSharePolicyRuleWithContext defines model for SmbSharePolicyRuleWithContext.
type SmbSharePolicyRuleWithContext struct {
	// Change The state of the principal's Change access permission.
	// Valid values are `allow` and `deny`. When not set, value is `null`.
	// When allowed, includes all access granted by the Read permission. Users
	// can also change data within files and add or delete files and folders.
	// When denied, these operations are explicitly blocked.
	// If not set for any applicable rule on any applicable policy, acts as an
	// implicit deny.
	// If set to `allow`, implicitly sets the Read permission to `allow`. This
	// is incompatible with explicitly setting any permission to `deny`.
	// If set to `deny`, implicitly sets the Read permission to `deny`, and
	// clears the Full Control permission if it is currently `allow`. This is
	// incompatible with explicitly setting any permission to `allow`.
	// If set to an empty string (`""`), the value (and implicitly the Full
	// Control permission) will be cleared. This is incompatible with
	// explicitly setting the Full Control permission to `allow` or `deny`.
	Change *string `json:"change,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// FullControl The state of the principal's Full Control access permission.
	// Valid values are `allow` and `deny`. When not set, value is `null`.
	// When allowed, includes all access granted by the Change permission. Users
	// can also change the permissions for files and folders.
	// When denied, these operations are explicitly blocked.
	// If not set for any applicable rule on any applicable policy, acts as an
	// implicit deny.
	// If set to `allow`, implicitly sets the Change and Read permissions to
	// `allow`. This is incompatible with explicitly setting any permission to
	// `deny`.
	// If set to `deny`, implicitly sets the Change and Read permissions to
	// `deny`. This is incompatible with explicitly setting any permission to
	// `allow`.
	// If set to an empty string (`""`), the value will be cleared.
	FullControl *string `json:"full_control,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Principal The user or group who is the subject of this rule, and their domain.
	// If modifying this value, providing the domain is optional. If no domain
	// is provided, it will be derived if possible.
	// For example, `PURESTORAGE\Administrator`, `samplegroup@PureStorage`, or
	// `sampleuser`.
	Principal *string `json:"principal,omitempty"`

	// Read The state of the principal's Read access permission.
	// Valid values are `allow` and `deny`.
	// When allowed, users can view file names, read the data in those files, and
	// run some programs.
	// When denied, these operations are explicitly blocked.
	// If set to `allow`, implicitly clears the Full Control and Change
	// permissions if they are currently `deny`. This is incompatible with
	// explicitly setting any permission to `deny`.
	// If set to `deny`, implicitly clears the Full Control and Change
	// permissions if they are currently `allow`. This is incompatible with
	// explicitly setting any permission to `allow`.
	Read *string `json:"read,omitempty"`
}

// SmtpServer defines model for SmtpServer.
type SmtpServer struct {
	// EncryptionMode Enforces an encryption mode when sending alert email messages.
	// Valid values include `starttls`.
	// Use "" to clear.
	EncryptionMode *string `json:"encryption_mode,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// RelayHost Relay server used as a forwarding point for email sent from the array.
	// Can be set as a hostname, IPv4 address, or IPv6 address, with optional port numbers.
	// The expected format for IPv4 is `ddd.ddd.ddd.ddd:PORT`.
	// The expected format for IPv6 is `xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx`, or
	// if a port number is specified, `[xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx]:PORT`.
	RelayHost *string `json:"relay_host,omitempty"`

	// SenderDomain Domain name appended to alert email messages.
	SenderDomain *string `json:"sender_domain,omitempty"`
}

// SmtpServerGetResponse defines model for SmtpServerGetResponse.
type SmtpServerGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string       `json:"continuation_token,omitempty"`
	Items             *[]SmtpServer `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SmtpServerResponse defines model for SmtpServerResponse.
type SmtpServerResponse struct {
	Items *[]SmtpServer `json:"items,omitempty"`
}

// SnmpAgent defines model for SnmpAgent.
type SnmpAgent struct {
	// EngineId An SNMP agent's adminstration domain unique name.
	EngineId *string `json:"engine_id,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// V2c The v2c configurations of SNMP.
	V2c *SnmpV2c `json:"v2c,omitempty"`

	// V3 The v3 configurations of SNMP.
	V3 *SnmpV3 `json:"v3,omitempty"`

	// Version Version of the SNMP protocol to be used by an SNMP manager
	// in communications with Purity's SNMP agent.
	// Valid values are `v2c` and `v3`.
	Version *string `json:"version,omitempty"`
}

// SnmpAgentGetResponse defines model for SnmpAgentGetResponse.
type SnmpAgentGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string      `json:"continuation_token,omitempty"`
	Items             *[]SnmpAgent `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SnmpAgentMib defines model for SnmpAgentMib.
type SnmpAgentMib struct {
	// Mib MIB text.
	Mib *string `json:"mib,omitempty"`
}

// SnmpAgentMibResponse defines model for SnmpAgentMibResponse.
type SnmpAgentMibResponse struct {
	Items *[]SnmpAgentMib `json:"items,omitempty"`
}

// SnmpAgentResponse defines model for SnmpAgentResponse.
type SnmpAgentResponse struct {
	Items *[]SnmpAgent `json:"items,omitempty"`
}

// SnmpManager defines model for SnmpManager.
type SnmpManager struct {
	// Host DNS hostname or IP address of a computer that hosts an SNMP manager
	// to which Purity is to send trap messages when it generates alerts.
	Host *string `json:"host,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Notification The type of notification the agent will send.
	// Valid values are `inform` and `trap`.
	Notification *string `json:"notification,omitempty"`

	// V2c The v2c configurations of SNMP.
	V2c *SnmpV2c `json:"v2c,omitempty"`

	// V3 The v3 configurations of SNMP.
	V3 *SnmpV3 `json:"v3,omitempty"`

	// Version Version of the SNMP protocol to be used by Purity in communications
	// with the specified manager.
	// Valid values are `v2c` and `v3`.
	Version *string `json:"version,omitempty"`
}

// SnmpManagerGetResponse defines model for SnmpManagerGetResponse.
type SnmpManagerGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string        `json:"continuation_token,omitempty"`
	Items             *[]SnmpManager `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SnmpManagerPost defines model for SnmpManagerPost.
type SnmpManagerPost struct {
	// Host DNS hostname or IP address of a computer that hosts an SNMP manager
	// to which Purity is to send trap messages when it generates alerts.
	Host *string `json:"host,omitempty"`

	// Notification The type of notification the agent will send.
	// Valid values are `inform` and `trap`.
	Notification *string `json:"notification,omitempty"`

	// V2c The v2c configurations of SNMP.
	V2c *SnmpV2c `json:"v2c,omitempty"`

	// V3 The v3 configurations of SNMP.
	V3 *SnmpV3Post `json:"v3,omitempty"`

	// Version Version of the SNMP protocol to be used by Purity in communications
	// with the specified manager.
	// Valid values are `v2c` and `v3`.
	Version *string `json:"version,omitempty"`
}

// SnmpManagerResponse defines model for SnmpManagerResponse.
type SnmpManagerResponse struct {
	Items *[]SnmpManager `json:"items,omitempty"`
}

// SoftwareCheck defines model for SoftwareCheck.
type SoftwareCheck struct {
	// Checks A list of checks in this check task.
	Checks *[]SoftwareChecksChecks `json:"checks,omitempty"`

	// Details The detailed reason for the `status`.
	Details *string `json:"details,omitempty"`

	// EndTime End time in milliseconds since the UNIX epoch.
	EndTime *int64 `json:"end_time,omitempty"`

	// Id A globally unique, system-generated ID. The ID cannot be modified.
	Id *string `json:"id,omitempty"`

	// Name Name of the resource. The name cannot be modified.
	Name *string `json:"name,omitempty"`

	// SoftwareName The name of the software the upgrade checks will test.
	SoftwareName *string `json:"software_name,omitempty"`

	// SoftwareUpgradeHops The list of software versions the upgrade goes through. The upgrade checks
	// also test this particular path.
	SoftwareUpgradeHops *[]string `json:"software_upgrade_hops,omitempty"`

	// SoftwareVersion The version of the software that the upgrade checks will test.
	SoftwareVersion *string `json:"software_version,omitempty"`

	// StartTime Start time in milliseconds since the UNIX epoch.
	StartTime *int64 `json:"start_time,omitempty"`

	// Status The status of the check task.
	// Valid values are `queued`, `running`, `passed`, and `failed`.
	// A status of `queued` indicates that the task is queued to run and is waiting
	// for other check tasks to complete.
	// A status of `running` indicates that the task is currently running.
	// A status of `passed` indicates that all upgrade checks in the task are complete.
	// A status of `failed` indicates that at least one upgrade check in the task has failed.
	Status *string `json:"status,omitempty"`
}

// SoftwareChecksGetResponse defines model for SoftwareChecksGetResponse.
type SoftwareChecksGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string          `json:"continuation_token,omitempty"`
	Items             *[]SoftwareCheck `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SoftwareChecksResponse defines model for SoftwareChecksResponse.
type SoftwareChecksResponse struct {
	Items *[]SoftwareCheck `json:"items,omitempty"`
}

// SshCertificateAuthorityPolicy defines model for SshCertificateAuthorityPolicy.
type SshCertificateAuthorityPolicy struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// SigningAuthority A reference to the authority that will digitally sign user SSH certificates that will be
	// used to access the system.
	// This may be either a certificate or a public key. If a certificate is used as the signer,
	// then its expiry period will be honored and user SSH certificates signed by the certificate
	// will no longer be accepted after the certificate has expired.
	SigningAuthority *ReferenceWritable `json:"signing_authority,omitempty"`

	// StaticAuthorizedPrincipals If not specified - users affected by this policy can only log into the system when they
	// present an SSH certificate containing their own username as a principle.
	// If specified - users affected by this policy can only log into the system when they
	// present an SSH certificate containing at least one username from this list as a
	// principle.
	StaticAuthorizedPrincipals *[]string `json:"static_authorized_principals,omitempty"`
}

// SshCertificateAuthorityPolicyGetResponse defines model for SshCertificateAuthorityPolicyGetResponse.
type SshCertificateAuthorityPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of SSH certificate authority policy objects.
	Items *[]SshCertificateAuthorityPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SshCertificateAuthorityPolicyPost defines model for SshCertificateAuthorityPolicyPost.
type SshCertificateAuthorityPolicyPost struct {
	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// SigningAuthority A reference to the authority that will digitally sign user SSH certificates that will be
	// used to access the system.
	// This may be either a certificate or a public key. If a certificate is used as the signer,
	// then its expiry period will be honored and user SSH certificates signed by the certificate
	// will no longer be accepted after the certificate has expired.
	SigningAuthority *ReferenceWritable `json:"signing_authority,omitempty"`

	// StaticAuthorizedPrincipals If not specified - users affected by this policy can only log into the system when they
	// present an SSH certificate containing their own username as a principle.
	// If specified - users affected by this policy can only log into the system when they
	// present an SSH certificate containing at least one username from this list as a
	// principle.
	StaticAuthorizedPrincipals *[]string `json:"static_authorized_principals,omitempty"`
}

// SshCertificateAuthorityPolicyResponse defines model for SshCertificateAuthorityPolicyResponse.
type SshCertificateAuthorityPolicyResponse struct {
	// Items A list of SSH certificate authority policy objects.
	Items *[]SshCertificateAuthorityPolicy `json:"items,omitempty"`
}

// StorageClassInfo defines model for StorageClassInfo.
type StorageClassInfo struct {
	Name *string `json:"name,omitempty"`

	// Status The status of the transition from the policy to the requested policy. If there is an ongoing transition, the status will be one of `In-Progress` or `Queued`. If there is no transition ongoing, this field will be null.
	Status *string `json:"status,omitempty"`

	// StatusDetails Additional details about the status of the transition. If there is no transition ongoing, this field will be null.
	StatusDetails *string `json:"status_details,omitempty"`
}

// StorageClassSpace defines model for StorageClassSpace.
type StorageClassSpace struct {
	// Capacity Usable capacity in bytes.
	Capacity *int64  `json:"capacity,omitempty"`
	Name     *string `json:"name,omitempty"`
	Space    *Space  `json:"space,omitempty"`

	// Time Sample time in milliseconds since UNIX epoch.
	Time *int64 `json:"time,omitempty"`
}

// Subnet defines model for Subnet.
type Subnet struct {
	// Enabled Indicates if subnet is enabled (`true`) or disabled (`false`).
	// If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Gateway The IPv4 or IPv6 address of the gateway through which the specified
	// subnet is to communicate with the network.
	Gateway *string `json:"gateway,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Interfaces List of network interfaces associated with this subnet.
	Interfaces *[]FixedReference `json:"interfaces,omitempty"`

	// LinkAggregationGroup Reference to the associated LAG.
	LinkAggregationGroup *Reference `json:"link_aggregation_group,omitempty"`

	// Mtu Maximum message transfer unit (packet) size for the subnet in bytes.
	// MTU setting cannot exceed the MTU of the corresponding physical
	// interface. If not specified, defaults to `1500`.
	Mtu *int32 `json:"mtu,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Prefix The IPv4 or IPv6 address to be associated with the specified subnet.
	Prefix *string `json:"prefix,omitempty"`

	// Services The services provided by this subnet, as inherited from all of its
	// interfaces.
	Services *[]string `json:"services,omitempty"`

	// Vlan VLAN ID.
	Vlan *int32 `json:"vlan,omitempty"`
}

// SubnetGetResponse defines model for SubnetGetResponse.
type SubnetGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of subnet objects.
	Items *[]Subnet `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SubnetResponse defines model for SubnetResponse.
type SubnetResponse struct {
	// Items A list of subnet objects.
	Items *[]Subnet `json:"items,omitempty"`
}

// Support defines model for Support.
type Support struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name             *string `json:"name,omitempty"`
	PhonehomeEnabled *bool   `json:"phonehome_enabled,omitempty"`
	Proxy            *string `json:"proxy,omitempty"`

	// RemoteAssistActive The switch to open all remote-assist sessions.
	RemoteAssistActive *bool `json:"remote_assist_active,omitempty"`

	// RemoteAssistDuration Specifies the duration of the remote-assist session in milliseconds.
	// This parameter should only be provided when establishing a new session.
	// It determines the length of time the session will remain active after it's initiated.
	RemoteAssistDuration *int64 `json:"remote_assist_duration,omitempty"`

	// RemoteAssistExpires The time when the session expires.
	RemoteAssistExpires *string `json:"remote_assist_expires,omitempty"`

	// RemoteAssistOpened The time when the session opened.
	RemoteAssistOpened *string                     `json:"remote_assist_opened,omitempty"`
	RemoteAssistPaths  *[]SupportRemoteAssistPaths `json:"remote_assist_paths,omitempty"`

	// RemoteAssistStatus The status of the remote-assist sessions.
	// Valid values are `connected`, `partially_connected`, `reconnecting`,
	// and `disconnected`.
	RemoteAssistStatus *string `json:"remote_assist_status,omitempty"`
}

// SupportDiagnostics defines model for SupportDiagnostics.
type SupportDiagnostics struct {
	// AnalysisPeriod A resource with a start time and end time.
	AnalysisPeriod *StartEndTime `json:"analysis_period,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The unique index of the task.
	Index *int64 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// SeverityCount List of severity counts.
	SeverityCount *[]SupportDiagnosticsSeverityCount `json:"severity_count,omitempty"`

	// StartTime Start time in milliseconds since the UNIX epoch.
	StartTime *int64 `json:"start_time,omitempty"`

	// Status Status of the diagnostics.
	// A status of `running` indicates that the diagnostics is still running.
	// A status of `completed` indicates that the diagnostics has completed.
	// A status of `failed` indicates that the diagnostics has failed.
	Status *string `json:"status,omitempty"`

	// TaskId A globally unique, system-generated ID. The ID cannot be modified.
	TaskId *string `json:"task_id,omitempty"`

	// Version Version of diagnostics tool.
	Version *string `json:"version,omitempty"`
}

// SupportDiagnosticsDetails defines model for SupportDiagnosticsDetails.
type SupportDiagnosticsDetails struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Index The unique index of the test. It will be of the format A.B
	// where A is the task index and B is the test index.
	Index *float32 `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// ResultDetails More details related to the test.
	// This field can provide remediation information as well.
	ResultDetails *string `json:"result_details,omitempty"`

	// Severity Severity level of the test.
	// Valid values include `info`, `warning`, `critical`.
	Severity *string `json:"severity,omitempty"`

	// TaskId The task ID of the diagnostics for which this refers to.
	TaskId *string `json:"task_id,omitempty"`

	// TestName Name of the test that was performed.
	TestName *string `json:"test_name,omitempty"`

	// TestType Category to which the test belongs to.
	TestType *string `json:"test_type,omitempty"`
}

// SupportDiagnosticsDetailsGetResponse defines model for SupportDiagnosticsDetailsGetResponse.
type SupportDiagnosticsDetailsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string                      `json:"continuation_token,omitempty"`
	Items             *[]SupportDiagnosticsDetails `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SupportDiagnosticsDetailsResponse defines model for SupportDiagnosticsDetailsResponse.
type SupportDiagnosticsDetailsResponse struct {
	Items *[]SupportDiagnosticsDetails `json:"items,omitempty"`
}

// SupportDiagnosticsGetResponse defines model for SupportDiagnosticsGetResponse.
type SupportDiagnosticsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string               `json:"continuation_token,omitempty"`
	Items             *[]SupportDiagnostics `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SupportDiagnosticsResponse defines model for SupportDiagnosticsResponse.
type SupportDiagnosticsResponse struct {
	Items *[]SupportDiagnostics `json:"items,omitempty"`
}

// SupportGetResponse defines model for SupportGetResponse.
type SupportGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string    `json:"continuation_token,omitempty"`
	Items             *[]Support `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SupportResponse defines model for SupportResponse.
type SupportResponse struct {
	Items *[]Support `json:"items,omitempty"`
}

// SyslogServer defines model for SyslogServer.
type SyslogServer struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Services Valid values are `data-audit` and `management`.
	// If not specified, defaults to `management`.
	Services *[]string `json:"services,omitempty"`

	// Uri The URI of the syslog server in the format PROTOCOL://HOSTNAME:PORT.
	Uri *string `json:"uri,omitempty"`
}

// SyslogServerContext defines model for SyslogServerContext.
type SyslogServerContext struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Services Valid values are `data-audit` and `management`.
	// If not specified, defaults to `management`.
	Services *[]string `json:"services,omitempty"`

	// Uri The URI of the syslog server in the format PROTOCOL://HOSTNAME:PORT.
	Uri *string `json:"uri,omitempty"`
}

// SyslogServerContextResponse defines model for SyslogServerContextResponse.
type SyslogServerContextResponse struct {
	Items *[]SyslogServerContext `json:"items,omitempty"`
}

// SyslogServerGetResponse defines model for SyslogServerGetResponse.
type SyslogServerGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
	Items  *[]SyslogServerContext        `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SyslogServerPatch defines model for SyslogServerPatch.
type SyslogServerPatch struct {
	// Services Valid values are `data-audit` and `management`.
	Services *[]string `json:"services,omitempty"`

	// Uri The URI of the syslog server in the format PROTOCOL://HOSTNAME:PORT.
	Uri *string `json:"uri,omitempty"`
}

// SyslogServerPost defines model for SyslogServerPost.
type SyslogServerPost struct {
	// Services Valid values are `data-audit` and `management`.
	// If not specified, defaults to `management`.
	Services *[]string `json:"services,omitempty"`

	// Uri The URI of the syslog server in the format PROTOCOL://HOSTNAME:PORT.
	Uri *string `json:"uri,omitempty"`
}

// SyslogServerPostOrPatch A syslog server
type SyslogServerPostOrPatch struct {
	// Uri The URI of the syslog server in the format PROTOCOL://HOSTNAME:PORT.
	Uri *string `json:"uri,omitempty"`
}

// SyslogServerResponse defines model for SyslogServerResponse.
type SyslogServerResponse struct {
	Items *[]SyslogServer `json:"items,omitempty"`
}

// SyslogServerSettings defines model for SyslogServerSettings.
type SyslogServerSettings struct {
	CaCertificate *struct {
		// Id A non-modifiable, globally unique ID chosen by the system.
		Id *string `json:"id,omitempty"`

		// Name A name chosen by the user. Can be changed. Must be locally unique.
		Name *string `json:"name,omitempty"`

		// ResourceType Type of the object (full name of the endpoint).
		// Valid values are the unique part of the resource's REST endpoint.
		// For example, a reference to a file system would have a
		// `resource_type` of `file-systems`.
		ResourceType *string `json:"resource_type,omitempty"`
	} `json:"ca_certificate,omitempty"`
	CaCertificateGroup *struct {
		// Id A non-modifiable, globally unique ID chosen by the system.
		Id *string `json:"id,omitempty"`

		// Name A name chosen by the user. Can be changed. Must be locally unique.
		Name *string `json:"name,omitempty"`

		// ResourceType Type of the object (full name of the endpoint).
		// Valid values are the unique part of the resource's REST endpoint.
		// For example, a reference to a file system would have a
		// `resource_type` of `file-systems`.
		ResourceType *string `json:"resource_type,omitempty"`
	} `json:"ca_certificate_group,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// SyslogServerSettingsGetResponse defines model for SyslogServerSettingsGetResponse.
type SyslogServerSettingsGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string                 `json:"continuation_token,omitempty"`
	Items             *[]SyslogServerSettings `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// SyslogServerSettingsResponse defines model for SyslogServerSettingsResponse.
type SyslogServerSettingsResponse struct {
	Items *[]SyslogServerSettings `json:"items,omitempty"`
}

// Target defines model for Target.
type Target struct {
	// Address IP address or FQDN of the target system.
	Address *string `json:"address,omitempty"`

	// CaCertificateGroup The group of CA certificates that can be used, in addition to
	// well-known Certificate Authority certificates, in order to
	// establish a secure connection to the target system.
	// Defaults to a reference to the `_default_replication_certs` group.
	CaCertificateGroup *FixedReference `json:"ca_certificate_group,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Status Status of the connection.
	// Valid values are `connected` and `connecting`.
	// `connected` - The connection is OK.
	// `connecting` - No connection exists and the array is trying to
	// reconnect to the target.
	Status *string `json:"status,omitempty"`

	// StatusDetails Additional information describing any issues encountered when
	// connecting, or `null` if the `status` is `connected`.
	StatusDetails *string `json:"status_details,omitempty"`
}

// TargetGetResponse defines model for TargetGetResponse.
type TargetGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of target objects.
	Items *[]TargetWithContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// TargetPost defines model for TargetPost.
type TargetPost struct {
	// Address IP address or FQDN of the target system.
	Address *string `json:"address,omitempty"`
}

// TargetResponse defines model for TargetResponse.
type TargetResponse struct {
	// Items A list of target objects.
	Items *[]Target `json:"items,omitempty"`
}

// TargetResponseContext defines model for TargetResponseContext.
type TargetResponseContext struct {
	// Items A list of target objects.
	Items *[]TargetWithContext `json:"items,omitempty"`
}

// TargetWithContext defines model for TargetWithContext.
type TargetWithContext struct {
	// Address IP address or FQDN of the target system.
	Address *string `json:"address,omitempty"`

	// CaCertificateGroup The group of CA certificates that can be used, in addition to
	// well-known Certificate Authority certificates, in order to
	// establish a secure connection to the target system.
	// Defaults to a reference to the `_default_replication_certs` group.
	CaCertificateGroup *FixedReference `json:"ca_certificate_group,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// Status Status of the connection.
	// Valid values are `connected` and `connecting`.
	// `connected` - The connection is OK.
	// `connecting` - No connection exists and the array is trying to
	// reconnect to the target.
	Status *string `json:"status,omitempty"`

	// StatusDetails Additional information describing any issues encountered when
	// connecting, or `null` if the `status` is `connected`.
	StatusDetails *string `json:"status_details,omitempty"`
}

// TestResult defines model for TestResult.
type TestResult struct {
	// ComponentAddress Address of the component running the test.
	ComponentAddress *string `json:"component_address,omitempty"`

	// ComponentName Name of the component running the test.
	ComponentName *string `json:"component_name,omitempty"`

	// Description What the test is doing.
	Description *string `json:"description,omitempty"`

	// Destination The URI of the target server being tested.
	Destination *string `json:"destination,omitempty"`

	// Enabled Is the service enabled or not?
	Enabled *bool `json:"enabled,omitempty"`

	// Resource A reference to the object being tested.
	Resource *FixedReference `json:"resource,omitempty"`

	// ResultDetails Additional information about the test result.
	ResultDetails *string `json:"result_details,omitempty"`

	// Success Returns a value of `true` if the specified test succeeded.
	// Returns a value of `false` if the specified test failed.
	Success *bool `json:"success,omitempty"`

	// TestType Displays the type of test being performed. The returned values are determined
	// by the `resource` being tested and its configuration.
	TestType *string `json:"test_type,omitempty"`
}

// TestResultGetResponse defines model for TestResultGetResponse.
type TestResultGetResponse struct {
	Items *[]TestResult `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// TestResultResponse defines model for TestResultResponse.
type TestResultResponse struct {
	Items *[]TestResult `json:"items,omitempty"`
}

// TlsPolicy defines model for TlsPolicy.
type TlsPolicy struct {
	// ApplianceCertificate A reference to a certificate that will be presented as the server certificate
	// in TLS negotiations with any clients that connect to appliance network addresses
	// to which this policy applies.
	ApplianceCertificate *ReferenceWritable `json:"appliance_certificate,omitempty"`

	// DisabledTlsCiphers If specified, disables the specific TLS ciphers. If all TLS ciphers
	// that are available for a specific TLS version on the system are disabled, then client
	// access over that TLS version is not possible. As such, disabled ciphers must still
	// result in at least one cipher being available for each enabled TLS version.
	// Changes to this setting can disrupt traffic for any clients relying on disabled
	// ciphers.
	DisabledTlsCiphers *[]string `json:"disabled_tls_ciphers,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// EnabledTlsCiphers If specified, enables only the specified TLS ciphers. If all TLS ciphers
	// that are available for a specific TLS version on the system are disabled, then client
	// access over that TLS version is not possible. As such, the enabled ciphers must always
	// contain at least one cipher for each enabled TLS version.
	// Changes to this setting can disrupt traffic for any clients relying on ciphers that
	// are removed. If set to `default`, then the enabled ciphers may be automatically adjusted
	// upon upgrade to newer software in order to align with the best known practices at the
	// time of software release.
	EnabledTlsCiphers *[]string `json:"enabled_tls_ciphers,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// MinTlsVersion The minimum TLS version that will be allowed for inbound connections on IPs to
	// which this policy applies. Changing this setting can disrupt connections for
	// any clients relying on older TLS versions that are disabled.
	// If set to `default`, then the lowest TLS version permitted may be automatically
	// raised upon upgrade to newer software in order to align with the best known
	// practices at the time of software release.
	// Configuring an explicit, low value can prevent upgrades to newer software
	// versions that no longer support older TLS versions.
	// Valid values include `default`, `TLSv1.1`, `TLSv1.0`, `TLSv1.2`,
	// and `TLSv1.3`.
	MinTlsVersion *string `json:"min_tls_version,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// TlsPolicyGetResponse defines model for TlsPolicyGetResponse.
type TlsPolicyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of TLS policy objects.
	Items *[]TlsPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// TlsPolicyPost defines model for TlsPolicyPost.
type TlsPolicyPost struct {
	// ApplianceCertificate A reference to a certificate that will be presented as the server certificate
	// in TLS negotiations with any clients that connect to appliance network addresses
	// to which this policy applies.
	ApplianceCertificate *ReferenceWritable `json:"appliance_certificate,omitempty"`

	// DisabledTlsCiphers If specified, disables the specific TLS ciphers. If all TLS ciphers
	// that are available for a specific TLS version on the system are disabled, then client
	// access over that TLS version is not possible. As such, disabled ciphers must still
	// result in at least one cipher being available for each enabled TLS version.
	// Changes to this setting can disrupt traffic for any clients relying on disabled
	// ciphers.
	DisabledTlsCiphers *[]string `json:"disabled_tls_ciphers,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// EnabledTlsCiphers If specified, enables only the specified TLS ciphers. If all TLS ciphers
	// that are available for a specific TLS version on the system are disabled, then client
	// access over that TLS version is not possible. As such, the enabled ciphers must always
	// contain at least one cipher for each enabled TLS version.
	// Changes to this setting can disrupt traffic for any clients relying on ciphers that
	// are removed. If set to `default`, then the enabled ciphers may be automatically adjusted
	// upon upgrade to newer software in order to align with the best known practices at the
	// time of software release.
	EnabledTlsCiphers *[]string `json:"enabled_tls_ciphers,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// MinTlsVersion The minimum TLS version that will be allowed for inbound connections on IPs to
	// which this policy applies. Changing this setting can disrupt connections for
	// any clients relying on older TLS versions that are disabled.
	// If set to `default`, then the lowest TLS version permitted may be automatically
	// raised upon upgrade to newer software in order to align with the best known
	// practices at the time of software release.
	// Configuring an explicit, low value can prevent upgrades to newer software
	// versions that no longer support older TLS versions.
	// Valid values include `default`, `TLSv1.1`, `TLSv1.0`, `TLSv1.2`,
	// and `TLSv1.3`.
	MinTlsVersion *string `json:"min_tls_version,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`
}

// TlsPolicyResponse defines model for TlsPolicyResponse.
type TlsPolicyResponse struct {
	// Items A list of TLS policy objects.
	Items *[]TlsPolicy `json:"items,omitempty"`
}

// TrustPolicyRule defines model for TrustPolicyRule.
type TrustPolicyRule struct {
	// Actions The list of role-assumption actions granted by this rule to the respective role.
	// Currently we support `sts:AssumeRoleWithSAML` and `sts:AssumeRoleWithWebIdentity` actions.
	Actions *[]string `json:"actions,omitempty"`

	// Conditions Conditions used to limit the scope which this rule applies to.
	Conditions *[]TrustPolicyRuleCondition `json:"conditions,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// Valid values include `allow`.
	Effect *string `json:"effect,omitempty"`

	// Index Index of the object in the containing array.
	Index *int `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Principals List of Identity Providers
	Principals *[]ReferenceWritable `json:"principals,omitempty"`
}

// TrustPolicyRulePost defines model for TrustPolicyRulePost.
type TrustPolicyRulePost struct {
	// Actions The list of role-assumption actions granted by this rule to the respective role.
	// Currently we support `sts:AssumeRoleWithSAML` and `sts:AssumeRoleWithWebIdentity` actions.
	Actions *[]string `json:"actions,omitempty"`

	// Conditions Conditions used to limit the scope which this rule applies to.
	Conditions *[]TrustPolicyRuleCondition `json:"conditions,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// Valid values include `allow`.
	Effect *string `json:"effect,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Principals List of Identity Providers
	Principals *[]ReferenceWritable `json:"principals,omitempty"`
}

// TrustPolicyRuleWithContext defines model for TrustPolicyRuleWithContext.
type TrustPolicyRuleWithContext struct {
	// Actions The list of role-assumption actions granted by this rule to the respective role.
	// Currently we support `sts:AssumeRoleWithSAML` and `sts:AssumeRoleWithWebIdentity` actions.
	Actions *[]string `json:"actions,omitempty"`

	// Conditions Conditions used to limit the scope which this rule applies to.
	Conditions *[]TrustPolicyRuleCondition `json:"conditions,omitempty"`

	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// Effect Effect of this rule.
	// When `allow`, the rule allows the given actions to be performed on the
	// given resources, subject to the given conditions.
	// Valid values include `allow`.
	Effect *string `json:"effect,omitempty"`

	// Index Index of the object in the containing array.
	Index *int `json:"index,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Policy The policy to which this rule belongs.
	Policy *FixedReference `json:"policy,omitempty"`

	// Principals List of Identity Providers
	Principals *[]ReferenceWritable `json:"principals,omitempty"`
}

// UserQuota defines model for UserQuota.
type UserQuota struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context    *Reference      `json:"context,omitempty"`
	FileSystem *FixedReference `json:"file_system,omitempty"`

	// FileSystemDefaultQuota File system's default user quota (in bytes). If it is `0`, it means there
	// is no default quota. This will be the effective user quota if the user
	// doesn't have an individual quota. This default quota is set through the
	// `file-systems` endpoint.
	FileSystemDefaultQuota *int64 `json:"file_system_default_quota,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Quota The limit of the quota (in bytes) for the specified user, cannot be `0`.
	// If specified, this value will override the file system's default user
	// quota.
	Quota *int64 `json:"quota,omitempty"`

	// Usage The usage of the file system (in bytes) by the specified user.
	Usage *int64 `json:"usage,omitempty"`

	// User The user on which this quota is enforced.
	User *User `json:"user,omitempty"`
}

// UserQuotaGetResponse defines model for UserQuotaGetResponse.
type UserQuotaGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of quota objects.
	Items *[]UserQuota `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// UserQuotaPatch defines model for UserQuotaPatch.
type UserQuotaPatch = UserQuotaPost

// UserQuotaPost defines model for UserQuotaPost.
type UserQuotaPost struct {
	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// Quota The limit of the quota (in bytes) for the specified user, cannot be `0`.
	// If specified, this value will override the file system's default user
	// quota.
	Quota int64 `json:"quota"`
}

// UserQuotaResponse defines model for UserQuotaResponse.
type UserQuotaResponse struct {
	// Items A list of quota objects.
	Items *[]UserQuota `json:"items,omitempty"`
}

// VerificationKey defines model for VerificationKey.
type VerificationKey struct {
	// KeyId The key id of the verification key.
	KeyId *int64 `json:"key_id,omitempty"`

	// Name Name of the verification key. Possible values include `access`.
	Name *string `json:"name,omitempty"`

	// VerificationKey The text of the verification key.
	VerificationKey *string `json:"verification_key,omitempty"`
}

// VerificationKeyGetResponse defines model for VerificationKeyGetResponse.
type VerificationKeyGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Items A list of verification key objects.
	Items *[]VerificationKey `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// VerificationKeyPatch defines model for VerificationKeyPatch.
type VerificationKeyPatch struct {
	// SignedVerificationKey The text of the signed verification key.
	SignedVerificationKey *string `json:"signed_verification_key,omitempty"`
}

// VerificationKeyResponse defines model for VerificationKeyResponse.
type VerificationKeyResponse struct {
	// Items A list of verification key objects.
	Items *[]VerificationKey `json:"items,omitempty"`
}

// WormDataPoliciesGetResponse defines model for WormDataPoliciesGetResponse.
type WormDataPoliciesGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of worm data policy objects.
	Items *[]WormDataPolicy `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// WormDataPoliciesMembersGetResponse defines model for WormDataPoliciesMembersGetResponse.
type WormDataPoliciesMembersGetResponse struct {
	// ContinuationToken Continuation token that can be provided in the `continuation_token` query
	// param to get the next page of data.
	// If you use the `continuation_token` to page through data you
	// are guaranteed to get all items exactly once regardless of
	// how items are modified. If an item is added or deleted during
	// the pagination then it may or may not be returned.
	// The `continuation_token` is generated if the `limit` is less
	// than the remaining number of items, and the default sort is used
	// (no sort is specified).
	ContinuationToken *string `json:"continuation_token,omitempty"`

	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`

	// Items A list of members for worm data policies.
	Items *[]PolicyMemberContext `json:"items,omitempty"`

	// TotalItemCount Total number of items after applying `filter` params.
	TotalItemCount *int32 `json:"total_item_count,omitempty"`
}

// WormDataPoliciesMembersResponse defines model for WormDataPoliciesMembersResponse.
type WormDataPoliciesMembersResponse struct {
	// Items A list of members for worm data policies.
	Items *[]PolicyMemberContext `json:"items,omitempty"`
}

// WormDataPoliciesResponse defines model for WormDataPoliciesResponse.
type WormDataPoliciesResponse struct {
	// Items A list of worm data policy objects.
	Items *[]WormDataPolicy `json:"items,omitempty"`
}

// WormDataPolicy defines model for WormDataPolicy.
type WormDataPolicy struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`

	// DefaultRetention Default retention period, in milliseconds. If the access time is not specified
	// when committing a file, then the default retention period is applied.
	DefaultRetention *int64 `json:"default_retention,omitempty"`

	// Enabled If `true`, the policy is enabled. If not specified, defaults to `true`.
	Enabled *bool `json:"enabled,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Whether the policy is defined on the local array.
	IsLocal *bool `json:"is_local,omitempty"`

	// Location Reference to the array where the policy is defined.
	Location *FixedReference `json:"location,omitempty"`

	// MaxRetention Maximum retention period, in milliseconds.
	MaxRetention *int64 `json:"max_retention,omitempty"`

	// MinRetention Minimum retention period, in milliseconds.
	MinRetention *int64 `json:"min_retention,omitempty"`

	// Mode The type of the retention lock. Valid values is `compliance`.
	Mode *string `json:"mode,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`

	// PolicyType Type of the policy. Valid values include `alert`, `audit`, `bucket-access`,
	// `cross-origin-resource-sharing`, `network-access`, `nfs`, `object-access`,
	// `smb-client`, `smb-share`, `snapshot`, `ssh-certificate-authority`,
	// and `worm-data`.
	PolicyType *string `json:"policy_type,omitempty"`

	// RetentionLock If set to `locked`, then the value of retention attributes or policy attributes are not
	// allowed to change.
	// If set to `unlocked`, then the value of the retention attributes and policy attributes
	// are allowed to change.
	// Valid values are `unlocked` and `locked`. It is always allowed to change from `unlocked` to
	// `locked`. Contact Pure Technical Services to change from `locked` to `unlocked`.
	RetentionLock *string `json:"retention_lock,omitempty"`
}

// ApiToken API token
type ApiToken struct {
	// CreatedAt Creation time in milliseconds since the UNIX epoch.
	CreatedAt *int64 `json:"created_at,omitempty"`

	// ExpiresAt Expiration time in milliseconds since the UNIX epoch.
	ExpiresAt *int64  `json:"expires_at,omitempty"`
	Token     *string `json:"token,omitempty"`
}

// ArrayEncryption defines model for _arrayEncryption.
type ArrayEncryption struct {
	DataAtRest *ArrayEncryptionDataAtRest `json:"data_at_rest,omitempty"`
}

// ArrayEncryptionDataAtRest Data at Rest Encryption properties.
type ArrayEncryptionDataAtRest struct {
	// Algorithms The algorithms used to encrypt data at rest on the array.
	Algorithms *[]string `json:"algorithms,omitempty"`

	// Enabled Returns a value of `true` if Data at Rest Encryption is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// EntropySource The entropy source used to generate the Data at Rest Encryption key on the array.
	EntropySource *string `json:"entropy_source,omitempty"`
}

// ArrayEradicationConfig defines model for _arrayEradicationConfig.
type ArrayEradicationConfig struct {
	// EradicationDelay The file eradication delay is in milliseconds.
	// Automatically eradicate destroyed filesystems and snapshots after the delay time.
	// Valid values are `86400000` and any multiple of `86400000`
	// in the range of `86400000` and `2592000000`.
	// Any other values will be rounded down to the
	// nearest multiple of `86400000`.
	EradicationDelay *int64 `json:"eradication_delay,omitempty"`

	// ManualEradication Manual eradication status is applied on the array level.
	// If status is all-disabled, you cannot eradicate buckets and file systems.
	// If status is file-disabled then you can not eradicate files systems.
	// If status is object-disabled then you can not eradicate buckets.
	// If status is all-enabled then you can eradicate file systems and buckets.
	// Values include `all-enabled`, `file-disabled`,
	// `object-disabled`, and `all-disabled`.
	ManualEradication *string `json:"manual_eradication,omitempty"`
}

// BucketDefaults defines model for _bucketDefaults.
type BucketDefaults struct {
	// HardLimitEnabled The value of this field will be used to configure the `hard_limit_enabled`
	// field of newly created buckets associated with this object store account,
	// if the bucket creation does not specify its own value. If not specified,
	// defaults to `false`.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// QuotaLimit The value of this field will be used to configure the `quota_limit` field
	// of newly created buckets associated with this object store account, if the
	// bucket creation does not specify its own value. If set to an empty string
	// (`""`), the bucket default is unlimited in size. If not specified,
	// defaults to unlimited.
	QuotaLimit *string `json:"quota_limit,omitempty"`
}

// BucketDefaultsReadonly defines model for _bucketDefaultsReadonly.
type BucketDefaultsReadonly struct {
	// HardLimitEnabled The value of this field will be used to configure the `hard_limit_enabled`
	// field of newly created buckets associated with this object store account,
	// if the bucket creation does not specify its own value. If not specified,
	// defaults to `false`.
	HardLimitEnabled *bool `json:"hard_limit_enabled,omitempty"`

	// QuotaLimit The value of this field will be used to configure the `quota_limit` field
	// of newly created buckets associated with this object store account, if the
	// bucket creation does not specify its own value. If unset, the bucket
	// default is unlimited in size.
	QuotaLimit *int `json:"quota_limit,omitempty"`
}

// BucketEradicationConfig Configuration settings related to bucket eradication.
type BucketEradicationConfig struct {
	// EradicationDelay Minimum eradication delay in milliseconds. Automatically eradicate destroyed
	// buckets after the delay time passes unless automatic eradication
	// is delayed due to other configuration values.
	EradicationDelay *int64 `json:"eradication_delay,omitempty"`

	// EradicationMode The eradication mode of the bucket.
	// If it's `permission-based` the bucket can be eradicated based
	// on user permissions.
	// If it's `retention-based` the bucket can never be eradicated as long
	// as there are locked objects still being retained.
	// Valid values are `permission-based` and `retention-based`.
	EradicationMode *string `json:"eradication_mode,omitempty"`

	// ManualEradication The manual eradication status of the bucket.
	// If `disabled`, the bucket cannot be eradicated after it has been
	// destroyed, unless it is empty.
	// If `enabled`, the bucket can be eradicated.
	// Valid values are `disabled` and `enabled`.
	ManualEradication *string `json:"manual_eradication,omitempty"`
}

// BuiltIn defines model for _builtIn.
type BuiltIn struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// BuiltInNoId defines model for _builtInNoId.
type BuiltInNoId struct {
	// Name Name of the object (e.g., a file system or snapshot).
	Name *string `json:"name,omitempty"`
}

// BuiltInRelationship defines model for _builtInRelationship.
type BuiltInRelationship struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`
}

// Context defines model for _context.
type Context struct {
	// Context The context in which the operation was performed.
	// Valid values include a reference to any array which is a member of the same fleet.
	// If the array is not a member of a fleet, `context` will always implicitly be set
	// to the array that received the request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	Context *Reference `json:"context,omitempty"`
}

// ContinuousReplicationPerformance defines model for _continuousReplicationPerformance.
type ContinuousReplicationPerformance struct {
	// ObjectBacklog The total number of pending object operations
	// and their size that are currently in the backlog.
	ObjectBacklog *ObjectBacklog `json:"object_backlog,omitempty"`

	// ReceivedBytesPerSec Total bytes received per second.
	ReceivedBytesPerSec *float64 `json:"received_bytes_per_sec,omitempty"`

	// TransmittedBytesPerSec Total bytes transmitted per second.
	TransmittedBytesPerSec *float64 `json:"transmitted_bytes_per_sec,omitempty"`
}

// Direction The direction of replication. Valid values are `inbound` and
// `outbound`.
type Direction = string

// DirectoryServiceManagement Properties specific to the management service.
type DirectoryServiceManagement struct {
	// UserLoginAttribute User login attribute in the structure of the configured LDAP servers.
	// Typically the attribute field that holds the user's unique login name.
	// Default value is `sAMAccountName` for Active Directory or `uid` for all other
	// directory services.
	UserLoginAttribute *string `json:"user_login_attribute,omitempty"`

	// UserObjectClass Value of the object class for a management LDAP user.
	// Defaults to `User` for Active Directory servers, `posixAccount` or `shadowAccount` for
	// OpenLDAP servers dependent on the group type of the server, or `person` for all other
	// directory servers.
	UserObjectClass *string `json:"user_object_class,omitempty"`
}

// DirectoryServiceNfs Properties specific to the NFS service.
type DirectoryServiceNfs struct {
	// NisDomains NIS domains to search.
	NisDomains *[]string `json:"nis_domains,omitempty"`

	// NisServers A list of the IP addresses or hostnames of NIS servers to search.
	NisServers *[]string `json:"nis_servers,omitempty"`
}

// DirectoryServiceSmb DEPRECATED - Properties specific to the SMB service.
type DirectoryServiceSmb struct {
	// JoinOu Optional organizational unit where the machine account for the directory service will be created.
	JoinOu *string `json:"join_ou,omitempty"`
}

// ErrorContextResponse defines model for _errorContextResponse.
type ErrorContextResponse struct {
	// Errors The list of errors encountered when attempting to perform an operation.
	Errors *[]ErrorContextResponseErrors `json:"errors,omitempty"`
}

// ErrorContextResponseErrors defines model for _errorContextResponseErrors.
type ErrorContextResponseErrors struct {
	// Context Contains information relating to the cause of this error,
	// or the name of the object that was being processed when the error was encountered.
	// This may be `null` for more general errors.
	Context *string `json:"context,omitempty"`

	// LocationContext Contains information relating to the context in which the request was executing
	// when the error occurred.
	// For example, this may be the name of an array in the same fleet.
	// This may be `null` for more general errors, or if no explicit `context` parameter
	// was provided with the request.
	LocationContext *FixedReferenceWithType `json:"location_context,omitempty"`

	// Message A description of the error which occurred.
	Message *string `json:"message,omitempty"`
}

// EulaSignature defines model for _eula_signature.
type EulaSignature struct {
	// Accepted Accepted time in milliseconds since the UNIX epoch.
	Accepted *int64 `json:"accepted,omitempty"`

	// Company The company of the person who accepted the End User Agreement.
	// This field is deprecated and the response will be `null`. Modification to this field
	// will be ignored.
	Company *string `json:"company,omitempty"`

	// Name The name of the person who accepted the End User Agreement.
	// This field is deprecated and the response will be `null`. Modification to this field
	// will be ignored.
	Name *string `json:"name,omitempty"`

	// Title The title of the person who accepted the End User Agreement.
	// This field is deprecated and the response will be `null`. Modification to this field
	// will be ignored.
	Title *string `json:"title,omitempty"`
}

// FileLockRange The range in bytes (`offset`, `length`) the lock covers within a file.
// If the lock reaches the end of the file, the `length` will be `null`.
// If the lock is set for the entire file, both `offset` and `length`
// will be `null`.
type FileLockRange struct {
	Length *int `json:"length,omitempty"`
	Offset *int `json:"offset,omitempty"`
}

// FileSystemEradicationConfig Configuration settings related to file system eradication.
type FileSystemEradicationConfig struct {
	// EradicationMode The eradication mode of the file system.
	// If it's `permission-based` the file system can be eradicated based
	// on user permissions.
	// If it's `retention-based` the file system can not be eradicated
	// until no files/inodes are locked or retained.
	// Valid values are `permission-based` and `retention-based`.
	EradicationMode *string `json:"eradication_mode,omitempty"`

	// ManualEradication The manual eradication status of the file system.
	// If `disabled`, the file system cannot be eradicated after it has been
	// destroyed, unless it is empty.
	// If `enabled`, the file system can be eradicated.
	// Valid values are `disabled` and `enabled`.
	ManualEradication *string `json:"manual_eradication,omitempty"`
}

// FixedLocationReference defines model for _fixedLocationReference.
type FixedLocationReference struct {
	// DisplayName Full name of the source with remote array information.
	// Response will be same as source name for local file systems and policies.
	DisplayName *string `json:"display_name,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Is the location reference to the local array or somewhere remote?
	IsLocal *bool `json:"is_local,omitempty"`

	// Location A reference to the location where the object is defined.
	Location *FixedReference `json:"location,omitempty"`
	Name     *string         `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// FixedReference defines model for _fixedReference.
type FixedReference struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// FixedReferenceNameOnly defines model for _fixedReferenceNameOnly.
type FixedReferenceNameOnly struct {
	Name *string `json:"name,omitempty"`
}

// FixedReferenceNoId defines model for _fixedReferenceNoId.
type FixedReferenceNoId struct {
	Name *string `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// FixedReferenceNoResourceType defines model for _fixedReferenceNoResourceType.
type FixedReferenceNoResourceType struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// FixedReferenceWithIsLocal defines model for _fixedReferenceWithIsLocal.
type FixedReferenceWithIsLocal struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal If set to `true`, the location reference is to the local array.
	// If set to `false`, the location reference is to a remote location,
	// such as a remote array or offload target.
	IsLocal *bool   `json:"is_local,omitempty"`
	Name    *string `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// FixedReferenceWithRemote defines model for _fixedReferenceWithRemote.
type FixedReferenceWithRemote struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// Remote The remote field of the corresponding array connection.
	Remote *FixedReferenceNoResourceType `json:"remote,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// FixedReferenceWithType defines model for _fixedReferenceWithType.
type FixedReferenceWithType struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	//   Valid values are the unique part of the resource's REST endpoint.
	//   For example, a reference to a fleet would have a
	//   `resource_type` of `fleets`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// FleetMemberPostMembers defines model for _fleetMemberPostMembers.
type FleetMemberPostMembers struct {
	// Key Provide the `fleet key` generated from any array in the fleet.
	Key    *string                       `json:"key,omitempty"`
	Member *FleetMemberPostMembersMember `json:"member,omitempty"`
}

// FleetMemberPostMembersMember defines model for _fleetMemberPostMembersMember.
type FleetMemberPostMembersMember struct {
	// Id A globally unique, system-generated ID.
	// The ID cannot be modified.
	Id *string `json:"id,omitempty"`

	// Name The resource name.
	Name *string `json:"name,omitempty"`

	// ResourceType Type of the object (e.g. remote-arrays)
	ResourceType *string `json:"resource_type,omitempty"`
}

// Group defines model for _group.
type Group struct {
	// Id The numeric group id that represents the group's identity in a POSIX system.
	Id *int64 `json:"id,omitempty"`

	// Name The group name that represents the group's identity, and which resolves to the group's id
	// in a configured directory service.
	Name *string `json:"name,omitempty"`
}

// Http defines model for _http.
type Http struct {
	// Enabled Is the protocol enabled? If not specified, defaults to `false`.
	Enabled *bool `json:"enabled,omitempty"`
}

// Index defines model for _index.
type Index struct {
	// Index Index of the object in the containing array.
	Index *int `json:"index,omitempty"`
}

// LifecycleRuleConfigExtension defines model for _lifecycleRuleConfigExtension.
type LifecycleRuleConfigExtension struct {
	// AbortIncompleteMultipartUploadsAfter Duration of time after which incomplete multipart uploads will be aborted.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	AbortIncompleteMultipartUploadsAfter *int64 `json:"abort_incomplete_multipart_uploads_after,omitempty"`

	// KeepCurrentVersionFor Time after which current versions will be marked expired.
	// Measured in milliseconds.
	// Must be a multiple of 86400000 to represent a whole number of days.
	KeepCurrentVersionFor *int64 `json:"keep_current_version_for,omitempty"`

	// KeepCurrentVersionUntil Time after which current versions will be marked expired.
	// Measured in milliseconds, time since epoch.
	// Must be a valid date, accurate to day.
	KeepCurrentVersionUntil *int64 `json:"keep_current_version_until,omitempty"`
}

// LocationReference defines model for _locationReference.
type LocationReference struct {
	// DisplayName Full name of the source with remote array information.
	// Response will be same as source name for local file systems and policies.
	DisplayName *string `json:"display_name,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// IsLocal Is the location reference to the local array or somewhere remote?
	IsLocal *bool `json:"is_local,omitempty"`

	// Location A reference to the location where the object is defined.
	Location *Reference `json:"location,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// MemberLink defines model for _memberLink.
type MemberLink struct {
	// LocalFileSystem Reference to a local file system.
	LocalFileSystem *FixedReference `json:"local_file_system,omitempty"`

	// Remote Reference to a remote array.
	Remote *FixedReferenceNoResourceType `json:"remote,omitempty"`

	// RemoteFileSystem Reference to a remote file system.
	RemoteFileSystem *FixedReferenceNoResourceType `json:"remote_file_system,omitempty"`
}

// MultiProtocol defines model for _multiProtocol.
type MultiProtocol struct {
	// AccessControlStyle The access control style that is utilized for client actions such as
	// setting file and directory ACLs.
	// Possible values include `nfs`, `smb`, `shared`, `independent`, and `mode-bits`.
	// If `nfs` is specified, then SMB clients will be unable to set permissions
	// on files and directories.
	// If `smb` is specified, then NFS clients will be unable to set permissions
	// on files and directories.
	// If `shared` is specified, then NFS and SMB clients will both be able
	// to set permissions on files and directories. Any client will be able to
	// overwrite the permissions set by another client, regardless of protocol.
	// If `independent` is specified, then NFS and SMB clients will both be able
	// to set permissions on files and directories, and can access files and
	// directories created over any protocol. Permissions set by SMB clients
	// will not affect NFS clients and vice versa. NFS clients will be restricted
	// to only using mode bits to set permissions.
	// If `mode-bits` is specified, then NFS and SMB clients will both be able
	// to set permissions on files and directories, but only mode bits may be
	// used to set permissions for NFS clients. When SMB clients set an ACL,
	// it will be converted to have the same permission granularity as NFS mode
	// bits.
	AccessControlStyle *string `json:"access_control_style,omitempty"`

	// SafeguardAcls If set to `true`, prevents NFS clients from erasing a configured ACL when
	// setting NFS mode bits.
	// If this is `true`, then attempts to set mode bits on a file or directory
	// will fail if they cannot be combined with the existing ACL set on a file
	// or directory without erasing the ACL.
	// Attempts to set mode bits that would not erase an existing ACL will still
	// succeed and the mode bit changes will be merged with the existing ACL.
	// This must be `false` when `access_control_style` is set to either
	// `independent` or `mode-bits`.
	SafeguardAcls *bool `json:"safeguard_acls,omitempty"`
}

// MultiProtocolPost defines model for _multiProtocolPost.
type MultiProtocolPost struct {
	// AccessControlStyle The access control style that is utilized for client actions such as
	// setting file and directory ACLs.
	// Possible values include `nfs`, `smb`, `shared`, `independent`, and `mode-bits`.
	// If `nfs` is specified, then SMB clients will be unable to set permissions
	// on files and directories.
	// If `smb` is specified, then NFS clients will be unable to set permissions
	// on files and directories.
	// If `shared` is specified, then NFS and SMB clients will both be able
	// to set permissions on files and directories. Any client will be able to
	// overwrite the permissions set by another client, regardless of protocol.
	// If `independent` is specified, then NFS and SMB clients will both be able
	// to set permissions on files and directories, and can access files and
	// directories created over any protocol. Permissions set by SMB clients
	// will not affect NFS clients and vice versa. NFS clients will be restricted
	// to only using mode bits to set permissions.
	// If `mode-bits` is specified, then NFS and SMB clients will both be able
	// to set permissions on files and directories, but only mode bits may be
	// used to set permissions for NFS clients. When SMB clients set an ACL,
	// it will be converted to have the same permission granularity as NFS mode
	// bits.
	// Defaults to `shared`.
	AccessControlStyle *string `json:"access_control_style,omitempty"`

	// SafeguardAcls If set to `true`, prevents NFS clients from erasing a configured ACL when
	// setting NFS mode bits.
	// If this is `true`, then attempts to set mode bits on a file or directory
	// will fail if they cannot be combined with the existing ACL set on a file
	// or directory without erasing the ACL.
	// Attempts to set mode bits that would not erase an existing ACL will still
	// succeed and the mode bit changes will be merged with the existing ACL.
	// This must be `false` when `access_control_style` is set to either
	// `independent` or `mode-bits`.
	// Defaults to `true`.
	SafeguardAcls *bool `json:"safeguard_acls,omitempty"`
}

// Nfs defines model for _nfs.
type Nfs struct {
	// ExportPolicy Deprecated. See File System Exports for newer functionality.
	// The value returned will be the `policy` of the File System
	// Export for the default server, and NFS, with the `export_name`
	// matching the file system name, if there is one and null otherwise.
	// Modifying this field will still work.
	// If the current value is null, then setting this field will attempt
	// to create a File System Export with the policy
	// and other default values. The `export_name` will be the same as the
	// file system's `name`.
	// If the current value is not null, then setting this field will change
	// the policy in the matching File System Export.
	// Either the `export_policy` or `rules` will control the
	// NFS export functionality for the file system.
	// If this is set, then the `rules` field will be cleared.
	// Both `export_policy` and `rules` can not be set in the same request.
	ExportPolicy *ReferenceWritable `json:"export_policy,omitempty"`

	// Rules Deprecated. See File System Exports and NFS Export Policies for newer functionality.
	// Modifying this field will still work, causing the matching
	// File System Export to be deleted, if there is one. See `export_policy`.
	// Both `export_policy` and `rules` can not be set in the same request.
	// Rules can be applied to an individual
	// client or a range of clients specified by IP address (`ip_address(options)`),
	// netmask (`ip_address/length(options)`), netgroup (`@groupname(options)`),
	// hostname (`hostname(options)`) (see RFC-1123 part 2.1), fully qualified domain name
	// (`host.exampledomain.com(options)`) (see RFC-1123 part 2.1, RFC 2181 part 11), or wildcards
	// with fully qualified domain name or hostname (`*.exampledomain?.com(options)`).
	// Possible export options include `rw`, `ro`, `fileid_32bit`,  `no_fileid_32bit`,
	// `anonuid`, `anongid`, `root_squash`, `no_root_squash`, `all_squash`,
	// `no_all_squash`,  `secure`, `insecure`, `atime`, `noatime`, and `sec`.
	// If not specified, defaults to `*(rw,no_root_squash)`.
	Rules *string `json:"rules,omitempty"`

	// V3Enabled If set to `true`, the NFSv3 protocol will be enabled.
	V3Enabled *bool `json:"v3_enabled,omitempty"`

	// V41Enabled If set to `true`, the NFSv4.1 protocol will be enabled.
	V41Enabled *bool `json:"v4_1_enabled,omitempty"`
}

// NfsPatch defines model for _nfsPatch.
type NfsPatch struct {
	// AddRules The rules which will be added to the existing NFS export rules for the
	// file system. If `export_policy` is in use and and this field is set, the operation
	// will fail.
	AddRules *string `json:"add_rules,omitempty"`

	// After The `after` field can be used with `add_rules` or `remove_rules` or both.
	// If used with `add_rules`, then the `add_rules` string will be inserted after
	// the first occurrence of the `after` string.
	// If used with `remove_rules`, then remove the first occurrence of `remove_rules`
	// after the first occurrence of the `after` string. The `remove_rules` will be
	// processed before the `add_rules`.
	After *string `json:"after,omitempty"`

	// ExportPolicy Deprecated. See File System Exports for newer functionality.
	// The value returned will be the `policy` of the File System
	// Export for the default server, and NFS, with the `export_name`
	// matching the file system name, if there is one and null otherwise.
	// Modifying this field will still work.
	// If the current value is null, then setting this field will attempt
	// to create a File System Export with the policy
	// and other default values. The `export_name` will be the same as the
	// file system's `name`.
	// If the current value is not null, then setting this field will change
	// the policy in the matching File System Export.
	// Either the `export_policy` or `rules` will control the
	// NFS export functionality for the file system.
	// If this is set, then the `rules` field will be cleared.
	// Both `export_policy` and `rules` can not be set in the same request.
	ExportPolicy *ReferenceWritable `json:"export_policy,omitempty"`

	// RemoveRules The rules which will be removed from the existing NFS export rules for the
	// file system. Only the first occurrence of the `remove_rules` will be removed.
	// If `export_policy` is in use and and this field is set, the operation will fail.
	RemoveRules *string `json:"remove_rules,omitempty"`

	// Rules Deprecated. See File System Exports and NFS Export Policies for newer functionality.
	// Modifying this field will still work, causing the matching
	// File System Export to be deleted, if there is one. See `export_policy`.
	// Both `export_policy` and `rules` can not be set in the same request.
	// Rules can be applied to an individual
	// client or a range of clients specified by IP address (`ip_address(options)`),
	// netmask (`ip_address/length(options)`), netgroup (`@groupname(options)`),
	// hostname (`hostname(options)`) (see RFC-1123 part 2.1), fully qualified domain name
	// (`host.exampledomain.com(options)`) (see RFC-1123 part 2.1, RFC 2181 part 11), or wildcards
	// with fully qualified domain name or hostname (`*.exampledomain?.com(options)`).
	// Possible export options include `rw`, `ro`, `fileid_32bit`,  `no_fileid_32bit`,
	// `anonuid`, `anongid`, `root_squash`, `no_root_squash`, `all_squash`,
	// `no_all_squash`,  `secure`, `insecure`, `atime`, `noatime`, and `sec`.
	// If not specified, defaults to `*(rw,no_root_squash)`.
	Rules *string `json:"rules,omitempty"`

	// V3Enabled If set to `true`, the NFSv3 protocol will be enabled.
	V3Enabled *bool `json:"v3_enabled,omitempty"`

	// V41Enabled If set to `true`, the NFSv4.1 protocol will be enabled.
	V41Enabled *bool `json:"v4_1_enabled,omitempty"`
}

// ObjectBacklog defines model for _objectBacklog.
type ObjectBacklog struct {
	// BytesCount The size of the objects in bytes that need to be replicated.
	// This does not include the size of custom metadata.
	BytesCount *int64 `json:"bytes_count,omitempty"`

	// DeleteOpsCount The number of DELETE operations that need to be replicated.
	DeleteOpsCount *int64 `json:"delete_ops_count,omitempty"`

	// OtherOpsCount The number of other operations that need to be replicated.
	OtherOpsCount *int64 `json:"other_ops_count,omitempty"`

	// PutOpsCount The number of PUT operations that need to be replicated.
	PutOpsCount *int64 `json:"put_ops_count,omitempty"`
}

// ObjectLockConfigBase Configuration settings related to object lock.
type ObjectLockConfigBase struct {
	// DefaultRetentionMode The retention mode used to apply locks on new objects if
	// none is specified by the S3 client.
	// Valid values include `compliance` and `governance`.
	// If there is no default, this value is `null`.
	// Use "" to clear.
	DefaultRetentionMode *string `json:"default_retention_mode,omitempty"`

	// Enabled If set to `true`, then S3 APIs relating to object lock
	// may be used.
	Enabled *bool `json:"enabled,omitempty"`

	// FreezeLockedObjects If set to `true`, a locked object will be read-only and no
	// new versions of the object may be created due to modifications.
	// If not specified, defaults to `false`.
	FreezeLockedObjects *bool `json:"freeze_locked_objects,omitempty"`
}

// ObjectLockConfigRequestBody defines model for _objectLockConfigRequestBody.
type ObjectLockConfigRequestBody struct {
	// DefaultRetention The retention period, in milliseconds, used to apply locks
	// on new objects if none is specified by the S3 client.
	// Valid values are any multiple of `86400000` (1 day), up to
	// `3153600000000` (36500 days).
	// If there is no default, this value is `null`.
	// Use "" to clear.
	DefaultRetention *string `json:"default_retention,omitempty"`

	// DefaultRetentionMode The retention mode used to apply locks on new objects if
	// none is specified by the S3 client.
	// Valid values include `compliance` and `governance`.
	// If there is no default, this value is `null`.
	// Use "" to clear.
	DefaultRetentionMode *string `json:"default_retention_mode,omitempty"`

	// Enabled If set to `true`, then S3 APIs relating to object lock
	// may be used.
	Enabled *bool `json:"enabled,omitempty"`

	// FreezeLockedObjects If set to `true`, a locked object will be read-only and no
	// new versions of the object may be created due to modifications.
	// If not specified, defaults to `false`.
	FreezeLockedObjects *bool `json:"freeze_locked_objects,omitempty"`
}

// ObjectLockConfigResponse defines model for _objectLockConfigResponse.
type ObjectLockConfigResponse struct {
	// DefaultRetention The retention period, in milliseconds, used to apply locks
	// on new objects if none is specified by the S3 client.
	// Valid values are any multiple of `86400000` (1 day), up to
	// `3153600000000` (36500 days).
	// If there is no default, this value is `null`.
	DefaultRetention *int64 `json:"default_retention,omitempty"`

	// DefaultRetentionMode The retention mode used to apply locks on new objects if
	// none is specified by the S3 client.
	// Valid values include `compliance` and `governance`.
	// If there is no default, this value is `null`.
	// Use "" to clear.
	DefaultRetentionMode *string `json:"default_retention_mode,omitempty"`

	// Enabled If set to `true`, then S3 APIs relating to object lock
	// may be used.
	Enabled *bool `json:"enabled,omitempty"`

	// FreezeLockedObjects If set to `true`, a locked object will be read-only and no
	// new versions of the object may be created due to modifications.
	// If not specified, defaults to `false`.
	FreezeLockedObjects *bool `json:"freeze_locked_objects,omitempty"`
}

// OidcSsoPostIdp Identity Provider
type OidcSsoPostIdp struct {
	// ProviderUrl URL of the Identity Provider server
	ProviderUrl *string `json:"provider_url,omitempty"`

	// ProviderUrlCaCertificate CA certificate used to validate the authenticity of the configured
	// Identity Provider server.
	ProviderUrlCaCertificate *Reference `json:"provider_url_ca_certificate,omitempty"`

	// ProviderUrlCaCertificateGroup A certificate group containing CA certificates that can be used to
	// validate the authenticity of the configured Identity Provider server.
	ProviderUrlCaCertificateGroup *Reference `json:"provider_url_ca_certificate_group,omitempty"`
}

// Permission defines model for _permission.
type Permission struct {
	// Action The `action` that the user can perform on the `resource_type`.
	// Typical values include `get`, `patch`, `post`, and `delete`.
	// Values can also be finer grained.
	Action *string `json:"action,omitempty"`

	// ResourceType The `resource_type` that this `permission` affects.
	ResourceType *string `json:"resource_type,omitempty"`
}

// PolicyRuleIndex defines model for _policyRuleIndex.
type PolicyRuleIndex struct {
	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	// NOTE: It is recommended to use the query param `before_rule_id` to do reordering to
	// avoid concurrency issues, but changing `index` is also supported. `index` can not be
	// changed if `before_rule_id` or `before_rule_name` are specified.
	Index *int32 `json:"index,omitempty"`
}

// PolicyRuleIndexInPolicy defines model for _policyRuleIndexInPolicy.
type PolicyRuleIndexInPolicy struct {
	// Index The index within the policy. The `index` indicates the order the rules are evaluated.
	Index *int32 `json:"index,omitempty"`
}

// PolicyRuleObjectAccessCondition defines model for _policyRuleObjectAccessCondition.
type PolicyRuleObjectAccessCondition struct {
	// S3Delimiters If specified, groups result objects by the specified delimiter. Only
	// top-level groupings will be returned.
	// Can be used with the `s3:ListBucket` and `s3:ListBucketVersions` actions.
	S3Delimiters *[]string `json:"s3_delimiters,omitempty"`

	// S3Prefixes If specified, restricts access and results based on the prefix of the
	// relevant objects.
	// Can be used with the `s3:ListBucket` and `s3:ListBucketVersions` actions.
	S3Prefixes *[]string `json:"s3_prefixes,omitempty"`

	// SourceIps If specified, the rule will apply only to requests matching at least one
	// provided IP address or subnet.
	// Each entry must be in standard CIDR format (including an IP address
	// without an associated routing prefix).
	// Can be used with any action.
	SourceIps *[]string `json:"source_ips,omitempty"`
}

// PolicyRule Rule
type PolicyRule struct {
	// At Time during the day to take the snapshot (using array time zone),
	// only valid if 'every' is in days.
	At *int64 `json:"at,omitempty"`

	// Every How often to take snapshots.
	Every *int64 `json:"every,omitempty"`

	// KeepFor The time to keep the snapshots for.
	KeepFor *int64 `json:"keep_for,omitempty"`

	// TimeZone The time zone to use with the `at` time.
	TimeZone *string `json:"time_zone,omitempty"`
}

// PublicAccessConfig Configuration settings related to public access.
type PublicAccessConfig struct {
	// BlockNewPublicPolicies If set to `true`, adding bucket policies that grant public access to a bucket is not allowed.
	BlockNewPublicPolicies *bool `json:"block_new_public_policies,omitempty"`

	// BlockPublicAccess If set to `true`, access to a bucket with a public policy is restricted to only authenticated
	// users within the account that bucket belongs to.
	BlockPublicAccess *bool `json:"block_public_access,omitempty"`
}

// Reference An ordinary (as opposed to built-in) resource that can be created, named,
// renamed or deleted by the user. This might be a virtual resource (e.g., a
// volume), or correspond to something in the environment, like a host or a
// server.
type Reference struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// ReferenceNameOnly defines model for _referenceNameOnly.
type ReferenceNameOnly struct {
	Name *string `json:"name,omitempty"`
}

// ReferenceWritable An ordinary (as opposed to built-in) resource that can be created, named,
// renamed or deleted by the user. This might be a virtual resource (e.g., a
// volume), or correspond to something in the environment, like a host or a
// server.
type ReferenceWritable struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`

	// ResourceType Type of the object (full name of the endpoint).
	// Valid values are the unique part of the resource's REST endpoint.
	// For example, a reference to a file system would have a
	// `resource_type` of `file-systems`.
	ResourceType *string `json:"resource_type,omitempty"`
}

// ReplicaLinkBuiltIn defines model for _replicaLinkBuiltIn.
type ReplicaLinkBuiltIn struct {
	// Direction The direction of replication. Valid values are `inbound` and
	// `outbound`.
	Direction *Direction `json:"direction,omitempty"`

	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Lag Duration in milliseconds that represents how far
	// behind the replication target is from the source.
	// This is the time difference between current time and `recovery_point`.
	Lag *int64 `json:"lag,omitempty"`

	// StatusDetails Detailed information about the status of the replica link when it is
	// unhealthy.
	StatusDetails *string `json:"status_details,omitempty"`
}

// ReplicationPerformance defines model for _replication_performance.
type ReplicationPerformance struct {
	// ReceivedBytesPerSec Total bytes received per second.
	ReceivedBytesPerSec *float64 `json:"received_bytes_per_sec,omitempty"`

	// TransmittedBytesPerSec Total bytes transmitted per second.
	TransmittedBytesPerSec *float64 `json:"transmitted_bytes_per_sec,omitempty"`
}

// Resource An ordinary (as opposed to built-in) resource that can be created, named,
// renamed or deleted by the user. This might be a virtual resource (e.g., a
// file system), or correspond to something in the environment,
// like a network interface.
type Resource struct {
	// Id A non-modifiable, globally unique ID chosen by the system.
	Id *string `json:"id,omitempty"`

	// Name A name chosen by the user. Can be changed. Must be locally unique.
	Name *string `json:"name,omitempty"`
}

// ResourceFixedNonUniqueName A resource with a non-unique name.
type ResourceFixedNonUniqueName struct {
	// Id A globally unique, system-generated ID. The ID cannot be modified.
	Id *string `json:"id,omitempty"`

	// Name Name of the resource. The name cannot be modified.
	Name *string `json:"name,omitempty"`
}

// Saml2SsoIdp Properties specific to the identity provider.
type Saml2SsoIdp struct {
	// EncryptAssertionEnabled If set to `true`, SAML assertions will be encrypted by the identity provider.
	EncryptAssertionEnabled *bool `json:"encrypt_assertion_enabled,omitempty"`

	// EntityId A globally unique name for the identity provider.
	EntityId *string `json:"entity_id,omitempty"`

	// MetadataUrl The URL of the identity provider metadata.
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// MetadataUrlCaCertificate CA certificate used to validate the authenticity of the configured
	// Identity Provider server.
	MetadataUrlCaCertificate *ReferenceWritable `json:"metadata_url_ca_certificate,omitempty"`

	// MetadataUrlCaCertificateGroup A certificate group containing CA certificates that can be used to
	// validate the authenticity of the configured Identity Provider server.
	MetadataUrlCaCertificateGroup *ReferenceWritable `json:"metadata_url_ca_certificate_group,omitempty"`

	// SignRequestEnabled If set to `true`, SAML requests will be signed by the service provider.
	SignRequestEnabled *bool `json:"sign_request_enabled,omitempty"`

	// Url The URL of the identity provider.
	Url *string `json:"url,omitempty"`

	// VerificationCertificate The certificate used by the service provider to verify the SAML response
	// signature from the identity provider. The credential is managed by
	// the `certificates` endpoint and `purecert` CLI commands.
	VerificationCertificate *ReferenceWritable `json:"verification_certificate,omitempty"`
}

// Saml2SsoSp defines model for _saml2SsoSp.
type Saml2SsoSp struct {
	// AssertionConsumerUrl The URL where the identity provider will send its SAML response after authenticating a user.
	AssertionConsumerUrl *string `json:"assertion_consumer_url,omitempty"`

	// DecryptionCredential The credential used by the service provider to decrypt encrypted SAML
	// assertions from the identity provider. The credential is managed by
	// the `certificates` endpoint and `purecert` CLI commands.
	DecryptionCredential *ReferenceWritable `json:"decryption_credential,omitempty"`

	// EntityId A globally unique name for the service provider.
	EntityId *string `json:"entity_id,omitempty"`

	// MetadataUrl The URL of the service provider metadata.
	MetadataUrl *string `json:"metadata_url,omitempty"`

	// SigningCredential The credential used by the service provider to sign SAML requests.
	// The credential is managed by the `certificates` endpoint and
	// `purecert` CLI commands.
	SigningCredential *ReferenceWritable `json:"signing_credential,omitempty"`
}

// Saml2SsoSpCredential defines model for _saml2SsoSpCredential.
type Saml2SsoSpCredential struct {
	// DecryptionCredential The credential used by the service provider to decrypt encrypted SAML
	// assertions from the identity provider. The credential is managed by
	// the `certificates` endpoint and `purecert` CLI commands.
	DecryptionCredential *ReferenceWritable `json:"decryption_credential,omitempty"`

	// SigningCredential The credential used by the service provider to sign SAML requests.
	// The credential is managed by the `certificates` endpoint and
	// `purecert` CLI commands.
	SigningCredential *ReferenceWritable `json:"signing_credential,omitempty"`
}

// Smb defines model for _smb.
type Smb struct {
	// ClientPolicy Deprecated. See File System Exports for newer functionality.
	// The value returned will be the `client_policy` of the File System
	// Export for the default server, and SMB, with the `export_name`
	// matching the file system name, if there is one and null otherwise.
	// Modifying this field will still work.
	// If the current value is null, then setting this field will attempt
	// to create a File System Export with the `client_policy`
	// and other default values. The `export_name` will be the same as the
	// file system's `name`.
	// If the current value is not null, then setting this field will change
	// the `client_policy` in the matching File System Export.
	// The SMB Client policy for the file system. Setting a policy here grants
	// access permissions (e.g. read-only or read-write) to the file system via
	// SMB on a per-client basis.
	// If no policy is set here, no client will have access.
	// Use "" to clear.
	ClientPolicy *ReferenceWritable `json:"client_policy,omitempty"`

	// ContinuousAvailabilityEnabled If set to `true`, the file system will be continuously available during
	// disruptive scenarios such as network disruption, blades failover, etc.
	// If not specified, defaults to `true`.
	ContinuousAvailabilityEnabled *bool `json:"continuous_availability_enabled,omitempty"`

	// Enabled If set to `true`, enables access to the file system over the SMB
	// protocol. If not specified, defaults to `false`.
	Enabled *bool `json:"enabled,omitempty"`

	// SharePolicy Deprecated. See File System Exports for newer functionality.
	// The value returned will be the `policy` of the File System
	// Export for the default server, and SMB, with the `export_name`
	// matching the file system name, if there is one and null otherwise.
	// Modifying this field will still work.
	// If the current value is null, then setting this field will attempt
	// to create a File System Export with the policy
	// and other default values. The `export_name` will be the same as the
	// file system's `name`.
	// If the current value is not null, then setting this field will change
	// the `policy` in the matching File System Export.
	// The SMB Share policy for the file system. Setting a policy here
	// grants access permissions (e.g. allow or deny Full Control, Change,
	// and/or Read) to the file system via SMB on a per-user / per-group basis.
	// If no policy is set here, no user or group will have access.
	// Use "" to clear.
	SharePolicy *ReferenceWritable `json:"share_policy,omitempty"`
}

// SmbPost defines model for _smbPost.
type SmbPost struct {
	// ClientPolicy The SMB Client policy for the file system. Setting a policy here grants
	// access permissions (e.g. read-only or read-write) to the file system via
	// SMB on a per-client basis.
	// Defaults to a pre-defined full access policy if none is specified.
	ClientPolicy *ReferenceWritable `json:"client_policy,omitempty"`

	// ContinuousAvailabilityEnabled If set to `true`, the file system will be continuously available during
	// disruptive scenarios such as network disruption, blades failover, etc.
	// If not specified, defaults to `true`.
	ContinuousAvailabilityEnabled *bool `json:"continuous_availability_enabled,omitempty"`

	// Enabled If set to `true`, enables access to the file system over the SMB
	// protocol. If not specified, defaults to `false`.
	Enabled *bool `json:"enabled,omitempty"`

	// SharePolicy The SMB Share policy for the file system. Setting a policy here
	// grants access permissions (e.g. allow or deny Full Control, Change,
	// and/or Read) to the file system via SMB on a per-user / per-group basis.
	// Defaults to a pre-defined full access policy if none is specified.
	SharePolicy *ReferenceWritable `json:"share_policy,omitempty"`
}

// SnmpV2c The v2c configurations of SNMP.
type SnmpV2c struct {
	// Community Manager community ID under which Purity is to communicate with
	// the specified managers.
	Community *string `json:"community,omitempty"`
}

// SnmpV3 The v3 configurations of SNMP.
type SnmpV3 struct {
	// AuthPassphrase Passphrase used by Purity to authenticate the array with the
	// specified managers.
	AuthPassphrase *string `json:"auth_passphrase,omitempty"`

	// AuthProtocol Hash algorithm used to validate the authentication passphrase.
	// Valid values are `MD5` and `SHA`.
	AuthProtocol *string `json:"auth_protocol,omitempty"`

	// PrivacyPassphrase Passphrase used to encrypt SNMP messages.
	PrivacyPassphrase *string `json:"privacy_passphrase,omitempty"`

	// PrivacyProtocol Encryption protocol for SNMP messages.
	// Valid values are `AES` and `DES`.
	PrivacyProtocol *string `json:"privacy_protocol,omitempty"`

	// User User ID recognized by the specified SNMP managers which Purity
	// is to use in communications with them.
	User *string `json:"user,omitempty"`
}

// SnmpV3Post The v3 configurations of SNMP.
type SnmpV3Post struct {
	// AuthPassphrase Passphrase used by Purity to authenticate the array with the
	// specified managers.
	AuthPassphrase *string `json:"auth_passphrase,omitempty"`

	// AuthProtocol Hash algorithm used to validate the authentication passphrase.
	// Valid values are `MD5` and `SHA`.
	AuthProtocol *string `json:"auth_protocol,omitempty"`

	// PrivacyPassphrase Passphrase used to encrypt SNMP messages.
	PrivacyPassphrase *string `json:"privacy_passphrase,omitempty"`

	// PrivacyProtocol Encryption protocol for SNMP messages.
	// Valid values are `AES` and `DES`.
	PrivacyProtocol *string `json:"privacy_protocol,omitempty"`

	// User User ID recognized by the specified SNMP managers which Purity
	// is to use in communications with them.
	User *string `json:"user,omitempty"`
}

// SoftwareChecksChecks defines model for _softwareChecksChecks.
type SoftwareChecksChecks struct {
	// Details Detailed result of the check used to diagnose check failures.
	Details *string `json:"details,omitempty"`

	// Name Name of the upgrade check.
	Name *string `json:"name,omitempty"`

	// Status Status of the check. Valid values are `running`, `failed`, and `passed`.
	// A status of `running` indicates that the check has not finished.
	// A status of `failed` indicates that the check has failed.
	// A status of `passed` indicates that the check has passed.
	Status *string `json:"status,omitempty"`
}

// Space defines model for _space.
type Space struct {
	// AvailableProvisioned The amount of space left that the current object can grow before writes are stopped
	// due to a hard limit quota being hit. This is total_provisioned minus the virtual space
	// used for file-systems and buckets.
	// For array and object store accounts it is total_provisioned minus the virtual space
	// used by non-destroyed file-systems and buckets.
	AvailableProvisioned *int64 `json:"available_provisioned,omitempty"`

	// AvailableRatio The ratio of the available space versus the total provisioned space.
	AvailableRatio *float32 `json:"available_ratio,omitempty"`

	// DataReduction Reduction of data.
	DataReduction *float32 `json:"data_reduction,omitempty"`

	// Destroyed Unique physical space (excluding snapshots) occupied by destroyed data within
	// the child containers, in bytes.
	// For buckets and filesystems, the destroyed space will be 0 as they cannot have
	// child containers.
	// For the whole array, the space will be the sum of all destroyed buckets and filesystems.
	Destroyed *int64 `json:"destroyed,omitempty"`

	// DestroyedVirtual The amount of destroyed logically written data within the child containers, in bytes.
	// For buckets and filesystems, the destroyed virtual space will be 0 as they cannot have
	// child containers.
	// For the whole array, the space will be the sum of all destroyed buckets and filesystems.
	DestroyedVirtual *int64 `json:"destroyed_virtual,omitempty"`

	// Shared The space contributed by data that is not unique to a managed directory,
	// or snapshot, measured in bytes.
	Shared *int64 `json:"shared,omitempty"`

	// Snapshots Physical usage by snapshots, other than unique in bytes.
	Snapshots *int64 `json:"snapshots,omitempty"`

	// TotalPhysical Deprecated. See total_used for the newer functionality.
	// The total physical space consumed by the file system, measured in bytes.
	TotalPhysical *int64 `json:"total_physical,omitempty"`

	// TotalProvisioned The effective provisioned size of the container, at which a hard limit
	// will be applied.
	// For a bucket with a `quota_limit` value and `hard_limit_enabled` set to `true`,
	// this is its `quota_limit` value, unless the available space of the associated
	// object store account, as defined by its `quota_limit` value, would prevent the
	// bucket from reaching its own `quota_limit` value. In such a case,
	// `total_provisioned` will reflect the smaller value.
	// For a file system with a `provisioned` value and `hard_limit_enabled` set to
	// `true`, this is the `provisioned` value of the file system.
	// For an object store account with a `quota_limit` value and `hard_limit_enabled`
	// set to `true`, this is the `quota_limit` value of the object store account.
	// For the array, this is the sum of the file systems and accounts.
	// Measured in bytes.
	TotalProvisioned *int64 `json:"total_provisioned,omitempty"`

	// TotalUsed The total space consumed by customer data, measured in bytes.
	TotalUsed *int64 `json:"total_used,omitempty"`

	// Unique Unique physical space occupied by customer data, in bytes.
	// Excludes snapshots, destroyed.
	Unique *int64 `json:"unique,omitempty"`

	// Virtual The amount of logically written data, in bytes.
	// Excludes destroyed data.
	Virtual *int64 `json:"virtual,omitempty"`
}

// StartEndTime A resource with a start time and end time.
type StartEndTime struct {
	// EndTime End time in milliseconds since the UNIX epoch.
	EndTime *int64 `json:"end_time,omitempty"`

	// StartTime Start time in milliseconds since the UNIX epoch.
	StartTime *int64 `json:"start_time,omitempty"`
}

// SupportDiagnosticsSeverityCount defines model for _supportDiagnosticsSeverityCount.
type SupportDiagnosticsSeverityCount struct {
	// Count Count of the corresponding severity.
	Count *int `json:"count,omitempty"`

	// Severity Severity level of the test.
	// Valid values include `info`, `warning`, `critical`.
	Severity *string `json:"severity,omitempty"`
}

// SupportRemoteAssistPaths defines model for _support_remote_assist_paths.
type SupportRemoteAssistPaths struct {
	// ComponentName The name of the FM.
	ComponentName *string `json:"component_name,omitempty"`

	// Status The status of the remote-assist session on the local FM.
	// Valid values are `reconnecting`, `connected`, `disconnected`,
	// and `unknown`.
	Status *string `json:"status,omitempty"`
}

// Throttle The bandwidth throttling for an array connection or target.
type Throttle struct {
	// DefaultLimit Default maximum bandwidth threshold for outbound traffic in bytes. Once
	// exceeded, bandwidth throttling occurs.
	DefaultLimit *int64 `json:"default_limit,omitempty"`

	// Window The time during which the window_limit threshold is in effect.
	Window *TimeWindow `json:"window,omitempty"`

	// WindowLimit Maximum bandwidth threshold for outbound traffic during the specified
	// `window_limit` time range in bytes. Once exceeded, bandwidth throttling
	// occurs.
	WindowLimit *int64 `json:"window_limit,omitempty"`
}

// TimeZone defines model for _timeZone.
type TimeZone = BuiltInNoId

// TimeWindow defines model for _time_window.
type TimeWindow struct {
	// End The window end time. Measured in milliseconds since midnight. The time must be set on the hour. (e.g., `28800000`, which is equal to 8:00 AM).
	End *int64 `json:"end,omitempty"`

	// Start The window start time. Measured in milliseconds since midnight. The time must be set on the hour. (e.g., `18000000`, which is equal to 5:00 AM).
	Start *int64 `json:"start,omitempty"`
}

// TrustPolicyRuleCondition Identity-provider-specific condition that specifies who can assume the role.
type TrustPolicyRuleCondition struct {
	// Key Key from the context of the role assuming request that will have its
	// value compared based on the operator specified in this condition to the
	// values provided in this condition.
	Key *string `json:"key,omitempty"`

	// Operator Operator specifying the comparison to be done between the values from
	// the request context and the values provided in this condition.
	// Valid values: `StringEquals`.
	Operator *string `json:"operator,omitempty"`

	// Values Values to be compared with the values in the role assuming request
	// context identified by the key. If multiple values are specified, it's
	// sufficient if just one matches.
	Values *[]string `json:"values,omitempty"`
}

// User defines model for _user.
type User struct {
	// Id The numeric user id that represents the user's identity in a POSIX system.
	Id *int64 `json:"id,omitempty"`

	// Name The user name that represents the user's identity, and which resolves to the user's id
	// in a configured directory service.
	Name *string `json:"name,omitempty"`
}

// UserNoId defines model for _user_no_id.
type UserNoId struct {
	// Name The user name that represents the user's identity, and which resolves to the user's id
	// in a configured directory service.
	Name *string `json:"name,omitempty"`
}

// Version defines model for _version.
type Version struct {
	// Version A hash of the other properties of this resource. This can be used when
	// updating the resource to ensure there aren't any updates since the
	// resource was read.
	Version *string `json:"version,omitempty"`
}

// WormDataPolicyRetentionConfig defines model for _wormDataPolicyRetentionConfig.
type WormDataPolicyRetentionConfig struct {
	// DefaultRetention Default retention period, in milliseconds. If the access time is not specified
	// when committing a file, then the default retention period is applied.
	DefaultRetention *int64 `json:"default_retention,omitempty"`

	// MaxRetention Maximum retention period, in milliseconds.
	MaxRetention *int64 `json:"max_retention,omitempty"`

	// MinRetention Minimum retention period, in milliseconds.
	MinRetention *int64 `json:"min_retention,omitempty"`

	// Mode The type of the retention lock. Valid values is `compliance`.
	Mode *string `json:"mode,omitempty"`

	// RetentionLock If set to `locked`, then the value of retention attributes or policy attributes are not
	// allowed to change.
	// If set to `unlocked`, then the value of the retention attributes and policy attributes
	// are allowed to change.
	// Valid values are `unlocked` and `locked`. It is always allowed to change from `unlocked` to
	// `locked`. Contact Pure Technical Services to change from `locked` to `unlocked`.
	RetentionLock *string `json:"retention_lock,omitempty"`
}

// AccessKeyNames defines model for Access_key_names.
type AccessKeyNames = []string

// AdminIds defines model for Admin_ids.
type AdminIds = []string

// AdminNames defines model for Admin_names.
type AdminNames = []string

// AllowErrors defines model for Allow_errors.
type AllowErrors = bool

// AnalysisPeriodEndTime defines model for Analysis_period_end_time.
type AnalysisPeriodEndTime = int64

// AnalysisPeriodStartTime defines model for Analysis_period_start_time.
type AnalysisPeriodStartTime = int64

// BeforeRuleId defines model for Before_rule_id.
type BeforeRuleId = string

// BeforeRuleName defines model for Before_rule_name.
type BeforeRuleName = string

// BucketIds defines model for Bucket_ids.
type BucketIds = []string

// BucketNames defines model for Bucket_names.
type BucketNames = []string

// CancelInProgressTransfers defines model for Cancel_in_progress_transfers.
type CancelInProgressTransfers = bool

// CancelStorageClassTransition defines model for Cancel_storage_class_transition.
type CancelStorageClassTransition = bool

// CascadeDelete defines model for Cascade_delete.
type CascadeDelete = []string

// CertificateGroupIds defines model for Certificate_group_ids.
type CertificateGroupIds = []string

// CertificateGroupNames defines model for Certificate_group_names.
type CertificateGroupNames = []string

// CertificateIds defines model for Certificate_ids.
type CertificateIds = []string

// CertificateNames defines model for Certificate_names.
type CertificateNames = []string

// ClientNames defines model for Client_names.
type ClientNames = []string

// ConfirmDate defines model for Confirm_date.
type ConfirmDate = bool

// ContextNames defines model for Context_names.
type ContextNames = []string

// ContextNamesGet defines model for Context_names_get.
type ContextNamesGet = []string

// ContinuationToken defines model for Continuation_token.
type ContinuationToken = string

// CreateDs defines model for Create_ds.
type CreateDs = string

// DefaultExports defines model for Default_exports.
type DefaultExports = []string

// DeleteLinkOnEradication defines model for Delete_link_on_eradication.
type DeleteLinkOnEradication = bool

// DestroySnapshots defines model for Destroy_snapshots.
type DestroySnapshots = bool

// Destroyed defines model for Destroyed.
type Destroyed = bool

// DiscardDetailedPermissions defines model for Discard_detailed_permissions.
type DiscardDetailedPermissions = bool

// DiscardNonSnapshottedData defines model for Discard_non_snapshotted_data.
type DiscardNonSnapshottedData = bool

// Disruptive defines model for Disruptive.
type Disruptive = bool

// EffectiveTlsPolicy defines model for Effective_tls_policy.
type EffectiveTlsPolicy = bool

// EndTime defines model for End_time.
type EndTime = int64

// EnforceActionRestrictions defines model for Enforce_action_restrictions.
type EnforceActionRestrictions = bool

// ExcludeRules defines model for Exclude_rules.
type ExcludeRules = bool

// ExposeApiToken defines model for Expose_api_token.
type ExposeApiToken = bool

// FileSystemIds defines model for File_system_ids.
type FileSystemIds = []string

// FileSystemNames defines model for File_system_names.
type FileSystemNames = []string

// Filter defines model for Filter.
type Filter = string

// FleetIds defines model for Fleet_ids.
type FleetIds = []string

// FleetNames defines model for Fleet_names.
type FleetNames = []string

// FragmentPacket defines model for Fragment_packet.
type FragmentPacket = bool

// FullAccess defines model for Full_access.
type FullAccess = bool

// Gids defines model for Gids.
type Gids = []int32

// GidsNotStrict defines model for Gids_not_strict.
type GidsNotStrict = []string

// GroupNames defines model for Group_names.
type GroupNames = []string

// GroupNamesNotStrict defines model for Group_names_not_strict.
type GroupNamesNotStrict = []string

// Ids defines model for Ids.
type Ids = []string

// IdsForDirectoryServiceRoles defines model for Ids_for_directory_service_roles.
type IdsForDirectoryServiceRoles = []string

// IdsSingle defines model for Ids_single.
type IdsSingle = []string

// IgnoreUsage defines model for Ignore_usage.
type IgnoreUsage = bool

// Indices defines model for Indices.
type Indices = []int

// Inodes defines model for Inodes.
type Inodes = []float32

// JoinExistingAcctAd defines model for Join_existing_acct_ad.
type JoinExistingAcctAd = bool

// KeytabIds defines model for Keytab_ids.
type KeytabIds = []string

// KeytabNames defines model for Keytab_names.
type KeytabNames = []string

// LatestReplica defines model for Latest_replica.
type LatestReplica = bool

// LegalHoldsRecursive defines model for Legal_holds_recursive.
type LegalHoldsRecursive = bool

// LegalHoldsRelease defines model for Legal_holds_release.
type LegalHoldsRelease = bool

// Limit defines model for Limit.
type Limit = int32

// LocalBucketIds defines model for Local_bucket_ids.
type LocalBucketIds = []string

// LocalBucketNames defines model for Local_bucket_names.
type LocalBucketNames = []string

// LocalFileSystemIds defines model for Local_file_system_ids.
type LocalFileSystemIds = []string

// LocalFileSystemNames defines model for Local_file_system_names.
type LocalFileSystemNames = []string

// LocalOnlyAd defines model for Local_only_ad.
type LocalOnlyAd = bool

// MemberIds defines model for Member_ids.
type MemberIds = []string

// MemberNames defines model for Member_names.
type MemberNames = []string

// MemberTypes defines model for Member_types.
type MemberTypes = []string

// Method defines model for Method.
type Method = string

// Mtu defines model for Mtu.
type Mtu = bool

// NamePrefixes defines model for Name_prefixes.
type NamePrefixes = string

// Names defines model for Names.
type Names = []string

// NamesForDirectoryServiceRoles defines model for Names_for_directory_service_roles.
type NamesForDirectoryServiceRoles = []string

// NamesForSyslog defines model for Names_for_syslog.
type NamesForSyslog = []string

// NamesOrOwnerNames defines model for Names_or_owner_names.
type NamesOrOwnerNames = []string

// NamesRequired defines model for Names_required.
type NamesRequired = []string

// NamesSingle defines model for Names_single.
type NamesSingle = []string

// ObjectStoreRoleIds defines model for Object_store_role_ids.
type ObjectStoreRoleIds = []string

// ObjectStoreRoleNames defines model for Object_store_role_names.
type ObjectStoreRoleNames = []string

// Offset defines model for Offset.
type Offset = int32

// OpenFilesPaths defines model for Open_files_paths.
type OpenFilesPaths = []string

// OpenFilesUserNames defines model for Open_files_user_names.
type OpenFilesUserNames = []string

// Overwrite defines model for Overwrite.
type Overwrite = bool

// OwnerIds defines model for Owner_ids.
type OwnerIds = []string

// PacketSize defines model for Packet_size.
type PacketSize = int32

// Paths defines model for Paths.
type Paths = []string

// PingCount defines model for Ping_count.
type PingCount = int32

// PingTraceComponent defines model for Ping_trace_component.
type PingTraceComponent = string

// PingTraceDestination defines model for Ping_trace_destination.
type PingTraceDestination = string

// PingTraceSource defines model for Ping_trace_source.
type PingTraceSource = string

// PolicyIds defines model for Policy_ids.
type PolicyIds = []string

// PolicyNames defines model for Policy_names.
type PolicyNames = []string

// Port defines model for Port.
type Port = string

// PrintLatency defines model for Print_latency.
type PrintLatency = bool

// Protocol defines model for Protocol.
type Protocol = string

// Protocols defines model for Protocols.
type Protocols = []string

// ProtocolsRequired defines model for Protocols_required.
type ProtocolsRequired = []string

// PurityDefined defines model for Purity_defined.
type PurityDefined = bool

// Recursive defines model for Recursive.
type Recursive = bool

// Refresh defines model for Refresh.
type Refresh = bool

// RemoteBucketNames defines model for Remote_bucket_names.
type RemoteBucketNames = []string

// RemoteCredentialsIds defines model for Remote_credentials_ids.
type RemoteCredentialsIds = []string

// RemoteCredentialsNames defines model for Remote_credentials_names.
type RemoteCredentialsNames = []string

// RemoteFileSystemIds defines model for Remote_file_system_ids.
type RemoteFileSystemIds = []string

// RemoteFileSystemNames defines model for Remote_file_system_names.
type RemoteFileSystemNames = []string

// RemoteIds defines model for Remote_ids.
type RemoteIds = []string

// RemoteIdsDeprecated defines model for Remote_ids_deprecated.
type RemoteIdsDeprecated = []string

// RemoteNames defines model for Remote_names.
type RemoteNames = []string

// RemoteNamesDeprecated defines model for Remote_names_deprecated.
type RemoteNamesDeprecated = []string

// ReplicateNow defines model for Replicate_now.
type ReplicateNow = bool

// Resolution defines model for Resolution.
type Resolution = int64

// ResolveHostname defines model for Resolve_hostname.
type ResolveHostname = bool

// RoleIds defines model for Role_ids.
type RoleIds = []string

// RoleNames defines model for Role_names.
type RoleNames = []string

// Send defines model for Send.
type Send = bool

// SessionNames defines model for Session_names.
type SessionNames = []string

// SessionsUserNames defines model for Sessions_user_names.
type SessionsUserNames = []string

// SoftwareNames defines model for Software_names.
type SoftwareNames = []string

// SoftwareVersions defines model for Software_versions.
type SoftwareVersions = []string

// Sort defines model for Sort.
type Sort = []string

// SourceIds defines model for Source_ids.
type SourceIds = []string

// SourceNames defines model for Source_names.
type SourceNames = []string

// StartTime defines model for Start_time.
type StartTime = int64

// StorageClassNames defines model for StorageClassNames.
type StorageClassNames = []string

// Targets defines model for Targets.
type Targets = []string

// TestType defines model for Test_type.
type TestType = string

// Timeout defines model for Timeout.
type Timeout = int64

// TotalItemCount defines model for Total_item_count.
type TotalItemCount = bool

// TotalOnly defines model for Total_only.
type TotalOnly = bool

// Type defines model for Type.
type Type = string

// TypeForPerformance defines model for Type_for_performance.
type TypeForPerformance = string

// Uids defines model for Uids.
type Uids = []int32

// UidsNotStrict defines model for Uids_not_strict.
type UidsNotStrict = []int32

// Unreachable defines model for Unreachable.
type Unreachable = bool

// UserNames defines model for User_names.
type UserNames = []string

// UserNamesNotStrict defines model for User_names_not_strict.
type UserNamesNotStrict = []string

// Versions defines model for Versions.
type Versions = []string

// XRequestId defines model for XRequestId.
type XRequestId = string

// OauthToken200 defines model for OauthToken200.
type OauthToken200 struct {
	// AccessToken The serialized OAuth 2.0 Bearer token used to perform authenticated requests.
	// The access token must be added to the Authorization header of all API calls.
	AccessToken *string `json:"access_token,omitempty"`

	// ExpiresIn The duration after which the access token will expire.
	// Measured in seconds. This differs from other duration
	// fields that are expressed in milliseconds.
	ExpiresIn *uint32 `json:"expires_in,omitempty"`

	// IssuedTokenType The type of token that is issued.
	// The Pure Storage REST API supports OAuth 2.0 access tokens.
	IssuedTokenType *string `json:"issued_token_type,omitempty"`

	// TokenType Indicates how the API client can use the access token issued.
	// The Pure Storage REST API supports the `Bearer` token.
	TokenType *string `json:"token_type,omitempty"`
}

// OauthToken400 defines model for OauthToken400.
type OauthToken400 struct {
	Error            *string `json:"error,omitempty"`
	ErrorDescription *string `json:"error_description,omitempty"`
}

// OauthToken401 defines model for OauthToken401.
type OauthToken401 struct {
	Error            *string `json:"error,omitempty"`
	ErrorDescription *string `json:"error_description,omitempty"`
}

// DeleteApi217ActiveDirectoryParams defines parameters for DeleteApi217ActiveDirectory.
type DeleteApi217ActiveDirectoryParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// LocalOnly If specified as `true`, only delete the Active Directory
	// configuration on the local array, without deleting the
	// computer account created in the Active Directory domain.
	// If not specified, defaults to `false`.
	LocalOnly *LocalOnlyAd `form:"local_only,omitempty" json:"local_only,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ActiveDirectoryParams defines parameters for GetApi217ActiveDirectory.
type GetApi217ActiveDirectoryParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ActiveDirectoryParams defines parameters for PatchApi217ActiveDirectory.
type PatchApi217ActiveDirectoryParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ActiveDirectoryParams defines parameters for PostApi217ActiveDirectory.
type PostApi217ActiveDirectoryParams struct {
	// JoinExistingAccount If specified as `true`, the domain is searched for a pre-existing computer account to join to,
	// and no new account will be created within the domain.
	// The `user` specified when joining to a pre-existing account must have permissions to
	// 'read attributes from' and 'reset the password of' the pre-existing account.
	// `service_principal_names`, `encryption_types`, and `join_ou` will be read from the
	// pre-existing account and cannot be specified when joining to an existing account.
	// If not specified, defaults to `false`.
	JoinExistingAccount *JoinExistingAcctAd `form:"join_existing_account,omitempty" json:"join_existing_account,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ActiveDirectoryTestParams defines parameters for GetApi217ActiveDirectoryTest.
type GetApi217ActiveDirectoryTestParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217AdminsParams defines parameters for DeleteApi217Admins.
type DeleteApi217AdminsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AdminsParams defines parameters for GetApi217Admins.
type GetApi217AdminsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// ExposeApiToken If `true`, exposes the API token of the current user.
	ExposeApiToken *ExposeApiToken `form:"expose_api_token,omitempty" json:"expose_api_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217AdminsParams defines parameters for PatchApi217Admins.
type PatchApi217AdminsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217AdminsParams defines parameters for PostApi217Admins.
type PostApi217AdminsParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217AdminsApiTokensParams defines parameters for DeleteApi217AdminsApiTokens.
type DeleteApi217AdminsApiTokensParams struct {
	// AdminIds A comma-separated list of admin IDs. If after filtering, there is not
	// at least one admin resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the `admin_names` query
	// parameter.
	AdminIds *AdminIds `form:"admin_ids,omitempty" json:"admin_ids,omitempty"`

	// AdminNames A comma-separated list of admin names. If there is not at least one
	// admin resource that matches each of the elements, then an error is returned.
	// This cannot be provided together with `admin_ids` query parameter.
	AdminNames *AdminNames `form:"admin_names,omitempty" json:"admin_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AdminsApiTokensParams defines parameters for GetApi217AdminsApiTokens.
type GetApi217AdminsApiTokensParams struct {
	// AdminIds A comma-separated list of admin IDs. If after filtering, there is not
	// at least one admin resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the `admin_names` query
	// parameter.
	AdminIds *AdminIds `form:"admin_ids,omitempty" json:"admin_ids,omitempty"`

	// AdminNames A comma-separated list of admin names. If there is not at least one
	// admin resource that matches each of the elements, then an error is returned.
	// This cannot be provided together with `admin_ids` query parameter.
	AdminNames *AdminNames `form:"admin_names,omitempty" json:"admin_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// ExposeApiToken If `true`, exposes the API token of the current user.
	ExposeApiToken *ExposeApiToken `form:"expose_api_token,omitempty" json:"expose_api_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217AdminsApiTokensParams defines parameters for PostApi217AdminsApiTokens.
type PostApi217AdminsApiTokensParams struct {
	// AdminIds A comma-separated list of admin IDs. If after filtering, there is not
	// at least one admin resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the `admin_names` query
	// parameter.
	AdminIds *AdminIds `form:"admin_ids,omitempty" json:"admin_ids,omitempty"`

	// AdminNames A comma-separated list of admin names. If there is not at least one
	// admin resource that matches each of the elements, then an error is returned.
	// This cannot be provided together with `admin_ids` query parameter.
	AdminNames *AdminNames `form:"admin_names,omitempty" json:"admin_names,omitempty"`

	// Timeout The duration of API token validity, in milliseconds.
	Timeout *Timeout `form:"timeout,omitempty" json:"timeout,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217AdminsCacheParams defines parameters for DeleteApi217AdminsCache.
type DeleteApi217AdminsCacheParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AdminsCacheParams defines parameters for GetApi217AdminsCache.
type GetApi217AdminsCacheParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Refresh Whether to refresh the user info from directory service.
	// If not specified, defaults to `false`.
	Refresh *Refresh `form:"refresh,omitempty" json:"refresh,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AdminsSettingsParams defines parameters for GetApi217AdminsSettings.
type GetApi217AdminsSettingsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217AdminsSettingsParams defines parameters for PatchApi217AdminsSettings.
type PatchApi217AdminsSettingsParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217AdminsSshCertificateAuthorityPoliciesParams defines parameters for DeleteApi217AdminsSshCertificateAuthorityPolicies.
type DeleteApi217AdminsSshCertificateAuthorityPoliciesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AdminsSshCertificateAuthorityPoliciesParams defines parameters for GetApi217AdminsSshCertificateAuthorityPolicies.
type GetApi217AdminsSshCertificateAuthorityPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217AdminsSshCertificateAuthorityPoliciesParams defines parameters for PostApi217AdminsSshCertificateAuthorityPolicies.
type PostApi217AdminsSshCertificateAuthorityPoliciesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217AlertWatchersParams defines parameters for DeleteApi217AlertWatchers.
type DeleteApi217AlertWatchersParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AlertWatchersParams defines parameters for GetApi217AlertWatchers.
type GetApi217AlertWatchersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217AlertWatchersParams defines parameters for PatchApi217AlertWatchers.
type PatchApi217AlertWatchersParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217AlertWatchersParams defines parameters for PostApi217AlertWatchers.
type PostApi217AlertWatchersParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AlertWatchersTestParams defines parameters for GetApi217AlertWatchersTest.
type GetApi217AlertWatchersTestParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AlertsParams defines parameters for GetApi217Alerts.
type GetApi217AlertsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217AlertsParams defines parameters for PatchApi217Alerts.
type PatchApi217AlertsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ApiClientsParams defines parameters for DeleteApi217ApiClients.
type DeleteApi217ApiClientsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ApiClientsParams defines parameters for GetApi217ApiClients.
type GetApi217ApiClientsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ApiClientsParams defines parameters for PatchApi217ApiClients.
type PatchApi217ApiClientsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ApiClientsParams defines parameters for PostApi217ApiClients.
type PostApi217ApiClientsParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ArrayConnectionsParams defines parameters for DeleteApi217ArrayConnections.
type DeleteApi217ArrayConnectionsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. Deprecated, best practice is to reference connections
	// with `ids`. If after filtering, there is not at least one resource that matches each of the
	// elements, then an error is returned. This cannot be provided together with the `remote_names`
	// query parameter.
	RemoteIds *RemoteIdsDeprecated `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. Deprecated, best practice is to reference
	// connections with `ids`. If there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with `remote_ids` query parameter.
	RemoteNames *RemoteNamesDeprecated `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArrayConnectionsParams defines parameters for GetApi217ArrayConnections.
type GetApi217ArrayConnectionsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ArrayConnectionsParams defines parameters for PatchApi217ArrayConnections.
type PatchApi217ArrayConnectionsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. Deprecated, best practice is to reference connections
	// with `ids`. If after filtering, there is not at least one resource that matches each of the
	// elements, then an error is returned. This cannot be provided together with the `remote_names`
	// query parameter.
	RemoteIds *RemoteIdsDeprecated `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. Deprecated, best practice is to reference
	// connections with `ids`. If there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with `remote_ids` query parameter.
	RemoteNames *RemoteNamesDeprecated `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ArrayConnectionsParams defines parameters for PostApi217ArrayConnections.
type PostApi217ArrayConnectionsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArrayConnectionsConnectionKeyParams defines parameters for GetApi217ArrayConnectionsConnectionKey.
type GetApi217ArrayConnectionsConnectionKeyParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ArrayConnectionsConnectionKeyParams defines parameters for PostApi217ArrayConnectionsConnectionKey.
type PostApi217ArrayConnectionsConnectionKeyParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArrayConnectionsPathParams defines parameters for GetApi217ArrayConnectionsPath.
type GetApi217ArrayConnectionsPathParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArrayConnectionsPerformanceReplicationParams defines parameters for GetApi217ArrayConnectionsPerformanceReplication.
type GetApi217ArrayConnectionsPerformanceReplicationParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// Type Display the metric of a specified object type.
	// Valid values are `all`, `file-system`, and `object-store`.
	// If not specified, defaults to `all`.
	Type *TypeForPerformance `form:"type,omitempty" json:"type,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysParams defines parameters for GetApi217Arrays.
type GetApi217ArraysParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ArraysParams defines parameters for PatchApi217Arrays.
type PatchApi217ArraysParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysClientsPerformanceParams defines parameters for GetApi217ArraysClientsPerformance.
type GetApi217ArraysClientsPerformanceParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysEulaParams defines parameters for GetApi217ArraysEula.
type GetApi217ArraysEulaParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ArraysEulaParams defines parameters for PatchApi217ArraysEula.
type PatchApi217ArraysEulaParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ArraysFactoryResetTokenParams defines parameters for DeleteApi217ArraysFactoryResetToken.
type DeleteApi217ArraysFactoryResetTokenParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysFactoryResetTokenParams defines parameters for GetApi217ArraysFactoryResetToken.
type GetApi217ArraysFactoryResetTokenParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ArraysFactoryResetTokenParams defines parameters for PostApi217ArraysFactoryResetToken.
type PostApi217ArraysFactoryResetTokenParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysHttpSpecificPerformanceParams defines parameters for GetApi217ArraysHttpSpecificPerformance.
type GetApi217ArraysHttpSpecificPerformanceParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysNfsSpecificPerformanceParams defines parameters for GetApi217ArraysNfsSpecificPerformance.
type GetApi217ArraysNfsSpecificPerformanceParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysPerformanceParams defines parameters for GetApi217ArraysPerformance.
type GetApi217ArraysPerformanceParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Protocol Display the performance of a specified protocol.
	// Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`.
	// If not specified, defaults to `all`, which will provide
	// the combined performance of all available protocols.
	Protocol *Protocol `form:"protocol,omitempty" json:"protocol,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysPerformanceReplicationParams defines parameters for GetApi217ArraysPerformanceReplication.
type GetApi217ArraysPerformanceReplicationParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// Type Display the metric of a specified object type.
	// Valid values are `all`, `file-system`, and `object-store`.
	// If not specified, defaults to `all`.
	Type *TypeForPerformance `form:"type,omitempty" json:"type,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysS3SpecificPerformanceParams defines parameters for GetApi217ArraysS3SpecificPerformance.
type GetApi217ArraysS3SpecificPerformanceParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysSpaceParams defines parameters for GetApi217ArraysSpace.
type GetApi217ArraysSpaceParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// Type Display the metric of a specified object type.
	// Valid values are `array`, `file-system`, and `object-store`.
	// If not specified, defaults to `array`.
	Type *Type `form:"type,omitempty" json:"type,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysSpaceStorageClassesParams defines parameters for GetApi217ArraysSpaceStorageClasses.
type GetApi217ArraysSpaceStorageClassesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// StorageClassNames A comma-separated list of storage class names. Valid values include `S500X-S` and `S500X-A`.
	StorageClassNames *StorageClassNames `form:"storage_class_names,omitempty" json:"storage_class_names,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ArraysSshCertificateAuthorityPoliciesParams defines parameters for DeleteApi217ArraysSshCertificateAuthorityPolicies.
type DeleteApi217ArraysSshCertificateAuthorityPoliciesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysSshCertificateAuthorityPoliciesParams defines parameters for GetApi217ArraysSshCertificateAuthorityPolicies.
type GetApi217ArraysSshCertificateAuthorityPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ArraysSshCertificateAuthorityPoliciesParams defines parameters for PostApi217ArraysSshCertificateAuthorityPolicies.
type PostApi217ArraysSshCertificateAuthorityPoliciesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ArraysSupportedTimeZonesParams defines parameters for GetApi217ArraysSupportedTimeZones.
type GetApi217ArraysSupportedTimeZonesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217AuditFileSystemsPoliciesParams defines parameters for DeleteApi217AuditFileSystemsPolicies.
type DeleteApi217AuditFileSystemsPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AuditFileSystemsPoliciesParams defines parameters for GetApi217AuditFileSystemsPolicies.
type GetApi217AuditFileSystemsPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217AuditFileSystemsPoliciesParams defines parameters for PatchApi217AuditFileSystemsPolicies.
type PatchApi217AuditFileSystemsPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217AuditFileSystemsPoliciesParams defines parameters for PostApi217AuditFileSystemsPolicies.
type PostApi217AuditFileSystemsPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217AuditFileSystemsPoliciesMembersParams defines parameters for DeleteApi217AuditFileSystemsPoliciesMembers.
type DeleteApi217AuditFileSystemsPoliciesMembersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AuditFileSystemsPoliciesMembersParams defines parameters for GetApi217AuditFileSystemsPoliciesMembers.
type GetApi217AuditFileSystemsPoliciesMembersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217AuditFileSystemsPoliciesMembersParams defines parameters for PostApi217AuditFileSystemsPoliciesMembers.
type PostApi217AuditFileSystemsPoliciesMembersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217AuditsParams defines parameters for GetApi217Audits.
type GetApi217AuditsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BladesParams defines parameters for GetApi217Blades.
type GetApi217BladesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217BucketReplicaLinksParams defines parameters for DeleteApi217BucketReplicaLinks.
type DeleteApi217BucketReplicaLinksParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// LocalBucketIds A comma-separated list of local bucket IDs. If after filtering, there is
	// not at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the `local_bucket_names`
	// query parameter.
	LocalBucketIds *LocalBucketIds `form:"local_bucket_ids,omitempty" json:"local_bucket_ids,omitempty"`

	// LocalBucketNames A comma-separated list of local bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned. This
	// cannot be provided together with `local_bucket_ids` query parameter.
	LocalBucketNames *LocalBucketNames `form:"local_bucket_names,omitempty" json:"local_bucket_names,omitempty"`

	// RemoteBucketNames A comma-separated list of remote bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned.
	RemoteBucketNames *RemoteBucketNames `form:"remote_bucket_names,omitempty" json:"remote_bucket_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketReplicaLinksParams defines parameters for GetApi217BucketReplicaLinks.
type GetApi217BucketReplicaLinksParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LocalBucketIds A comma-separated list of local bucket IDs. If after filtering, there is
	// not at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the `local_bucket_names`
	// query parameter.
	LocalBucketIds *LocalBucketIds `form:"local_bucket_ids,omitempty" json:"local_bucket_ids,omitempty"`

	// LocalBucketNames A comma-separated list of local bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned. This
	// cannot be provided together with `local_bucket_ids` query parameter.
	LocalBucketNames *LocalBucketNames `form:"local_bucket_names,omitempty" json:"local_bucket_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RemoteBucketNames A comma-separated list of remote bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned.
	RemoteBucketNames *RemoteBucketNames `form:"remote_bucket_names,omitempty" json:"remote_bucket_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217BucketReplicaLinksParams defines parameters for PatchApi217BucketReplicaLinks.
type PatchApi217BucketReplicaLinksParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// LocalBucketIds A comma-separated list of local bucket IDs. If after filtering, there is
	// not at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the `local_bucket_names`
	// query parameter.
	LocalBucketIds *LocalBucketIds `form:"local_bucket_ids,omitempty" json:"local_bucket_ids,omitempty"`

	// LocalBucketNames A comma-separated list of local bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned. This
	// cannot be provided together with `local_bucket_ids` query parameter.
	LocalBucketNames *LocalBucketNames `form:"local_bucket_names,omitempty" json:"local_bucket_names,omitempty"`

	// RemoteBucketNames A comma-separated list of remote bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned.
	RemoteBucketNames *RemoteBucketNames `form:"remote_bucket_names,omitempty" json:"remote_bucket_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217BucketReplicaLinksParams defines parameters for PostApi217BucketReplicaLinks.
type PostApi217BucketReplicaLinksParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// LocalBucketIds A comma-separated list of local bucket IDs. If after filtering, there is
	// not at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the `local_bucket_names`
	// query parameter.
	LocalBucketIds *LocalBucketIds `form:"local_bucket_ids,omitempty" json:"local_bucket_ids,omitempty"`

	// LocalBucketNames A comma-separated list of local bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned. This
	// cannot be provided together with `local_bucket_ids` query parameter.
	LocalBucketNames *LocalBucketNames `form:"local_bucket_names,omitempty" json:"local_bucket_names,omitempty"`

	// RemoteBucketNames A comma-separated list of remote bucket names. If there is not at least one
	// resource that matches each of the elements, then an error is returned.
	RemoteBucketNames *RemoteBucketNames `form:"remote_bucket_names,omitempty" json:"remote_bucket_names,omitempty"`

	// RemoteCredentialsIds A comma-separated list of remote credentials IDs. If after filtering, there
	// is not at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with the
	// `remote_credentials_names` query parameter.
	RemoteCredentialsIds *RemoteCredentialsIds `form:"remote_credentials_ids,omitempty" json:"remote_credentials_ids,omitempty"`

	// RemoteCredentialsNames A comma-separated list of remote credentials names. If there is not at least
	// one resource that matches each of the elements, then an error is returned.
	// This cannot be provided together with the `remote_credentials_ids` query
	// parameter.
	RemoteCredentialsNames *RemoteCredentialsNames `form:"remote_credentials_names,omitempty" json:"remote_credentials_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217BucketsParams defines parameters for DeleteApi217Buckets.
type DeleteApi217BucketsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketsParams defines parameters for GetApi217Buckets.
type GetApi217BucketsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Destroyed If set to `true`, lists only destroyed objects
	// that are in the eradication pending state.
	// If set to `false`, lists only objects that are not destroyed.
	// If not set, lists both objects that are destroyed and those that are not destroyed.
	//
	// If object name(s) are specified in the `names` parameter, then each object referenced must
	// exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed.
	// If `destroyed` is set to `false`, then each object referenced must also not be destroyed.
	// An error is returned if any of these conditions are not met.
	Destroyed *Destroyed `form:"destroyed,omitempty" json:"destroyed,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217BucketsParams defines parameters for PatchApi217Buckets.
type PatchApi217BucketsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// IgnoreUsage Allow update operations that lead to a `hard_limit_enabled` object store
	// account, bucket, or file system with usage over its limiting value.
	// For object store accounts and buckets, the limiting value is that of `quota_limit`,
	// and for file systems it is that of `provisioned`.
	// The operation can be setting `hard_limit_enabled` when usage is higher
	// than the limiting value, modifying the limiting value to a value under usage when
	// `hard_limit_enabled`, recovering a destroyed bucket of an object store account
	// that causes an account's space usage to go over its hard `quota_limit`.
	// Also allows update operations that would cause usage of the requested
	// storage class to go over its warning threshold.
	IgnoreUsage *IgnoreUsage `form:"ignore_usage,omitempty" json:"ignore_usage,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217BucketsParams defines parameters for PostApi217Buckets.
type PostApi217BucketsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217BucketsBucketAccessPoliciesParams defines parameters for DeleteApi217BucketsBucketAccessPolicies.
type DeleteApi217BucketsBucketAccessPoliciesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketsBucketAccessPoliciesParams defines parameters for GetApi217BucketsBucketAccessPolicies.
type GetApi217BucketsBucketAccessPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217BucketsBucketAccessPoliciesParams defines parameters for PostApi217BucketsBucketAccessPolicies.
type PostApi217BucketsBucketAccessPoliciesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217BucketsBucketAccessPoliciesRulesParams defines parameters for DeleteApi217BucketsBucketAccessPoliciesRules.
type DeleteApi217BucketsBucketAccessPoliciesRulesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketsBucketAccessPoliciesRulesParams defines parameters for GetApi217BucketsBucketAccessPoliciesRules.
type GetApi217BucketsBucketAccessPoliciesRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217BucketsBucketAccessPoliciesRulesParams defines parameters for PostApi217BucketsBucketAccessPoliciesRules.
type PostApi217BucketsBucketAccessPoliciesRulesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217BucketsCrossOriginResourceSharingPoliciesParams defines parameters for DeleteApi217BucketsCrossOriginResourceSharingPolicies.
type DeleteApi217BucketsCrossOriginResourceSharingPoliciesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketsCrossOriginResourceSharingPoliciesParams defines parameters for GetApi217BucketsCrossOriginResourceSharingPolicies.
type GetApi217BucketsCrossOriginResourceSharingPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217BucketsCrossOriginResourceSharingPoliciesParams defines parameters for PostApi217BucketsCrossOriginResourceSharingPolicies.
type PostApi217BucketsCrossOriginResourceSharingPoliciesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesParams defines parameters for DeleteApi217BucketsCrossOriginResourceSharingPoliciesRules.
type DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketsCrossOriginResourceSharingPoliciesRulesParams defines parameters for GetApi217BucketsCrossOriginResourceSharingPoliciesRules.
type GetApi217BucketsCrossOriginResourceSharingPoliciesRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams defines parameters for PostApi217BucketsCrossOriginResourceSharingPoliciesRules.
type PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketsPerformanceParams defines parameters for GetApi217BucketsPerformance.
type GetApi217BucketsPerformanceParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217BucketsS3SpecificPerformanceParams defines parameters for GetApi217BucketsS3SpecificPerformance.
type GetApi217BucketsS3SpecificPerformanceParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217CertificateGroupsParams defines parameters for DeleteApi217CertificateGroups.
type DeleteApi217CertificateGroupsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217CertificateGroupsParams defines parameters for GetApi217CertificateGroups.
type GetApi217CertificateGroupsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217CertificateGroupsParams defines parameters for PostApi217CertificateGroups.
type PostApi217CertificateGroupsParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217CertificateGroupsCertificatesParams defines parameters for DeleteApi217CertificateGroupsCertificates.
type DeleteApi217CertificateGroupsCertificatesParams struct {
	// CertificateGroupIds A comma-separated list of certificate group ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_group_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_names` parameter.
	CertificateGroupIds *CertificateGroupIds `form:"certificate_group_ids,omitempty" json:"certificate_group_ids,omitempty"`

	// CertificateGroupNames A comma-separated list of certificate group names.
	// If no resource matches each of the elements of `certificate_group_names`,
	// then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_ids` parameter.
	CertificateGroupNames *CertificateGroupNames `form:"certificate_group_names,omitempty" json:"certificate_group_names,omitempty"`

	// CertificateIds A comma-separated list of certificate ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_names`
	// parameter.
	CertificateIds *CertificateIds `form:"certificate_ids,omitempty" json:"certificate_ids,omitempty"`

	// CertificateNames A comma-separated list of certificate names.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_names`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_ids`
	// parameter.
	CertificateNames *CertificateNames `form:"certificate_names,omitempty" json:"certificate_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217CertificateGroupsCertificatesParams defines parameters for GetApi217CertificateGroupsCertificates.
type GetApi217CertificateGroupsCertificatesParams struct {
	// CertificateGroupIds A comma-separated list of certificate group ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_group_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_names` parameter.
	CertificateGroupIds *CertificateGroupIds `form:"certificate_group_ids,omitempty" json:"certificate_group_ids,omitempty"`

	// CertificateGroupNames A comma-separated list of certificate group names.
	// If no resource matches each of the elements of `certificate_group_names`,
	// then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_ids` parameter.
	CertificateGroupNames *CertificateGroupNames `form:"certificate_group_names,omitempty" json:"certificate_group_names,omitempty"`

	// CertificateIds A comma-separated list of certificate ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_names`
	// parameter.
	CertificateIds *CertificateIds `form:"certificate_ids,omitempty" json:"certificate_ids,omitempty"`

	// CertificateNames A comma-separated list of certificate names.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_names`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_ids`
	// parameter.
	CertificateNames *CertificateNames `form:"certificate_names,omitempty" json:"certificate_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217CertificateGroupsCertificatesParams defines parameters for PostApi217CertificateGroupsCertificates.
type PostApi217CertificateGroupsCertificatesParams struct {
	// CertificateGroupIds A comma-separated list of certificate group ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_group_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_names` parameter.
	CertificateGroupIds *CertificateGroupIds `form:"certificate_group_ids,omitempty" json:"certificate_group_ids,omitempty"`

	// CertificateGroupNames A comma-separated list of certificate group names.
	// If no resource matches each of the elements of `certificate_group_names`,
	// then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_ids` parameter.
	CertificateGroupNames *CertificateGroupNames `form:"certificate_group_names,omitempty" json:"certificate_group_names,omitempty"`

	// CertificateIds A comma-separated list of certificate ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_names`
	// parameter.
	CertificateIds *CertificateIds `form:"certificate_ids,omitempty" json:"certificate_ids,omitempty"`

	// CertificateNames A comma-separated list of certificate names.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_names`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_ids`
	// parameter.
	CertificateNames *CertificateNames `form:"certificate_names,omitempty" json:"certificate_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217CertificateGroupsUsesParams defines parameters for GetApi217CertificateGroupsUses.
type GetApi217CertificateGroupsUsesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217CertificatesParams defines parameters for DeleteApi217Certificates.
type DeleteApi217CertificatesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217CertificatesParams defines parameters for GetApi217Certificates.
type GetApi217CertificatesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217CertificatesParams defines parameters for PatchApi217Certificates.
type PatchApi217CertificatesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217CertificatesParams defines parameters for PostApi217Certificates.
type PostApi217CertificatesParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217CertificatesCertificateGroupsParams defines parameters for DeleteApi217CertificatesCertificateGroups.
type DeleteApi217CertificatesCertificateGroupsParams struct {
	// CertificateGroupIds A comma-separated list of certificate group ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_group_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_names` parameter.
	CertificateGroupIds *CertificateGroupIds `form:"certificate_group_ids,omitempty" json:"certificate_group_ids,omitempty"`

	// CertificateGroupNames A comma-separated list of certificate group names.
	// If no resource matches each of the elements of `certificate_group_names`,
	// then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_ids` parameter.
	CertificateGroupNames *CertificateGroupNames `form:"certificate_group_names,omitempty" json:"certificate_group_names,omitempty"`

	// CertificateIds A comma-separated list of certificate ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_names`
	// parameter.
	CertificateIds *CertificateIds `form:"certificate_ids,omitempty" json:"certificate_ids,omitempty"`

	// CertificateNames A comma-separated list of certificate names.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_names`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_ids`
	// parameter.
	CertificateNames *CertificateNames `form:"certificate_names,omitempty" json:"certificate_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217CertificatesCertificateGroupsParams defines parameters for GetApi217CertificatesCertificateGroups.
type GetApi217CertificatesCertificateGroupsParams struct {
	// CertificateGroupIds A comma-separated list of certificate group ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_group_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_names` parameter.
	CertificateGroupIds *CertificateGroupIds `form:"certificate_group_ids,omitempty" json:"certificate_group_ids,omitempty"`

	// CertificateGroupNames A comma-separated list of certificate group names.
	// If no resource matches each of the elements of `certificate_group_names`,
	// then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_ids` parameter.
	CertificateGroupNames *CertificateGroupNames `form:"certificate_group_names,omitempty" json:"certificate_group_names,omitempty"`

	// CertificateIds A comma-separated list of certificate ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_names`
	// parameter.
	CertificateIds *CertificateIds `form:"certificate_ids,omitempty" json:"certificate_ids,omitempty"`

	// CertificateNames A comma-separated list of certificate names.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_names`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_ids`
	// parameter.
	CertificateNames *CertificateNames `form:"certificate_names,omitempty" json:"certificate_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217CertificatesCertificateGroupsParams defines parameters for PostApi217CertificatesCertificateGroups.
type PostApi217CertificatesCertificateGroupsParams struct {
	// CertificateGroupIds A comma-separated list of certificate group ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_group_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_names` parameter.
	CertificateGroupIds *CertificateGroupIds `form:"certificate_group_ids,omitempty" json:"certificate_group_ids,omitempty"`

	// CertificateGroupNames A comma-separated list of certificate group names.
	// If no resource matches each of the elements of `certificate_group_names`,
	// then an error is returned.
	// This cannot be provided in conjunction with the `certificate_group_ids` parameter.
	CertificateGroupNames *CertificateGroupNames `form:"certificate_group_names,omitempty" json:"certificate_group_names,omitempty"`

	// CertificateIds A comma-separated list of certificate ids.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_ids`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_names`
	// parameter.
	CertificateIds *CertificateIds `form:"certificate_ids,omitempty" json:"certificate_ids,omitempty"`

	// CertificateNames A comma-separated list of certificate names.
	// If there is not at least one resource that matches each of the
	// elements of `certificate_names`, then an error is returned.
	// This cannot be provided in conjunction with the `certificate_ids`
	// parameter.
	CertificateNames *CertificateNames `form:"certificate_names,omitempty" json:"certificate_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217CertificatesUsesParams defines parameters for GetApi217CertificatesUses.
type GetApi217CertificatesUsesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217DirectoryServicesParams defines parameters for GetApi217DirectoryServices.
type GetApi217DirectoryServicesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217DirectoryServicesParams defines parameters for PatchApi217DirectoryServices.
type PatchApi217DirectoryServicesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217DirectoryServicesRolesParams defines parameters for DeleteApi217DirectoryServicesRoles.
type DeleteApi217DirectoryServicesRolesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217DirectoryServicesRolesParams defines parameters for GetApi217DirectoryServicesRoles.
type GetApi217DirectoryServicesRolesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `names`, `role_names`,
	// or `role_ids` query parameters.
	Ids *IdsForDirectoryServiceRoles `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	// This cannot be provided together with the `ids`, `role_names`,
	// or `role_ids` query parameters.
	Names *NamesForDirectoryServiceRoles `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RoleIds A comma-separated list of role_ids.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `ids`, `names` or
	// `role_names` query parameters.
	// This query parameter is deprecated for use with directory service
	// roles. If this parameter is used to query or modify directory
	// service roles, but more than 1 configuration exists with a given
	// role id, an error will be returned in order to avoid ambiguous
	// operation.
	RoleIds *RoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of role_names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `ids`, `names`,
	// or `role_ids` query parameters.
	// This query parameter is deprecated for use with directory service
	// roles. If this parameter is used to query or modify directory
	// service roles, but more than 1 configuration exists with a given
	// role name, an error will be returned in order to avoid ambiguous
	// operation.
	RoleNames *RoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217DirectoryServicesRolesParams defines parameters for PatchApi217DirectoryServicesRoles.
type PatchApi217DirectoryServicesRolesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `names`, `role_names`,
	// or `role_ids` query parameters.
	Ids *IdsForDirectoryServiceRoles `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	// This cannot be provided together with the `ids`, `role_names`,
	// or `role_ids` query parameters.
	Names *NamesForDirectoryServiceRoles `form:"names,omitempty" json:"names,omitempty"`

	// RoleIds A comma-separated list of role_ids.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `ids`, `names` or
	// `role_names` query parameters.
	// This query parameter is deprecated for use with directory service
	// roles. If this parameter is used to query or modify directory
	// service roles, but more than 1 configuration exists with a given
	// role id, an error will be returned in order to avoid ambiguous
	// operation.
	RoleIds *RoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of role_names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `ids`, `names`,
	// or `role_ids` query parameters.
	// This query parameter is deprecated for use with directory service
	// roles. If this parameter is used to query or modify directory
	// service roles, but more than 1 configuration exists with a given
	// role name, an error will be returned in order to avoid ambiguous
	// operation.
	RoleNames *RoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217DirectoryServicesRolesParams defines parameters for PostApi217DirectoryServicesRoles.
type PostApi217DirectoryServicesRolesParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217DirectoryServicesTestParams defines parameters for GetApi217DirectoryServicesTest.
type GetApi217DirectoryServicesTestParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217DirectoryServicesTestParams defines parameters for PatchApi217DirectoryServicesTest.
type PatchApi217DirectoryServicesTestParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217DnsParams defines parameters for DeleteApi217Dns.
type DeleteApi217DnsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217DnsParams defines parameters for GetApi217Dns.
type GetApi217DnsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217DnsParams defines parameters for PatchApi217Dns.
type PatchApi217DnsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217DnsParams defines parameters for PostApi217Dns.
type PostApi217DnsParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217DrivesParams defines parameters for GetApi217Drives.
type GetApi217DrivesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemExportsParams defines parameters for DeleteApi217FileSystemExports.
type DeleteApi217FileSystemExportsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemExportsParams defines parameters for GetApi217FileSystemExports.
type GetApi217FileSystemExportsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217FileSystemExportsParams defines parameters for PatchApi217FileSystemExports.
type PatchApi217FileSystemExportsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemExportsParams defines parameters for PostApi217FileSystemExports.
type PostApi217FileSystemExportsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemReplicaLinksParams defines parameters for DeleteApi217FileSystemReplicaLinks.
type DeleteApi217FileSystemReplicaLinksParams struct {
	// CancelInProgressTransfers This parameter must be set to `true` in order to delete
	// a file system replication link (which can cancel any
	// in-progress replication transfers). Setting this parameter
	// to `true` is acknowledgement that any in-progress replication
	// transfers on the specified links will be cancelled when
	// this request is fulfilled.
	CancelInProgressTransfers *CancelInProgressTransfers `form:"cancel_in_progress_transfers,omitempty" json:"cancel_in_progress_transfers,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// RemoteFileSystemIds A comma-separated list of remote file system IDs. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_names`
	// query parameter.
	RemoteFileSystemIds *RemoteFileSystemIds `form:"remote_file_system_ids,omitempty" json:"remote_file_system_ids,omitempty"`

	// RemoteFileSystemNames A comma-separated list of remote file system names. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_ids`
	// query parameter.
	RemoteFileSystemNames *RemoteFileSystemNames `form:"remote_file_system_names,omitempty" json:"remote_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemReplicaLinksParams defines parameters for GetApi217FileSystemReplicaLinks.
type GetApi217FileSystemReplicaLinksParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RemoteFileSystemIds A comma-separated list of remote file system IDs. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_names`
	// query parameter.
	RemoteFileSystemIds *RemoteFileSystemIds `form:"remote_file_system_ids,omitempty" json:"remote_file_system_ids,omitempty"`

	// RemoteFileSystemNames A comma-separated list of remote file system names. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_ids`
	// query parameter.
	RemoteFileSystemNames *RemoteFileSystemNames `form:"remote_file_system_names,omitempty" json:"remote_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217FileSystemReplicaLinksParams defines parameters for PatchApi217FileSystemReplicaLinks.
type PatchApi217FileSystemReplicaLinksParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// ReplicateNow If set to `true`, replicates the contents to the specified targets.
	// The `replicate_now` parameters can only be `true` with the partial-replica file system links.
	ReplicateNow *ReplicateNow `form:"replicate_now,omitempty" json:"replicate_now,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemReplicaLinksParams defines parameters for PostApi217FileSystemReplicaLinks.
type PostApi217FileSystemReplicaLinksParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// RemoteFileSystemNames A comma-separated list of remote file system names. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_ids`
	// query parameter.
	RemoteFileSystemNames *RemoteFileSystemNames `form:"remote_file_system_names,omitempty" json:"remote_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemReplicaLinksPoliciesParams defines parameters for DeleteApi217FileSystemReplicaLinksPolicies.
type DeleteApi217FileSystemReplicaLinksPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemReplicaLinksPoliciesParams defines parameters for GetApi217FileSystemReplicaLinksPolicies.
type GetApi217FileSystemReplicaLinksPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteFileSystemIds A comma-separated list of remote file system IDs. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_names`
	// query parameter.
	RemoteFileSystemIds *RemoteFileSystemIds `form:"remote_file_system_ids,omitempty" json:"remote_file_system_ids,omitempty"`

	// RemoteFileSystemNames A comma-separated list of remote file system names. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_ids`
	// query parameter.
	RemoteFileSystemNames *RemoteFileSystemNames `form:"remote_file_system_names,omitempty" json:"remote_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemReplicaLinksPoliciesParams defines parameters for PostApi217FileSystemReplicaLinksPolicies.
type PostApi217FileSystemReplicaLinksPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemReplicaLinksTransferParams defines parameters for GetApi217FileSystemReplicaLinksTransfer.
type GetApi217FileSystemReplicaLinksTransferParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// NamesOrOwnerNames A comma-separated list of resource names.
	// Either the names of the snapshots or the owning file systems.
	NamesOrOwnerNames *NamesOrOwnerNames `form:"names_or_owner_names,omitempty" json:"names_or_owner_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemSnapshotsParams defines parameters for DeleteApi217FileSystemSnapshots.
type DeleteApi217FileSystemSnapshotsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemSnapshotsParams defines parameters for GetApi217FileSystemSnapshots.
type GetApi217FileSystemSnapshotsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Destroyed If set to `true`, lists only destroyed objects
	// that are in the eradication pending state.
	// If set to `false`, lists only objects that are not destroyed.
	// If not set, lists both objects that are destroyed and those that are not destroyed.
	//
	// If object name(s) are specified in the `names` parameter, then each object referenced must
	// exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed.
	// If `destroyed` is set to `false`, then each object referenced must also not be destroyed.
	// An error is returned if any of these conditions are not met.
	Destroyed *Destroyed `form:"destroyed,omitempty" json:"destroyed,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// NamesOrOwnerNames A comma-separated list of resource names.
	// Either the names of the snapshots or the owning file systems.
	NamesOrOwnerNames *NamesOrOwnerNames `form:"names_or_owner_names,omitempty" json:"names_or_owner_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// OwnerIds A comma-separated list of owning file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of owner IDs, then an error is returned.
	// This cannot be provided together with the `ids`, `names_or_owner_names`,
	// or `names_or_sources` query parameters.
	OwnerIds *OwnerIds `form:"owner_ids,omitempty" json:"owner_ids,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217FileSystemSnapshotsParams defines parameters for PatchApi217FileSystemSnapshots.
type PatchApi217FileSystemSnapshotsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// LatestReplica Used when destroying a snapshot. If not present or `false`, and the snapshot
	// is the latest replicated snapshot, then destroy will fail. If `true` or the
	// snapshot is not the latest replicated snapshot, then destroy will be
	// successful.
	LatestReplica *LatestReplica `form:"latest_replica,omitempty" json:"latest_replica,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemSnapshotsParams defines parameters for PostApi217FileSystemSnapshots.
type PostApi217FileSystemSnapshotsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Send Whether to replicate created snapshots immediately to other arrays.
	// If it's `false`, created snapshots may still be replicated to other arrays
	// according to policy.
	Send *Send `form:"send,omitempty" json:"send,omitempty"`

	// SourceIds A comma-separated list of source file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `source_ids`, then an error is returned.
	// This cannot be provided together with the `names_or_sources` or
	// `sources` query parameters.
	SourceIds *SourceIds `form:"source_ids,omitempty" json:"source_ids,omitempty"`

	// SourceNames A comma-separated list of names for the source of the object.
	// If there is not at least one resource that matches each of the elements of
	// `source_names`, an error is returned.
	SourceNames *SourceNames `form:"source_names,omitempty" json:"source_names,omitempty"`

	// Targets The target arrays to replicate created snapshots to.
	// Only valid when `send` is `true`.
	Targets *Targets `form:"targets,omitempty" json:"targets,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemSnapshotsPoliciesParams defines parameters for DeleteApi217FileSystemSnapshotsPolicies.
type DeleteApi217FileSystemSnapshotsPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemSnapshotsPoliciesParams defines parameters for GetApi217FileSystemSnapshotsPolicies.
type GetApi217FileSystemSnapshotsPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemSnapshotsTransferParams defines parameters for DeleteApi217FileSystemSnapshotsTransfer.
type DeleteApi217FileSystemSnapshotsTransferParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemSnapshotsTransferParams defines parameters for GetApi217FileSystemSnapshotsTransfer.
type GetApi217FileSystemSnapshotsTransferParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// NamesOrOwnerNames A comma-separated list of resource names.
	// Either the names of the snapshots or the owning file systems.
	NamesOrOwnerNames *NamesOrOwnerNames `form:"names_or_owner_names,omitempty" json:"names_or_owner_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemsParams defines parameters for DeleteApi217FileSystems.
type DeleteApi217FileSystemsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsParams defines parameters for GetApi217FileSystems.
type GetApi217FileSystemsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Destroyed If set to `true`, lists only destroyed objects
	// that are in the eradication pending state.
	// If set to `false`, lists only objects that are not destroyed.
	// If not set, lists both objects that are destroyed and those that are not destroyed.
	//
	// If object name(s) are specified in the `names` parameter, then each object referenced must
	// exist. If `destroyed` is set to `true`, then each object referenced must also be destroyed.
	// If `destroyed` is set to `false`, then each object referenced must also not be destroyed.
	// An error is returned if any of these conditions are not met.
	Destroyed *Destroyed `form:"destroyed,omitempty" json:"destroyed,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217FileSystemsParams defines parameters for PatchApi217FileSystems.
type PatchApi217FileSystemsParams struct {
	// CancelInProgressStorageClassTransition If set to `true`, the storage class policy of this file system
	// will be set to the requested storage class policy, even if
	// a transition to a different storage class is in-progress.
	// Setting this parameter to `true` is acknowledgement that any
	// in-progress transition on this file system will be cancelled.
	// If not specified, the default value is `false`.
	CancelInProgressStorageClassTransition *CancelStorageClassTransition `form:"cancel_in_progress_storage_class_transition,omitempty" json:"cancel_in_progress_storage_class_transition,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// DeleteLinkOnEradication If set to `true`, the file system can be destroyed, even if it has a replica link.
	// If set to `false`, the file system cannot be destroyed if it has a replica link.
	// Defaults to `false`.
	DeleteLinkOnEradication *DeleteLinkOnEradication `form:"delete_link_on_eradication,omitempty" json:"delete_link_on_eradication,omitempty"`

	// DiscardDetailedPermissions This parameter must be set to `true` in order to change
	// a file system's `access_control_style` from a style that
	// supports more detailed access control lists to a style that
	// only supports less detailed mode bits as a form of permission
	// control.
	// This parameter may not be set to `true` any other time.
	// Setting this parameter to `true` is acknowledgement that any
	// more detailed access control lists currently set within the
	// file system will be lost, and NFS permission controls will
	// only be enforced at the granularity level of NFS mode bits.
	DiscardDetailedPermissions *DiscardDetailedPermissions `form:"discard_detailed_permissions,omitempty" json:"discard_detailed_permissions,omitempty"`

	// DiscardNonSnapshottedData This parameter must be set to `true` in order to restore
	// a file system from a snapshot or to demote a file system
	// (which restores the file system from the common baseline
	// snapshot). Setting this parameter to `true` is acknowledgement
	// that any non-snapshotted data currently in the file system
	// will be irretrievably lost.
	DiscardNonSnapshottedData *DiscardNonSnapshottedData `form:"discard_non_snapshotted_data,omitempty" json:"discard_non_snapshotted_data,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// IgnoreUsage Allow update operations that lead to a `hard_limit_enabled` object store
	// account, bucket, or file system with usage over its limiting value.
	// For object store accounts and buckets, the limiting value is that of `quota_limit`,
	// and for file systems it is that of `provisioned`.
	// The operation can be setting `hard_limit_enabled` when usage is higher
	// than the limiting value, modifying the limiting value to a value under usage when
	// `hard_limit_enabled`, recovering a destroyed bucket of an object store account
	// that causes an account's space usage to go over its hard `quota_limit`.
	// Also allows update operations that would cause usage of the requested
	// storage class to go over its warning threshold.
	IgnoreUsage *IgnoreUsage `form:"ignore_usage,omitempty" json:"ignore_usage,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemsParams defines parameters for PostApi217FileSystems.
type PostApi217FileSystemsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// DefaultExports A comma-separated list of export types to be created using default access.
	// Creating a file system with an explicit `nfs.rules` or `nfs.export_policy` value will always
	// create a NFS export to the default server regardless of this flag. If these are not set and
	// `default_exports` includes `nfs`, then `nfs.rules` will be set to "*(rw,no_root_squash)"
	// and a NFS export to the default server will be created. Otherwise `nfs.rules` will be set to ""
	// and no NFS export will be created.
	// Creating a file system with an explicit `smb.client_policy` or `smb.share_policy` value will
	// always create a SMB export to the default server regardless of this flag. If these are not set
	// and `default_exports` includes `smb`, then a SMB export to the default server will be
	// created with default policies. Otherwise no SMB export will be created.
	// Use empty string ("") to not create these default exports.
	// Default is `nfs,smb`.
	DefaultExports *DefaultExports `form:"default_exports,omitempty" json:"default_exports,omitempty"`

	// DiscardNonSnapshottedData This parameter must be set to `true` in order to restore
	// a file system from a snapshot or to demote a file system
	// (which restores the file system from the common baseline
	// snapshot). Setting this parameter to `true` is acknowledgement
	// that any non-snapshotted data currently in the file system
	// will be irretrievably lost.
	DiscardNonSnapshottedData *DiscardNonSnapshottedData `form:"discard_non_snapshotted_data,omitempty" json:"discard_non_snapshotted_data,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// Overwrite When used for snapshot restore, overwrites (`true`) an existing file system.
	Overwrite *Overwrite `form:"overwrite,omitempty" json:"overwrite,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemsAuditPoliciesParams defines parameters for DeleteApi217FileSystemsAuditPolicies.
type DeleteApi217FileSystemsAuditPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsAuditPoliciesParams defines parameters for GetApi217FileSystemsAuditPolicies.
type GetApi217FileSystemsAuditPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemsAuditPoliciesParams defines parameters for PostApi217FileSystemsAuditPolicies.
type PostApi217FileSystemsAuditPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsGroupsPerformanceParams defines parameters for GetApi217FileSystemsGroupsPerformance.
type GetApi217FileSystemsGroupsPerformanceParams struct {
	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Gids A comma-separated list of group IDs.
	// This cannot be provided together with `group_names` query parameter.
	Gids *GidsNotStrict `form:"gids,omitempty" json:"gids,omitempty"`

	// GroupNames A comma-separated list of group names.
	// This cannot be provided together with `gids` query parameter.
	GroupNames *GroupNamesNotStrict `form:"group_names,omitempty" json:"group_names,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemsLocksParams defines parameters for DeleteApi217FileSystemsLocks.
type DeleteApi217FileSystemsLocksParams struct {
	// ClientNames A comma-separated list of ip addresses of clients.
	// For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened
	// format are supported.
	ClientNames *ClientNames `form:"client_names,omitempty" json:"client_names,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Inodes A comma-separated list of inodes used for filtering file locks query by inodes.
	// This may only be specified if `file_system_ids` or `file_system_names` is
	// also specified.
	// This cannot be provided together with the `paths` query parameter.
	Inodes *Inodes `form:"inodes,omitempty" json:"inodes,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Paths A comma-separated list of paths used for filtering file locks query by paths.
	// This may only be specified if `file_system_ids` or `file_system_names` is
	// also specified.
	// This cannot be provided together with the `inodes` query parameter.
	Paths *Paths `form:"paths,omitempty" json:"paths,omitempty"`

	// Recursive Flag used to indicate that the action should be done recursively.
	// If set to `true` and used e.g. with `path` pointing to a directory, the
	// operation will delete all locks in given directory and subdirectories recursively.
	// For more fine grained control over deleted locks, use delete by name.
	// If not specified, defaults to `false`.
	Recursive *Recursive `form:"recursive,omitempty" json:"recursive,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsLocksParams defines parameters for GetApi217FileSystemsLocks.
type GetApi217FileSystemsLocksParams struct {
	// ClientNames A comma-separated list of ip addresses of clients.
	// For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened
	// format are supported.
	ClientNames *ClientNames `form:"client_names,omitempty" json:"client_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Inodes A comma-separated list of inodes used for filtering file locks query by inodes.
	// This may only be specified if `file_system_ids` or `file_system_names` is
	// also specified.
	// This cannot be provided together with the `paths` query parameter.
	Inodes *Inodes `form:"inodes,omitempty" json:"inodes,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Paths A comma-separated list of paths used for filtering file locks query by paths.
	// This may only be specified if `file_system_ids` or `file_system_names` is
	// also specified.
	// This cannot be provided together with the `inodes` query parameter.
	Paths *Paths `form:"paths,omitempty" json:"paths,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsLocksClientsParams defines parameters for GetApi217FileSystemsLocksClients.
type GetApi217FileSystemsLocksClientsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemsLocksNlmReclamationsParams defines parameters for PostApi217FileSystemsLocksNlmReclamations.
type PostApi217FileSystemsLocksNlmReclamationsParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemsOpenFilesParams defines parameters for DeleteApi217FileSystemsOpenFiles.
type DeleteApi217FileSystemsOpenFilesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsOpenFilesParams defines parameters for GetApi217FileSystemsOpenFiles.
type GetApi217FileSystemsOpenFilesParams struct {
	// ClientNames A comma-separated list of ip addresses of clients.
	// For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened
	// format are supported.
	ClientNames *ClientNames `form:"client_names,omitempty" json:"client_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Paths A comma-separated list of paths used for filtering open files query.
	Paths *OpenFilesPaths `form:"paths,omitempty" json:"paths,omitempty"`

	// Protocols A comma-separated list of file protocols.
	// Valid values include `nfs` and `smb`.
	Protocols ProtocolsRequired `form:"protocols" json:"protocols"`

	// SessionNames A comma-separated list of session names used for filtering open files query.
	// Files opened in any of the specified sessions will be returned.
	SessionNames *SessionNames `form:"session_names,omitempty" json:"session_names,omitempty"`

	// UserNames A comma-separated list of user names used for filtering open files query.
	// Files opened by any of the specified users will be returned.
	UserNames *OpenFilesUserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsPerformanceParams defines parameters for GetApi217FileSystemsPerformance.
type GetApi217FileSystemsPerformanceParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Protocol Display the performance of a specified protocol.
	// Valid values are `all`, `HTTP`, `SMB`, `NFS`, and `S3`.
	// If not specified, defaults to `all`, which will provide
	// the combined performance of all available protocols.
	Protocol *Protocol `form:"protocol,omitempty" json:"protocol,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemsPoliciesParams defines parameters for DeleteApi217FileSystemsPolicies.
type DeleteApi217FileSystemsPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsPoliciesParams defines parameters for GetApi217FileSystemsPolicies.
type GetApi217FileSystemsPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FileSystemsPoliciesParams defines parameters for PostApi217FileSystemsPolicies.
type PostApi217FileSystemsPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsPoliciesAllParams defines parameters for GetApi217FileSystemsPoliciesAll.
type GetApi217FileSystemsPoliciesAllParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FileSystemsSessionsParams defines parameters for DeleteApi217FileSystemsSessions.
type DeleteApi217FileSystemsSessionsParams struct {
	// ClientNames A comma-separated list of ip addresses of clients.
	// For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened
	// format are supported.
	ClientNames *ClientNames `form:"client_names,omitempty" json:"client_names,omitempty"`

	// Disruptive If set to `true`, a wide scope of sessions may be deleted
	// in a single action using a single query parameter from
	// `user_names`, `client_names`, or `protocols`. Otherwise,
	// multiple query parameters must be specified to narrow
	// the impact of deletion and avoid potential for accidental
	// disruption of clients.
	Disruptive *Disruptive `form:"disruptive,omitempty" json:"disruptive,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Protocols A comma-separated list of file protocols.
	// Valid values include `nfs` and `smb`.
	Protocols *Protocols `form:"protocols,omitempty" json:"protocols,omitempty"`

	// UserNames A comma-separated list of user names.
	UserNames *SessionsUserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsSessionsParams defines parameters for GetApi217FileSystemsSessions.
type GetApi217FileSystemsSessionsParams struct {
	// ClientNames A comma-separated list of ip addresses of clients.
	// For IPv6 both the extended format (x:x:x:x:x:x:x:x) and the shortened
	// format are supported.
	ClientNames *ClientNames `form:"client_names,omitempty" json:"client_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Protocols A comma-separated list of file protocols.
	// Valid values include `nfs` and `smb`.
	Protocols *Protocols `form:"protocols,omitempty" json:"protocols,omitempty"`

	// UserNames A comma-separated list of user names.
	UserNames *SessionsUserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsUsersPerformanceParams defines parameters for GetApi217FileSystemsUsersPerformance.
type GetApi217FileSystemsUsersPerformanceParams struct {
	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// Uids A comma-separated list of user IDs.
	// This cannot be provided together with `user_names` query parameter.
	Uids *UidsNotStrict `form:"uids,omitempty" json:"uids,omitempty"`

	// UserNames A comma-separated list of user names.
	// This cannot be provided together with `uids` query parameter.
	UserNames *UserNamesNotStrict `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FileSystemsWormDataPoliciesParams defines parameters for GetApi217FileSystemsWormDataPolicies.
type GetApi217FileSystemsWormDataPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FleetsParams defines parameters for DeleteApi217Fleets.
type DeleteApi217FleetsParams struct {
	// Ids Performs the operation on the unique resource IDs specified.
	// Only one value is supported.
	Ids *IdsSingle `form:"ids,omitempty" json:"ids,omitempty"`

	// Names Performs the operation on the unique resource names specified.
	// Only one value is supported.
	Names *NamesSingle `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FleetsParams defines parameters for GetApi217Fleets.
type GetApi217FleetsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids Performs the operation on the unique resource IDs specified.
	// Only one value is supported.
	Ids *IdsSingle `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names Performs the operation on the unique resource names specified.
	// Only one value is supported.
	Names *NamesSingle `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217FleetsParams defines parameters for PatchApi217Fleets.
type PatchApi217FleetsParams struct {
	// Ids Performs the operation on the unique resource IDs specified.
	// Only one value is supported.
	Ids *IdsSingle `form:"ids,omitempty" json:"ids,omitempty"`

	// Names Performs the operation on the unique resource names specified.
	// Only one value is supported.
	Names *NamesSingle `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FleetsParams defines parameters for PostApi217Fleets.
type PostApi217FleetsParams struct {
	// Names Performs the operation on the unique resource names specified.
	// Only one value is supported.
	Names *NamesSingle `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FleetsFleetKeyParams defines parameters for GetApi217FleetsFleetKey.
type GetApi217FleetsFleetKeyParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FleetsFleetKeyParams defines parameters for PostApi217FleetsFleetKey.
type PostApi217FleetsFleetKeyParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217FleetsMembersParams defines parameters for DeleteApi217FleetsMembers.
type DeleteApi217FleetsMembersParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Unreachable If set to `true`, allows a one-sided disconnect when the connection
	// status is `connecting` instead of `connected` or `partially connected`.
	// If set to `false`, it works just like normal coordinated disconnect.
	// If not specified, defaults to `false`.
	Unreachable *Unreachable `form:"unreachable,omitempty" json:"unreachable,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217FleetsMembersParams defines parameters for GetApi217FleetsMembers.
type GetApi217FleetsMembersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// FleetIds Performs the operation on the unique Fleet IDs specified.
	// This query currently accepts only 1 ID.
	FleetIds *FleetIds `form:"fleet_ids,omitempty" json:"fleet_ids,omitempty"`

	// FleetNames Performs the operation on the unique Fleet names specified.
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	// This query currently accepts only 1 name.
	FleetNames *FleetNames `form:"fleet_names,omitempty" json:"fleet_names,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217FleetsMembersParams defines parameters for PostApi217FleetsMembers.
type PostApi217FleetsMembersParams struct {
	// FleetIds Performs the operation on the unique Fleet IDs specified.
	// This query currently accepts only 1 ID.
	FleetIds *FleetIds `form:"fleet_ids,omitempty" json:"fleet_ids,omitempty"`

	// FleetNames Performs the operation on the unique Fleet names specified.
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	// This query currently accepts only 1 name.
	FleetNames *FleetNames `form:"fleet_names,omitempty" json:"fleet_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217HardwareParams defines parameters for GetApi217Hardware.
type GetApi217HardwareParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217HardwareParams defines parameters for PatchApi217Hardware.
type PatchApi217HardwareParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217HardwareConnectorsParams defines parameters for GetApi217HardwareConnectors.
type GetApi217HardwareConnectorsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217HardwareConnectorsParams defines parameters for PatchApi217HardwareConnectors.
type PatchApi217HardwareConnectorsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217HardwareConnectorsPerformanceParams defines parameters for GetApi217HardwareConnectorsPerformance.
type GetApi217HardwareConnectorsPerformanceParams struct {
	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217KeytabsParams defines parameters for DeleteApi217Keytabs.
type DeleteApi217KeytabsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217KeytabsParams defines parameters for GetApi217Keytabs.
type GetApi217KeytabsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217KeytabsParams defines parameters for PostApi217Keytabs.
type PostApi217KeytabsParams struct {
	// NamePrefixes The prefix to use for the names of all Kerberos keytab objects
	// that are being created.
	NamePrefixes *NamePrefixes `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217KeytabsDownloadParams defines parameters for GetApi217KeytabsDownload.
type GetApi217KeytabsDownloadParams struct {
	// KeytabIds A comma-separated list of keytab IDs. If after filtering, there is not
	// at least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `keytab_names` query
	// parameter.
	KeytabIds *KeytabIds `form:"keytab_ids,omitempty" json:"keytab_ids,omitempty"`

	// KeytabNames A comma-separated list of keytab names. If there is not at least one
	// resource that matches each of the elements, then an error is returned. This
	// cannot be provided together with `keytab_ids` query parameter.
	KeytabNames *KeytabNames `form:"keytab_names,omitempty" json:"keytab_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217KeytabsUploadMultipartBody defines parameters for PostApi217KeytabsUpload.
type PostApi217KeytabsUploadMultipartBody struct {
	// KeytabFile The keytab file to upload.
	KeytabFile KeytabFile `json:"keytab_file"`
}

// PostApi217KeytabsUploadParams defines parameters for PostApi217KeytabsUpload.
type PostApi217KeytabsUploadParams struct {
	// NamePrefixes The prefix to use for the names of all Kerberos keytab objects
	// that are being created.
	NamePrefixes *NamePrefixes `form:"name_prefixes,omitempty" json:"name_prefixes,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217KmipParams defines parameters for DeleteApi217Kmip.
type DeleteApi217KmipParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217KmipParams defines parameters for GetApi217Kmip.
type GetApi217KmipParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217KmipParams defines parameters for PatchApi217Kmip.
type PatchApi217KmipParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217KmipParams defines parameters for PostApi217Kmip.
type PostApi217KmipParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217KmipTestParams defines parameters for GetApi217KmipTest.
type GetApi217KmipTestParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217LegalHoldsParams defines parameters for DeleteApi217LegalHolds.
type DeleteApi217LegalHoldsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217LegalHoldsParams defines parameters for GetApi217LegalHolds.
type GetApi217LegalHoldsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217LegalHoldsParams defines parameters for PatchApi217LegalHolds.
type PatchApi217LegalHoldsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217LegalHoldsParams defines parameters for PostApi217LegalHolds.
type PostApi217LegalHoldsParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217LegalHoldsHeldEntitiesParams defines parameters for GetApi217LegalHoldsHeldEntities.
type GetApi217LegalHoldsHeldEntitiesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Paths A comma-separated list of paths used for filtering file locks query by paths.
	// This may only be specified if `file_system_ids` or `file_system_names` is
	// also specified.
	// This cannot be provided together with the `inodes` query parameter.
	Paths *Paths `form:"paths,omitempty" json:"paths,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217LegalHoldsHeldEntitiesParams defines parameters for PatchApi217LegalHoldsHeldEntities.
type PatchApi217LegalHoldsHeldEntitiesParams struct {
	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Paths A comma-separated list of paths used for filtering file locks query by paths.
	// This may only be specified if `file_system_ids` or `file_system_names` is
	// also specified.
	// This cannot be provided together with the `inodes` query parameter.
	Paths *Paths `form:"paths,omitempty" json:"paths,omitempty"`

	// Recursive This is a flag to set when recursively applying/releasing legal holds on entities.
	// By default, it is set to be false.
	// The `recursive` flag is required when applying/releasing a hold to/from a directory.
	Recursive *LegalHoldsRecursive `form:"recursive,omitempty" json:"recursive,omitempty"`

	// Released This is a flag to set when releasing an attached legal hold from a path.
	Released LegalHoldsRelease `form:"released" json:"released"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217LegalHoldsHeldEntitiesParams defines parameters for PostApi217LegalHoldsHeldEntities.
type PostApi217LegalHoldsHeldEntitiesParams struct {
	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Paths A comma-separated list of paths used for filtering file locks query by paths.
	// This may only be specified if `file_system_ids` or `file_system_names` is
	// also specified.
	// This cannot be provided together with the `inodes` query parameter.
	Paths *Paths `form:"paths,omitempty" json:"paths,omitempty"`

	// Recursive This is a flag to set when recursively applying/releasing legal holds on entities.
	// By default, it is set to be false.
	// The `recursive` flag is required when applying/releasing a hold to/from a directory.
	Recursive *LegalHoldsRecursive `form:"recursive,omitempty" json:"recursive,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217LifecycleRulesParams defines parameters for DeleteApi217LifecycleRules.
type DeleteApi217LifecycleRulesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217LifecycleRulesParams defines parameters for GetApi217LifecycleRules.
type GetApi217LifecycleRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217LifecycleRulesParams defines parameters for PatchApi217LifecycleRules.
type PatchApi217LifecycleRulesParams struct {
	// BucketIds A comma-separated list of bucket IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `bucket_ids`, then an error is returned.
	// This cannot be provided together with the `bucket_names` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketIds *BucketIds `form:"bucket_ids,omitempty" json:"bucket_ids,omitempty"`

	// BucketNames A comma-separated list of bucket names.
	// If there is not at least one resource that matches
	// each of the elements of `bucket_names`, then an error is returned.
	// This cannot be provided together with the `bucket_ids` query parameter.
	// This can be provided with the `ids` query parameter but not with `names`.
	BucketNames *BucketNames `form:"bucket_names,omitempty" json:"bucket_names,omitempty"`

	// ConfirmDate If set to `true`, then confirm the date of `keep_current_version_until` is correct.
	ConfirmDate *ConfirmDate `form:"confirm_date,omitempty" json:"confirm_date,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217LifecycleRulesParams defines parameters for PostApi217LifecycleRules.
type PostApi217LifecycleRulesParams struct {
	// ConfirmDate If set to `true`, then confirm the date of `keep_current_version_until` is correct.
	ConfirmDate *ConfirmDate `form:"confirm_date,omitempty" json:"confirm_date,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217LinkAggregationGroupsParams defines parameters for DeleteApi217LinkAggregationGroups.
type DeleteApi217LinkAggregationGroupsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217LinkAggregationGroupsParams defines parameters for GetApi217LinkAggregationGroups.
type GetApi217LinkAggregationGroupsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217LinkAggregationGroupsJSONBody defines parameters for PatchApi217LinkAggregationGroups.
type PatchApi217LinkAggregationGroupsJSONBody struct {
	AddPorts    *[]FixedReference `json:"add_ports,omitempty"`
	Ports       *[]FixedReference `json:"ports,omitempty"`
	RemovePorts *[]FixedReference `json:"remove_ports,omitempty"`
}

// PatchApi217LinkAggregationGroupsParams defines parameters for PatchApi217LinkAggregationGroups.
type PatchApi217LinkAggregationGroupsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217LinkAggregationGroupsParams defines parameters for PostApi217LinkAggregationGroups.
type PostApi217LinkAggregationGroupsParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217LogsParams defines parameters for GetApi217Logs.
type GetApi217LogsParams struct {
	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217LogsAsyncParams defines parameters for GetApi217LogsAsync.
type GetApi217LogsAsyncParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217LogsAsyncParams defines parameters for PatchApi217LogsAsync.
type PatchApi217LogsAsyncParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217LogsAsyncDownloadParams defines parameters for GetApi217LogsAsyncDownload.
type GetApi217LogsAsyncDownloadParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217MaintenanceWindowsParams defines parameters for DeleteApi217MaintenanceWindows.
type DeleteApi217MaintenanceWindowsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217MaintenanceWindowsParams defines parameters for GetApi217MaintenanceWindows.
type GetApi217MaintenanceWindowsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217MaintenanceWindowsParams defines parameters for PostApi217MaintenanceWindows.
type PostApi217MaintenanceWindowsParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkAccessPoliciesParams defines parameters for GetApi217NetworkAccessPolicies.
type GetApi217NetworkAccessPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217NetworkAccessPoliciesParams defines parameters for PatchApi217NetworkAccessPolicies.
type PatchApi217NetworkAccessPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkAccessPoliciesMembersParams defines parameters for GetApi217NetworkAccessPoliciesMembers.
type GetApi217NetworkAccessPoliciesMembersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217NetworkAccessPoliciesRulesParams defines parameters for DeleteApi217NetworkAccessPoliciesRules.
type DeleteApi217NetworkAccessPoliciesRulesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkAccessPoliciesRulesParams defines parameters for GetApi217NetworkAccessPoliciesRules.
type GetApi217NetworkAccessPoliciesRulesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217NetworkAccessPoliciesRulesParams defines parameters for PatchApi217NetworkAccessPoliciesRules.
type PatchApi217NetworkAccessPoliciesRulesParams struct {
	// BeforeRuleId The id of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_name` query parameter.
	BeforeRuleId *BeforeRuleId `form:"before_rule_id,omitempty" json:"before_rule_id,omitempty"`

	// BeforeRuleName The name of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_id` query parameter.
	BeforeRuleName *BeforeRuleName `form:"before_rule_name,omitempty" json:"before_rule_name,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217NetworkAccessPoliciesRulesParams defines parameters for PostApi217NetworkAccessPoliciesRules.
type PostApi217NetworkAccessPoliciesRulesParams struct {
	// BeforeRuleId The id of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_name` query parameter.
	BeforeRuleId *BeforeRuleId `form:"before_rule_id,omitempty" json:"before_rule_id,omitempty"`

	// BeforeRuleName The name of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_id` query parameter.
	BeforeRuleName *BeforeRuleName `form:"before_rule_name,omitempty" json:"before_rule_name,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217NetworkInterfacesParams defines parameters for DeleteApi217NetworkInterfaces.
type DeleteApi217NetworkInterfacesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkInterfacesParams defines parameters for GetApi217NetworkInterfaces.
type GetApi217NetworkInterfacesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217NetworkInterfacesParams defines parameters for PatchApi217NetworkInterfaces.
type PatchApi217NetworkInterfacesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217NetworkInterfacesParams defines parameters for PostApi217NetworkInterfaces.
type PostApi217NetworkInterfacesParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkInterfacesConnectorsParams defines parameters for GetApi217NetworkInterfacesConnectors.
type GetApi217NetworkInterfacesConnectorsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217NetworkInterfacesConnectorsParams defines parameters for PatchApi217NetworkInterfacesConnectors.
type PatchApi217NetworkInterfacesConnectorsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkInterfacesConnectorsPerformanceParams defines parameters for GetApi217NetworkInterfacesConnectorsPerformance.
type GetApi217NetworkInterfacesConnectorsPerformanceParams struct {
	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkInterfacesConnectorsSettingsParams defines parameters for GetApi217NetworkInterfacesConnectorsSettings.
type GetApi217NetworkInterfacesConnectorsSettingsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkInterfacesPingParams defines parameters for GetApi217NetworkInterfacesPing.
type GetApi217NetworkInterfacesPingParams struct {
	// ComponentName Used by ping and trace to specify where to run the operation. Valid values are controllers
	// and blades from hardware list.
	// If not specified, defaults to all available controllers and selected blades.
	ComponentName *PingTraceComponent `form:"component_name,omitempty" json:"component_name,omitempty"`

	// Count Used by ping to specify the number of packets to send.
	// If not specified, defaults to 1.
	Count *PingCount `form:"count,omitempty" json:"count,omitempty"`

	// Destination A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.
	Destination PingTraceDestination `form:"destination" json:"destination"`

	// PacketSize Used by ping to specify the number of data bytes to be sent per packet.
	// If not specified, defaults to 56.
	PacketSize *PacketSize `form:"packet_size,omitempty" json:"packet_size,omitempty"`

	// PrintLatency Used by ping to specify whether or not to print
	// the full user-to-user latency. If not specified, defaults to false.
	PrintLatency *PrintLatency `form:"print_latency,omitempty" json:"print_latency,omitempty"`

	// ResolveHostname Used by ping and trace to specify whether or not to
	// map IP addresses to host names. If not specified, defaults to true.
	ResolveHostname *ResolveHostname `form:"resolve_hostname,omitempty" json:"resolve_hostname,omitempty"`

	// Source Used by ping and trace to specify the property where to start
	// to run the specified operation. The property can be subnet or
	// IP.
	Source *PingTraceSource `form:"source,omitempty" json:"source,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217NetworkInterfacesTlsPoliciesParams defines parameters for DeleteApi217NetworkInterfacesTlsPolicies.
type DeleteApi217NetworkInterfacesTlsPoliciesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkInterfacesTlsPoliciesParams defines parameters for GetApi217NetworkInterfacesTlsPolicies.
type GetApi217NetworkInterfacesTlsPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217NetworkInterfacesTlsPoliciesParams defines parameters for PostApi217NetworkInterfacesTlsPolicies.
type PostApi217NetworkInterfacesTlsPoliciesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NetworkInterfacesTraceParams defines parameters for GetApi217NetworkInterfacesTrace.
type GetApi217NetworkInterfacesTraceParams struct {
	// ComponentName Used by ping and trace to specify where to run the operation. Valid values are controllers
	// and blades from hardware list.
	// If not specified, defaults to all available controllers and selected blades.
	ComponentName *PingTraceComponent `form:"component_name,omitempty" json:"component_name,omitempty"`

	// Destination A destination specified by user to run the network diagnosis against. Can be a hostname or an IP.
	Destination PingTraceDestination `form:"destination" json:"destination"`

	// DiscoverMtu Used by trace to specify whether or not to discover
	// the MTU along the path being traced. If not specified, defaults to false.
	DiscoverMtu *Mtu `form:"discover_mtu,omitempty" json:"discover_mtu,omitempty"`

	// FragmentPacket Used by trace to specify whether or not to
	// fragment packets. If not specified, defaults to true.
	FragmentPacket *FragmentPacket `form:"fragment_packet,omitempty" json:"fragment_packet,omitempty"`

	// Method Used by trace to specify which method to use for trace operations. Valid
	// values are `icmp`, `tcp`, and `udp`. If not specified, defaults to 'udp'.
	Method *Method `form:"method,omitempty" json:"method,omitempty"`

	// Port Used by trace to specify a destination port.
	Port *Port `form:"port,omitempty" json:"port,omitempty"`

	// ResolveHostname Used by ping and trace to specify whether or not to
	// map IP addresses to host names. If not specified, defaults to true.
	ResolveHostname *ResolveHostname `form:"resolve_hostname,omitempty" json:"resolve_hostname,omitempty"`

	// Source Used by ping and trace to specify the property where to start
	// to run the specified operation. The property can be subnet or
	// IP.
	Source *PingTraceSource `form:"source,omitempty" json:"source,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217NfsExportPoliciesParams defines parameters for DeleteApi217NfsExportPolicies.
type DeleteApi217NfsExportPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NfsExportPoliciesParams defines parameters for GetApi217NfsExportPolicies.
type GetApi217NfsExportPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217NfsExportPoliciesParams defines parameters for PatchApi217NfsExportPolicies.
type PatchApi217NfsExportPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217NfsExportPoliciesParams defines parameters for PostApi217NfsExportPolicies.
type PostApi217NfsExportPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217NfsExportPoliciesRulesParams defines parameters for DeleteApi217NfsExportPoliciesRules.
type DeleteApi217NfsExportPoliciesRulesParams struct {
	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217NfsExportPoliciesRulesParams defines parameters for GetApi217NfsExportPoliciesRules.
type GetApi217NfsExportPoliciesRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217NfsExportPoliciesRulesParams defines parameters for PatchApi217NfsExportPoliciesRules.
type PatchApi217NfsExportPoliciesRulesParams struct {
	// BeforeRuleId The id of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_name` query parameter.
	BeforeRuleId *BeforeRuleId `form:"before_rule_id,omitempty" json:"before_rule_id,omitempty"`

	// BeforeRuleName The name of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_id` query parameter.
	BeforeRuleName *BeforeRuleName `form:"before_rule_name,omitempty" json:"before_rule_name,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217NfsExportPoliciesRulesParams defines parameters for PostApi217NfsExportPoliciesRules.
type PostApi217NfsExportPoliciesRulesParams struct {
	// BeforeRuleId The id of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_name` query parameter.
	BeforeRuleId *BeforeRuleId `form:"before_rule_id,omitempty" json:"before_rule_id,omitempty"`

	// BeforeRuleName The name of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_id` query parameter.
	BeforeRuleName *BeforeRuleName `form:"before_rule_name,omitempty" json:"before_rule_name,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreAccessKeysParams defines parameters for DeleteApi217ObjectStoreAccessKeys.
type DeleteApi217ObjectStoreAccessKeysParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreAccessKeysParams defines parameters for GetApi217ObjectStoreAccessKeys.
type GetApi217ObjectStoreAccessKeysParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreAccessKeysParams defines parameters for PatchApi217ObjectStoreAccessKeys.
type PatchApi217ObjectStoreAccessKeysParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreAccessKeysParams defines parameters for PostApi217ObjectStoreAccessKeys.
type PostApi217ObjectStoreAccessKeysParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names to import.
	// To import a set of credentials, this field must be specified
	// with the `secret_access_key` body parameter. If both of these
	// are not specified, the system will generate a new set of credentials.
	Names *AccessKeyNames `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreAccessPoliciesParams defines parameters for DeleteApi217ObjectStoreAccessPolicies.
type DeleteApi217ObjectStoreAccessPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreAccessPoliciesParams defines parameters for GetApi217ObjectStoreAccessPolicies.
type GetApi217ObjectStoreAccessPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// ExcludeRules If true, the rules field in each policy will be null.
	// If false, each returned policy will include its list of rules in the response.
	// If not specified, defaults to `false`.
	ExcludeRules *ExcludeRules `form:"exclude_rules,omitempty" json:"exclude_rules,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreAccessPoliciesParams defines parameters for PatchApi217ObjectStoreAccessPolicies.
type PatchApi217ObjectStoreAccessPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EnforceActionRestrictions Certain combinations of actions and other rule elements are inherently ignored
	// if specified together in a rule.
	// If set to `true`, operations which attempt to set these combinations will
	// fail.
	// If set to `false`, such operations will instead be allowed.
	// Defaults to `true`.
	EnforceActionRestrictions *EnforceActionRestrictions `form:"enforce_action_restrictions,omitempty" json:"enforce_action_restrictions,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreAccessPoliciesParams defines parameters for PostApi217ObjectStoreAccessPolicies.
type PostApi217ObjectStoreAccessPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EnforceActionRestrictions Certain combinations of actions and other rule elements are inherently ignored
	// if specified together in a rule.
	// If set to `true`, operations which attempt to set these combinations will
	// fail.
	// If set to `false`, such operations will instead be allowed.
	// Defaults to `true`.
	EnforceActionRestrictions *EnforceActionRestrictions `form:"enforce_action_restrictions,omitempty" json:"enforce_action_restrictions,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesParams defines parameters for DeleteApi217ObjectStoreAccessPoliciesObjectStoreRoles.
type DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreAccessPoliciesObjectStoreRolesParams defines parameters for GetApi217ObjectStoreAccessPoliciesObjectStoreRoles.
type GetApi217ObjectStoreAccessPoliciesObjectStoreRolesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreAccessPoliciesObjectStoreRolesParams defines parameters for PostApi217ObjectStoreAccessPoliciesObjectStoreRoles.
type PostApi217ObjectStoreAccessPoliciesObjectStoreRolesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersParams defines parameters for DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsers.
type DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreAccessPoliciesObjectStoreUsersParams defines parameters for GetApi217ObjectStoreAccessPoliciesObjectStoreUsers.
type GetApi217ObjectStoreAccessPoliciesObjectStoreUsersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreAccessPoliciesObjectStoreUsersParams defines parameters for PostApi217ObjectStoreAccessPoliciesObjectStoreUsers.
type PostApi217ObjectStoreAccessPoliciesObjectStoreUsersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreAccessPoliciesRulesParams defines parameters for DeleteApi217ObjectStoreAccessPoliciesRules.
type DeleteApi217ObjectStoreAccessPoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreAccessPoliciesRulesParams defines parameters for GetApi217ObjectStoreAccessPoliciesRules.
type GetApi217ObjectStoreAccessPoliciesRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreAccessPoliciesRulesParams defines parameters for PatchApi217ObjectStoreAccessPoliciesRules.
type PatchApi217ObjectStoreAccessPoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EnforceActionRestrictions Certain combinations of actions and other rule elements are inherently ignored
	// if specified together in a rule.
	// If set to `true`, operations which attempt to set these combinations will
	// fail.
	// If set to `false`, such operations will instead be allowed.
	// Defaults to `true`.
	EnforceActionRestrictions *EnforceActionRestrictions `form:"enforce_action_restrictions,omitempty" json:"enforce_action_restrictions,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreAccessPoliciesRulesParams defines parameters for PostApi217ObjectStoreAccessPoliciesRules.
type PostApi217ObjectStoreAccessPoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// EnforceActionRestrictions Certain combinations of actions and other rule elements are inherently ignored
	// if specified together in a rule.
	// If set to `true`, operations which attempt to set these combinations will
	// fail.
	// If set to `false`, such operations will instead be allowed.
	// Defaults to `true`.
	EnforceActionRestrictions *EnforceActionRestrictions `form:"enforce_action_restrictions,omitempty" json:"enforce_action_restrictions,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreAccessPolicyActionsParams defines parameters for GetApi217ObjectStoreAccessPolicyActions.
type GetApi217ObjectStoreAccessPolicyActionsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreAccountsParams defines parameters for DeleteApi217ObjectStoreAccounts.
type DeleteApi217ObjectStoreAccountsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreAccountsParams defines parameters for GetApi217ObjectStoreAccounts.
type GetApi217ObjectStoreAccountsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreAccountsParams defines parameters for PatchApi217ObjectStoreAccounts.
type PatchApi217ObjectStoreAccountsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// IgnoreUsage Allow update operations that lead to a `hard_limit_enabled` object store
	// account, bucket, or file system with usage over its limiting value.
	// For object store accounts and buckets, the limiting value is that of `quota_limit`,
	// and for file systems it is that of `provisioned`.
	// The operation can be setting `hard_limit_enabled` when usage is higher
	// than the limiting value, modifying the limiting value to a value under usage when
	// `hard_limit_enabled`, recovering a destroyed bucket of an object store account
	// that causes an account's space usage to go over its hard `quota_limit`.
	// Also allows update operations that would cause usage of the requested
	// storage class to go over its warning threshold.
	IgnoreUsage *IgnoreUsage `form:"ignore_usage,omitempty" json:"ignore_usage,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreAccountsParams defines parameters for PostApi217ObjectStoreAccounts.
type PostApi217ObjectStoreAccountsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreRemoteCredentialsParams defines parameters for DeleteApi217ObjectStoreRemoteCredentials.
type DeleteApi217ObjectStoreRemoteCredentialsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreRemoteCredentialsParams defines parameters for GetApi217ObjectStoreRemoteCredentials.
type GetApi217ObjectStoreRemoteCredentialsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreRemoteCredentialsParams defines parameters for PatchApi217ObjectStoreRemoteCredentials.
type PatchApi217ObjectStoreRemoteCredentialsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreRemoteCredentialsParams defines parameters for PostApi217ObjectStoreRemoteCredentials.
type PostApi217ObjectStoreRemoteCredentialsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreRolesParams defines parameters for DeleteApi217ObjectStoreRoles.
type DeleteApi217ObjectStoreRolesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreRolesParams defines parameters for GetApi217ObjectStoreRoles.
type GetApi217ObjectStoreRolesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreRolesParams defines parameters for PatchApi217ObjectStoreRoles.
type PatchApi217ObjectStoreRolesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreRolesParams defines parameters for PostApi217ObjectStoreRoles.
type PostApi217ObjectStoreRolesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesParams defines parameters for DeleteApi217ObjectStoreRolesObjectStoreAccessPolicies.
type DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreRolesObjectStoreAccessPoliciesParams defines parameters for GetApi217ObjectStoreRolesObjectStoreAccessPolicies.
type GetApi217ObjectStoreRolesObjectStoreAccessPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreRolesObjectStoreAccessPoliciesParams defines parameters for PostApi217ObjectStoreRolesObjectStoreAccessPolicies.
type PostApi217ObjectStoreRolesObjectStoreAccessPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesParams defines parameters for GetApi217ObjectStoreRolesObjectStoreTrustPolicies.
type GetApi217ObjectStoreRolesObjectStoreTrustPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// RoleIds A comma-separated list of object store role IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `role_names` query parameter.
	RoleIds *ObjectStoreRoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of object store role names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `role_ids` query parameter.
	RoleNames *ObjectStoreRoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadParams defines parameters for GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownload.
type GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// RoleIds A comma-separated list of object store role IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `role_names` query parameter.
	RoleIds *ObjectStoreRoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of object store role names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `role_ids` query parameter.
	RoleNames *ObjectStoreRoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams defines parameters for DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRules.
type DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Indices A comma-separated list of resource indices.
	// If there is not at least one resource that matches
	// each of the elements of `indices`, then an error is returned.
	Indices *Indices `form:"indices,omitempty" json:"indices,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RoleIds A comma-separated list of object store role IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `role_names` query parameter.
	RoleIds *ObjectStoreRoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of object store role names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `role_ids` query parameter.
	RoleNames *ObjectStoreRoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams defines parameters for GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRules.
type GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Indices A comma-separated list of resource indices.
	// If there is not at least one resource that matches
	// each of the elements of `indices`, then an error is returned.
	Indices *Indices `form:"indices,omitempty" json:"indices,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RoleIds A comma-separated list of object store role IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `role_names` query parameter.
	RoleIds *ObjectStoreRoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of object store role names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `role_ids` query parameter.
	RoleNames *ObjectStoreRoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams defines parameters for PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRules.
type PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Indices A comma-separated list of resource indices.
	// If there is not at least one resource that matches
	// each of the elements of `indices`, then an error is returned.
	Indices *Indices `form:"indices,omitempty" json:"indices,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RoleIds A comma-separated list of object store role IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `role_names` query parameter.
	RoleIds *ObjectStoreRoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of object store role names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `role_ids` query parameter.
	RoleNames *ObjectStoreRoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams defines parameters for PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRules.
type PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RoleIds A comma-separated list of object store role IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `role_names` query parameter.
	RoleIds *ObjectStoreRoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of object store role names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `role_ids` query parameter.
	RoleNames *ObjectStoreRoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams defines parameters for PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUpload.
type PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams struct {
	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// RoleIds A comma-separated list of object store role IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `role_ids`, then an error is returned.
	// This cannot be provided together with the `role_names` query parameter.
	RoleIds *ObjectStoreRoleIds `form:"role_ids,omitempty" json:"role_ids,omitempty"`

	// RoleNames A comma-separated list of object store role names.
	// If there is not at least one resource that matches
	// each of the elements of `role_names`, then an error is returned.
	// This cannot be provided together with the `role_ids` query parameter.
	RoleNames *ObjectStoreRoleNames `form:"role_names,omitempty" json:"role_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreUsersParams defines parameters for DeleteApi217ObjectStoreUsers.
type DeleteApi217ObjectStoreUsersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreUsersParams defines parameters for GetApi217ObjectStoreUsers.
type GetApi217ObjectStoreUsersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreUsersParams defines parameters for PostApi217ObjectStoreUsers.
type PostApi217ObjectStoreUsersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// FullAccess If set to `true`, creates an object store user with full permissions.
	// If set to `false`, creates an object store user with no permission.
	// If not specified, defaults to `false`.
	FullAccess *FullAccess `form:"full_access,omitempty" json:"full_access,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesParams defines parameters for DeleteApi217ObjectStoreUsersObjectStoreAccessPolicies.
type DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreUsersObjectStoreAccessPoliciesParams defines parameters for GetApi217ObjectStoreUsersObjectStoreAccessPolicies.
type GetApi217ObjectStoreUsersObjectStoreAccessPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreUsersObjectStoreAccessPoliciesParams defines parameters for PostApi217ObjectStoreUsersObjectStoreAccessPolicies.
type PostApi217ObjectStoreUsersObjectStoreAccessPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ObjectStoreVirtualHostsParams defines parameters for DeleteApi217ObjectStoreVirtualHosts.
type DeleteApi217ObjectStoreVirtualHostsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ObjectStoreVirtualHostsParams defines parameters for GetApi217ObjectStoreVirtualHosts.
type GetApi217ObjectStoreVirtualHostsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ObjectStoreVirtualHostsParams defines parameters for PostApi217ObjectStoreVirtualHosts.
type PostApi217ObjectStoreVirtualHostsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PasswordPoliciesParams defines parameters for GetApi217PasswordPolicies.
type GetApi217PasswordPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217PasswordPoliciesParams defines parameters for PatchApi217PasswordPolicies.
type PatchApi217PasswordPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217PoliciesParams defines parameters for DeleteApi217Policies.
type DeleteApi217PoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PoliciesParams defines parameters for GetApi217Policies.
type GetApi217PoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217PoliciesParams defines parameters for PatchApi217Policies.
type PatchApi217PoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// DestroySnapshots This parameter must be set to `true` in order to modify a policy such
	// that local or remote snapshots would be destroyed.
	DestroySnapshots *DestroySnapshots `form:"destroy_snapshots,omitempty" json:"destroy_snapshots,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217PoliciesParams defines parameters for PostApi217Policies.
type PostApi217PoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PoliciesAllParams defines parameters for GetApi217PoliciesAll.
type GetApi217PoliciesAllParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PoliciesAllMembersParams defines parameters for GetApi217PoliciesAllMembers.
type GetApi217PoliciesAllMembersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// MemberTypes A comma-separated list of member types. Valid values are `file-systems`,
	// `file-system-snapshots`, `file-system-replica-links`, and
	// `object-store-users`. Different endpoints may accept different subsets of
	// these values.
	MemberTypes *MemberTypes `form:"member_types,omitempty" json:"member_types,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteFileSystemIds A comma-separated list of remote file system IDs. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_names`
	// query parameter.
	RemoteFileSystemIds *RemoteFileSystemIds `form:"remote_file_system_ids,omitempty" json:"remote_file_system_ids,omitempty"`

	// RemoteFileSystemNames A comma-separated list of remote file system names. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_ids`
	// query parameter.
	RemoteFileSystemNames *RemoteFileSystemNames `form:"remote_file_system_names,omitempty" json:"remote_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217PoliciesFileSystemReplicaLinksParams defines parameters for DeleteApi217PoliciesFileSystemReplicaLinks.
type DeleteApi217PoliciesFileSystemReplicaLinksParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PoliciesFileSystemReplicaLinksParams defines parameters for GetApi217PoliciesFileSystemReplicaLinks.
type GetApi217PoliciesFileSystemReplicaLinksParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteFileSystemIds A comma-separated list of remote file system IDs. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_names`
	// query parameter.
	RemoteFileSystemIds *RemoteFileSystemIds `form:"remote_file_system_ids,omitempty" json:"remote_file_system_ids,omitempty"`

	// RemoteFileSystemNames A comma-separated list of remote file system names. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_ids`
	// query parameter.
	RemoteFileSystemNames *RemoteFileSystemNames `form:"remote_file_system_names,omitempty" json:"remote_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217PoliciesFileSystemReplicaLinksParams defines parameters for PostApi217PoliciesFileSystemReplicaLinks.
type PostApi217PoliciesFileSystemReplicaLinksParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217PoliciesFileSystemSnapshotsParams defines parameters for DeleteApi217PoliciesFileSystemSnapshots.
type DeleteApi217PoliciesFileSystemSnapshotsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PoliciesFileSystemSnapshotsParams defines parameters for GetApi217PoliciesFileSystemSnapshots.
type GetApi217PoliciesFileSystemSnapshotsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217PoliciesFileSystemsParams defines parameters for DeleteApi217PoliciesFileSystems.
type DeleteApi217PoliciesFileSystemsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PoliciesFileSystemsParams defines parameters for GetApi217PoliciesFileSystems.
type GetApi217PoliciesFileSystemsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217PoliciesFileSystemsParams defines parameters for PostApi217PoliciesFileSystems.
type PostApi217PoliciesFileSystemsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PoliciesMembersParams defines parameters for GetApi217PoliciesMembers.
type GetApi217PoliciesMembersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LocalFileSystemIds A comma-separated list of local file system IDs. If after filtering,
	// there is not at least one resource that matches each of the elements,
	// then an error is returned. This cannot be provided together with the
	// `local_file_system_names` query parameter.
	LocalFileSystemIds *LocalFileSystemIds `form:"local_file_system_ids,omitempty" json:"local_file_system_ids,omitempty"`

	// LocalFileSystemNames A comma-separated list of local file system names. If there is not
	// at least one resource that matches each of the elements, then an error
	// is returned. This cannot be provided together with `local_file_system_ids`
	// query parameter.
	LocalFileSystemNames *LocalFileSystemNames `form:"local_file_system_names,omitempty" json:"local_file_system_names,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// MemberTypes A comma-separated list of member types. Valid values are `file-systems`,
	// `file-system-snapshots`, `file-system-replica-links`, and
	// `object-store-users`. Different endpoints may accept different subsets of
	// these values.
	MemberTypes *MemberTypes `form:"member_types,omitempty" json:"member_types,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// RemoteFileSystemIds A comma-separated list of remote file system IDs. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_names`
	// query parameter.
	RemoteFileSystemIds *RemoteFileSystemIds `form:"remote_file_system_ids,omitempty" json:"remote_file_system_ids,omitempty"`

	// RemoteFileSystemNames A comma-separated list of remote file system names. If there is not at
	// least one resource that matches each of the elements, then an error is
	// returned. This cannot be provided together with the `remote_file_system_ids`
	// query parameter.
	RemoteFileSystemNames *RemoteFileSystemNames `form:"remote_file_system_names,omitempty" json:"remote_file_system_names,omitempty"`

	// RemoteIds A comma-separated list of remote array IDs. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_names` query parameter.
	RemoteIds *RemoteIds `form:"remote_ids,omitempty" json:"remote_ids,omitempty"`

	// RemoteNames A comma-separated list of remote array names. If, after filtering, there is not at least one
	// resource that matches each of the elements, then an error is returned. This cannot be provided
	// together with the `remote_ids` query parameter.
	RemoteNames *RemoteNames `form:"remote_names,omitempty" json:"remote_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217PublicKeysParams defines parameters for DeleteApi217PublicKeys.
type DeleteApi217PublicKeysParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PublicKeysParams defines parameters for GetApi217PublicKeys.
type GetApi217PublicKeysParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217PublicKeysParams defines parameters for PostApi217PublicKeys.
type PostApi217PublicKeysParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217PublicKeysUsesParams defines parameters for GetApi217PublicKeysUses.
type GetApi217PublicKeysUsesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217QosPoliciesParams defines parameters for DeleteApi217QosPolicies.
type DeleteApi217QosPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217QosPoliciesParams defines parameters for GetApi217QosPolicies.
type GetApi217QosPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217QosPoliciesParams defines parameters for PatchApi217QosPolicies.
type PatchApi217QosPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217QosPoliciesParams defines parameters for PostApi217QosPolicies.
type PostApi217QosPoliciesParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217QosPoliciesFileSystemsParams defines parameters for GetApi217QosPoliciesFileSystems.
type GetApi217QosPoliciesFileSystemsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217QosPoliciesMembersParams defines parameters for GetApi217QosPoliciesMembers.
type GetApi217QosPoliciesMembersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217QuotasGroupsParams defines parameters for DeleteApi217QuotasGroups.
type DeleteApi217QuotasGroupsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Gids A comma-separated list of group IDs.
	// If there is not at least one resource that matches
	// each of the elements of `gids`, then an error is returned.
	// This cannot be provided together with `group_names` query parameter.
	Gids *Gids `form:"gids,omitempty" json:"gids,omitempty"`

	// GroupNames A comma-separated list of group names.
	// If there is not at least one resource that matches
	// each of the elements of `group_names`, then an error is returned.
	// This cannot be provided together with `gids` query parameter.
	GroupNames *GroupNames `form:"group_names,omitempty" json:"group_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217QuotasGroupsParams defines parameters for GetApi217QuotasGroups.
type GetApi217QuotasGroupsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Gids A comma-separated list of group IDs.
	// If there is not at least one resource that matches
	// each of the elements of `gids`, then an error is returned.
	// This cannot be provided together with `group_names` query parameter.
	Gids *Gids `form:"gids,omitempty" json:"gids,omitempty"`

	// GroupNames A comma-separated list of group names.
	// If there is not at least one resource that matches
	// each of the elements of `group_names`, then an error is returned.
	// This cannot be provided together with `gids` query parameter.
	GroupNames *GroupNames `form:"group_names,omitempty" json:"group_names,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217QuotasGroupsParams defines parameters for PatchApi217QuotasGroups.
type PatchApi217QuotasGroupsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Gids A comma-separated list of group IDs.
	// If there is not at least one resource that matches
	// each of the elements of `gids`, then an error is returned.
	// This cannot be provided together with `group_names` query parameter.
	Gids *Gids `form:"gids,omitempty" json:"gids,omitempty"`

	// GroupNames A comma-separated list of group names.
	// If there is not at least one resource that matches
	// each of the elements of `group_names`, then an error is returned.
	// This cannot be provided together with `gids` query parameter.
	GroupNames *GroupNames `form:"group_names,omitempty" json:"group_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217QuotasGroupsParams defines parameters for PostApi217QuotasGroups.
type PostApi217QuotasGroupsParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Gids A comma-separated list of group IDs.
	// If there is not at least one resource that matches
	// each of the elements of `gids`, then an error is returned.
	// This cannot be provided together with `group_names` query parameter.
	Gids *Gids `form:"gids,omitempty" json:"gids,omitempty"`

	// GroupNames A comma-separated list of group names.
	// If there is not at least one resource that matches
	// each of the elements of `group_names`, then an error is returned.
	// This cannot be provided together with `gids` query parameter.
	GroupNames *GroupNames `form:"group_names,omitempty" json:"group_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217QuotasSettingsParams defines parameters for GetApi217QuotasSettings.
type GetApi217QuotasSettingsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217QuotasSettingsParams defines parameters for PatchApi217QuotasSettings.
type PatchApi217QuotasSettingsParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217QuotasUsersParams defines parameters for DeleteApi217QuotasUsers.
type DeleteApi217QuotasUsersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Uids A comma-separated list of user IDs.
	// If there is not at least one resource that matches
	// each of the elements of `uids`, then an error is returned.
	// This cannot be provided together with `user_names` query parameter.
	Uids *Uids `form:"uids,omitempty" json:"uids,omitempty"`

	// UserNames A comma-separated list of user names.
	// If there is not at least one resource that matches
	// each of the elements of `user_names`, then an error is returned.
	// This cannot be provided together with `uids` query parameter.
	UserNames *UserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217QuotasUsersParams defines parameters for GetApi217QuotasUsers.
type GetApi217QuotasUsersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Uids A comma-separated list of user IDs.
	// If there is not at least one resource that matches
	// each of the elements of `uids`, then an error is returned.
	// This cannot be provided together with `user_names` query parameter.
	Uids *Uids `form:"uids,omitempty" json:"uids,omitempty"`

	// UserNames A comma-separated list of user names.
	// If there is not at least one resource that matches
	// each of the elements of `user_names`, then an error is returned.
	// This cannot be provided together with `uids` query parameter.
	UserNames *UserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217QuotasUsersParams defines parameters for PatchApi217QuotasUsers.
type PatchApi217QuotasUsersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Uids A comma-separated list of user IDs.
	// If there is not at least one resource that matches
	// each of the elements of `uids`, then an error is returned.
	// This cannot be provided together with `user_names` query parameter.
	Uids *Uids `form:"uids,omitempty" json:"uids,omitempty"`

	// UserNames A comma-separated list of user names.
	// If there is not at least one resource that matches
	// each of the elements of `user_names`, then an error is returned.
	// This cannot be provided together with `uids` query parameter.
	UserNames *UserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217QuotasUsersParams defines parameters for PostApi217QuotasUsers.
type PostApi217QuotasUsersParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Uids A comma-separated list of user IDs.
	// If there is not at least one resource that matches
	// each of the elements of `uids`, then an error is returned.
	// This cannot be provided together with `user_names` query parameter.
	Uids *Uids `form:"uids,omitempty" json:"uids,omitempty"`

	// UserNames A comma-separated list of user names.
	// If there is not at least one resource that matches
	// each of the elements of `user_names`, then an error is returned.
	// This cannot be provided together with `uids` query parameter.
	UserNames *UserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217RapidDataLockingParams defines parameters for GetApi217RapidDataLocking.
type GetApi217RapidDataLockingParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217RapidDataLockingParams defines parameters for PatchApi217RapidDataLocking.
type PatchApi217RapidDataLockingParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217RapidDataLockingRotateParams defines parameters for PostApi217RapidDataLockingRotate.
type PostApi217RapidDataLockingRotateParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217RapidDataLockingTestParams defines parameters for GetApi217RapidDataLockingTest.
type GetApi217RapidDataLockingTestParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217RemoteArraysParams defines parameters for GetApi217RemoteArrays.
type GetApi217RemoteArraysParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// CurrentFleetOnly If current_fleet_only is specified, then results will only show arrays from the same fleet to
	// which the current array is a member of.
	CurrentFleetOnly *bool `form:"current_fleet_only,omitempty" json:"current_fleet_only,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217RolesParams defines parameters for GetApi217Roles.
type GetApi217RolesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217ServersParams defines parameters for DeleteApi217Servers.
type DeleteApi217ServersParams struct {
	// CascadeDelete The resource types to delete when deleting this object. It will fail if the resources are
	// referenced by other objects.
	// Valid values include `directory-services`.
	CascadeDelete CascadeDelete `form:"cascade_delete" json:"cascade_delete"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217ServersParams defines parameters for GetApi217Servers.
type GetApi217ServersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ServersParams defines parameters for PatchApi217Servers.
type PatchApi217ServersParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217ServersParams defines parameters for PostApi217Servers.
type PostApi217ServersParams struct {
	// CreateDs The name of the directory service object to create used for NFS access to this server.
	// The name must be the server `name` followed by _nfs.
	CreateDs CreateDs `form:"create_ds" json:"create_ds"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SessionsParams defines parameters for GetApi217Sessions.
type GetApi217SessionsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SmbClientPoliciesParams defines parameters for DeleteApi217SmbClientPolicies.
type DeleteApi217SmbClientPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SmbClientPoliciesParams defines parameters for GetApi217SmbClientPolicies.
type GetApi217SmbClientPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SmbClientPoliciesParams defines parameters for PatchApi217SmbClientPolicies.
type PatchApi217SmbClientPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SmbClientPoliciesParams defines parameters for PostApi217SmbClientPolicies.
type PostApi217SmbClientPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SmbClientPoliciesRulesParams defines parameters for DeleteApi217SmbClientPoliciesRules.
type DeleteApi217SmbClientPoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SmbClientPoliciesRulesParams defines parameters for GetApi217SmbClientPoliciesRules.
type GetApi217SmbClientPoliciesRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SmbClientPoliciesRulesParams defines parameters for PatchApi217SmbClientPoliciesRules.
type PatchApi217SmbClientPoliciesRulesParams struct {
	// BeforeRuleId The id of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_name` query parameter.
	BeforeRuleId *BeforeRuleId `form:"before_rule_id,omitempty" json:"before_rule_id,omitempty"`

	// BeforeRuleName The name of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_id` query parameter.
	BeforeRuleName *BeforeRuleName `form:"before_rule_name,omitempty" json:"before_rule_name,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SmbClientPoliciesRulesParams defines parameters for PostApi217SmbClientPoliciesRules.
type PostApi217SmbClientPoliciesRulesParams struct {
	// BeforeRuleId The id of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_name` query parameter.
	BeforeRuleId *BeforeRuleId `form:"before_rule_id,omitempty" json:"before_rule_id,omitempty"`

	// BeforeRuleName The name of the rule to insert or move a rule before.
	// This cannot be provided together with the `before_rule_id` query parameter.
	BeforeRuleName *BeforeRuleName `form:"before_rule_name,omitempty" json:"before_rule_name,omitempty"`

	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Versions A comma-separated list of versions. This is an optional query param used for concurrency control.
	// The ordering should match the names or ids query param.
	// This will fail with a 412 Precondition failed if the resource was changed and the current
	// version of the resource doesn't match the value in the query param.
	Versions *Versions `form:"versions,omitempty" json:"versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SmbSharePoliciesParams defines parameters for DeleteApi217SmbSharePolicies.
type DeleteApi217SmbSharePoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SmbSharePoliciesParams defines parameters for GetApi217SmbSharePolicies.
type GetApi217SmbSharePoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SmbSharePoliciesParams defines parameters for PatchApi217SmbSharePolicies.
type PatchApi217SmbSharePoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SmbSharePoliciesParams defines parameters for PostApi217SmbSharePolicies.
type PostApi217SmbSharePoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SmbSharePoliciesRulesParams defines parameters for DeleteApi217SmbSharePoliciesRules.
type DeleteApi217SmbSharePoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SmbSharePoliciesRulesParams defines parameters for GetApi217SmbSharePoliciesRules.
type GetApi217SmbSharePoliciesRulesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SmbSharePoliciesRulesParams defines parameters for PatchApi217SmbSharePoliciesRules.
type PatchApi217SmbSharePoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SmbSharePoliciesRulesParams defines parameters for PostApi217SmbSharePoliciesRules.
type PostApi217SmbSharePoliciesRulesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SmtpServersParams defines parameters for GetApi217SmtpServers.
type GetApi217SmtpServersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SmtpServersParams defines parameters for PatchApi217SmtpServers.
type PatchApi217SmtpServersParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SnmpAgentsParams defines parameters for GetApi217SnmpAgents.
type GetApi217SnmpAgentsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SnmpAgentsParams defines parameters for PatchApi217SnmpAgents.
type PatchApi217SnmpAgentsParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SnmpAgentsMibParams defines parameters for GetApi217SnmpAgentsMib.
type GetApi217SnmpAgentsMibParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SnmpManagersParams defines parameters for DeleteApi217SnmpManagers.
type DeleteApi217SnmpManagersParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SnmpManagersParams defines parameters for GetApi217SnmpManagers.
type GetApi217SnmpManagersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SnmpManagersParams defines parameters for PatchApi217SnmpManagers.
type PatchApi217SnmpManagersParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SnmpManagersParams defines parameters for PostApi217SnmpManagers.
type PostApi217SnmpManagersParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SnmpManagersTestParams defines parameters for GetApi217SnmpManagersTest.
type GetApi217SnmpManagersTestParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SoftwareCheckParams defines parameters for GetApi217SoftwareCheck.
type GetApi217SoftwareCheckParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// SoftwareNames A comma-separated list of software names.
	SoftwareNames *SoftwareNames `form:"software_names,omitempty" json:"software_names,omitempty"`

	// SoftwareVersions A comma-separated list of target software versions.
	SoftwareVersions *SoftwareVersions `form:"software_versions,omitempty" json:"software_versions,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TotalItemCount If set to `true`, the `total_item_count` matching the
	// specified query parameters is calculated and returned in
	// the response. If set to `false`, the `total_item_count`
	// is `null` in the response. This may speed up queries
	// where the `total_item_count` is large. If not specified,
	// defaults to `false`.
	TotalItemCount *TotalItemCount `form:"total_item_count,omitempty" json:"total_item_count,omitempty"`
}

// PostApi217SoftwareCheckParams defines parameters for PostApi217SoftwareCheck.
type PostApi217SoftwareCheckParams struct {
	// SoftwareNames A comma-separated list of software names.
	SoftwareNames *SoftwareNames `form:"software_names,omitempty" json:"software_names,omitempty"`

	// SoftwareVersions A comma-separated list of target software versions.
	SoftwareVersions *SoftwareVersions `form:"software_versions,omitempty" json:"software_versions,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SshCertificateAuthorityPoliciesParams defines parameters for DeleteApi217SshCertificateAuthorityPolicies.
type DeleteApi217SshCertificateAuthorityPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SshCertificateAuthorityPoliciesParams defines parameters for GetApi217SshCertificateAuthorityPolicies.
type GetApi217SshCertificateAuthorityPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SshCertificateAuthorityPoliciesParams defines parameters for PatchApi217SshCertificateAuthorityPolicies.
type PatchApi217SshCertificateAuthorityPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SshCertificateAuthorityPoliciesParams defines parameters for PostApi217SshCertificateAuthorityPolicies.
type PostApi217SshCertificateAuthorityPoliciesParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SshCertificateAuthorityPoliciesAdminsParams defines parameters for DeleteApi217SshCertificateAuthorityPoliciesAdmins.
type DeleteApi217SshCertificateAuthorityPoliciesAdminsParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SshCertificateAuthorityPoliciesAdminsParams defines parameters for GetApi217SshCertificateAuthorityPoliciesAdmins.
type GetApi217SshCertificateAuthorityPoliciesAdminsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SshCertificateAuthorityPoliciesAdminsParams defines parameters for PostApi217SshCertificateAuthorityPoliciesAdmins.
type PostApi217SshCertificateAuthorityPoliciesAdminsParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SshCertificateAuthorityPoliciesArraysParams defines parameters for DeleteApi217SshCertificateAuthorityPoliciesArrays.
type DeleteApi217SshCertificateAuthorityPoliciesArraysParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SshCertificateAuthorityPoliciesArraysParams defines parameters for GetApi217SshCertificateAuthorityPoliciesArrays.
type GetApi217SshCertificateAuthorityPoliciesArraysParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SshCertificateAuthorityPoliciesArraysParams defines parameters for PostApi217SshCertificateAuthorityPoliciesArrays.
type PostApi217SshCertificateAuthorityPoliciesArraysParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SshCertificateAuthorityPoliciesMembersParams defines parameters for GetApi217SshCertificateAuthorityPoliciesMembers.
type GetApi217SshCertificateAuthorityPoliciesMembersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SsoOidcIdpsParams defines parameters for DeleteApi217SsoOidcIdps.
type DeleteApi217SsoOidcIdpsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SsoOidcIdpsParams defines parameters for GetApi217SsoOidcIdps.
type GetApi217SsoOidcIdpsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SsoOidcIdpsParams defines parameters for PatchApi217SsoOidcIdps.
type PatchApi217SsoOidcIdpsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SsoOidcIdpsParams defines parameters for PostApi217SsoOidcIdps.
type PostApi217SsoOidcIdpsParams struct {
	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SsoSaml2IdpsParams defines parameters for DeleteApi217SsoSaml2Idps.
type DeleteApi217SsoSaml2IdpsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SsoSaml2IdpsParams defines parameters for GetApi217SsoSaml2Idps.
type GetApi217SsoSaml2IdpsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SsoSaml2IdpsParams defines parameters for PatchApi217SsoSaml2Idps.
type PatchApi217SsoSaml2IdpsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SsoSaml2IdpsParams defines parameters for PostApi217SsoSaml2Idps.
type PostApi217SsoSaml2IdpsParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SsoSaml2IdpsTestParams defines parameters for GetApi217SsoSaml2IdpsTest.
type GetApi217SsoSaml2IdpsTestParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SsoSaml2IdpsTestParams defines parameters for PatchApi217SsoSaml2IdpsTest.
type PatchApi217SsoSaml2IdpsTestParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SubnetsParams defines parameters for DeleteApi217Subnets.
type DeleteApi217SubnetsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SubnetsParams defines parameters for GetApi217Subnets.
type GetApi217SubnetsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SubnetsParams defines parameters for PatchApi217Subnets.
type PatchApi217SubnetsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SubnetsParams defines parameters for PostApi217Subnets.
type PostApi217SubnetsParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SupportParams defines parameters for GetApi217Support.
type GetApi217SupportParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SupportParams defines parameters for PatchApi217Support.
type PatchApi217SupportParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SupportDiagnosticsParams defines parameters for GetApi217SupportDiagnostics.
type GetApi217SupportDiagnosticsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SupportDiagnosticsParams defines parameters for PostApi217SupportDiagnostics.
type PostApi217SupportDiagnosticsParams struct {
	// AnalysisPeriodEndTime When the analysis time window ends (in milliseconds since epoch).
	AnalysisPeriodEndTime *AnalysisPeriodEndTime `form:"analysis_period_end_time,omitempty" json:"analysis_period_end_time,omitempty"`

	// AnalysisPeriodStartTime When the analysis time window starts (in milliseconds since epoch).
	AnalysisPeriodStartTime *AnalysisPeriodStartTime `form:"analysis_period_start_time,omitempty" json:"analysis_period_start_time,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SupportDiagnosticsDetailsParams defines parameters for GetApi217SupportDiagnosticsDetails.
type GetApi217SupportDiagnosticsDetailsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SupportTestParams defines parameters for GetApi217SupportTest.
type GetApi217SupportTestParams struct {
	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// TestType Specifies the type of test. Valid values are `all`, `phonehome`, and `remote-assist`.
	// If not specified, defaults to `all`.
	TestType *TestType `form:"test_type,omitempty" json:"test_type,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SupportVerificationKeysParams defines parameters for GetApi217SupportVerificationKeys.
type GetApi217SupportVerificationKeysParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SupportVerificationKeysParams defines parameters for PatchApi217SupportVerificationKeys.
type PatchApi217SupportVerificationKeysParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217SyslogServersParams defines parameters for DeleteApi217SyslogServers.
type DeleteApi217SyslogServersParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names Performs the operation on the unique name specified.
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	Names *NamesForSyslog `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SyslogServersParams defines parameters for GetApi217SyslogServers.
type GetApi217SyslogServersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names Performs the operation on the unique name specified.
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	Names *NamesForSyslog `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SyslogServersParams defines parameters for PatchApi217SyslogServers.
type PatchApi217SyslogServersParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names Performs the operation on the unique name specified.
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	Names *NamesForSyslog `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217SyslogServersParams defines parameters for PostApi217SyslogServers.
type PostApi217SyslogServersParams struct {
	// Names Performs the operation on the unique name specified.
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	Names *NamesForSyslog `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SyslogServersSettingsParams defines parameters for GetApi217SyslogServersSettings.
type GetApi217SyslogServersSettingsParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217SyslogServersSettingsParams defines parameters for PatchApi217SyslogServersSettings.
type PatchApi217SyslogServersSettingsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217SyslogServersTestParams defines parameters for GetApi217SyslogServersTest.
type GetApi217SyslogServersTestParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217TargetsParams defines parameters for DeleteApi217Targets.
type DeleteApi217TargetsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217TargetsParams defines parameters for GetApi217Targets.
type GetApi217TargetsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217TargetsParams defines parameters for PatchApi217Targets.
type PatchApi217TargetsParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217TargetsParams defines parameters for PostApi217Targets.
type PostApi217TargetsParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217TargetsPerformanceReplicationParams defines parameters for GetApi217TargetsPerformanceReplication.
type GetApi217TargetsPerformanceReplicationParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// EndTime When the time window ends (in milliseconds since epoch).
	EndTime *EndTime `form:"end_time,omitempty" json:"end_time,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Resolution The desired ms between samples. Available resolutions may
	// depend on data type, `start_time` and `end_time`.
	// In general `1000`, `30000`, `300000`, `1800000`, `7200000`, and
	// `86400000` are possible values.
	Resolution *Resolution `form:"resolution,omitempty" json:"resolution,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// StartTime When the time window starts (in milliseconds since epoch).
	StartTime *StartTime `form:"start_time,omitempty" json:"start_time,omitempty"`

	// TotalOnly If set to `true`, returns the aggregate value of all items after filtering.
	// Where it makes more sense, the average value is displayed instead.
	// The values are displayed for each name where meaningful.
	// If `total_only=true`, the `items` list will be empty.
	TotalOnly *TotalOnly `form:"total_only,omitempty" json:"total_only,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217TlsPoliciesParams defines parameters for DeleteApi217TlsPolicies.
type DeleteApi217TlsPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217TlsPoliciesParams defines parameters for GetApi217TlsPolicies.
type GetApi217TlsPoliciesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Effective If `true`, then the TLS policies returned will be fully evaluated. This
	// involves expanding shortened TLS ciphers, removing disabled TLS ciphers from
	// the list of expanded enabled TLS ciphers, and converting values such as
	// `default` and `legacy` into concrete values, in order to return the discrete
	// effective TLS settings that the policies encode.
	// Defaults to `false`.
	Effective *EffectiveTlsPolicy `form:"effective,omitempty" json:"effective,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PurityDefined If `true`, then the results returned will be include the specification
	// for purity-defined values on the current purity version. These values
	// may be used in configurations in order to dynamically adopt new behavior
	// across upgrades, and this option allows the exact behavior for the current
	// version to be returned.
	// Defaults to `false`.
	PurityDefined *PurityDefined `form:"purity_defined,omitempty" json:"purity_defined,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217TlsPoliciesParams defines parameters for PatchApi217TlsPolicies.
type PatchApi217TlsPoliciesParams struct {
	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217TlsPoliciesParams defines parameters for PostApi217TlsPolicies.
type PostApi217TlsPoliciesParams struct {
	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217TlsPoliciesMembersParams defines parameters for GetApi217TlsPoliciesMembers.
type GetApi217TlsPoliciesMembersParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217TlsPoliciesNetworkInterfacesParams defines parameters for DeleteApi217TlsPoliciesNetworkInterfaces.
type DeleteApi217TlsPoliciesNetworkInterfacesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217TlsPoliciesNetworkInterfacesParams defines parameters for GetApi217TlsPoliciesNetworkInterfaces.
type GetApi217TlsPoliciesNetworkInterfacesParams struct {
	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217TlsPoliciesNetworkInterfacesParams defines parameters for PostApi217TlsPoliciesNetworkInterfaces.
type PostApi217TlsPoliciesNetworkInterfacesParams struct {
	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217UsageGroupsParams defines parameters for GetApi217UsageGroups.
type GetApi217UsageGroupsParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Gids A comma-separated list of group IDs.
	// If there is not at least one resource that matches
	// each of the elements of `gids`, then an error is returned.
	// This cannot be provided together with `group_names` query parameter.
	Gids *Gids `form:"gids,omitempty" json:"gids,omitempty"`

	// GroupNames A comma-separated list of group names.
	// If there is not at least one resource that matches
	// each of the elements of `group_names`, then an error is returned.
	// This cannot be provided together with `gids` query parameter.
	GroupNames *GroupNames `form:"group_names,omitempty" json:"group_names,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217UsageUsersParams defines parameters for GetApi217UsageUsers.
type GetApi217UsageUsersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// FileSystemIds A comma-separated list of file system IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `file_system_ids`, then an error is returned.
	// This cannot be provided together with the `file_system_names` query parameter.
	FileSystemIds *FileSystemIds `form:"file_system_ids,omitempty" json:"file_system_ids,omitempty"`

	// FileSystemNames A comma-separated list of file system names.
	// If there is not at least one resource that matches
	// each of the elements of `file_system_names`, then an error is returned.
	FileSystemNames *FileSystemNames `form:"file_system_names,omitempty" json:"file_system_names,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// Uids A comma-separated list of user IDs.
	// If there is not at least one resource that matches
	// each of the elements of `uids`, then an error is returned.
	// This cannot be provided together with `user_names` query parameter.
	Uids *Uids `form:"uids,omitempty" json:"uids,omitempty"`

	// UserNames A comma-separated list of user names.
	// If there is not at least one resource that matches
	// each of the elements of `user_names`, then an error is returned.
	// This cannot be provided together with `uids` query parameter.
	UserNames *UserNames `form:"user_names,omitempty" json:"user_names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// DeleteApi217WormDataPoliciesParams defines parameters for DeleteApi217WormDataPolicies.
type DeleteApi217WormDataPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217WormDataPoliciesParams defines parameters for GetApi217WormDataPolicies.
type GetApi217WormDataPoliciesParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217WormDataPoliciesParams defines parameters for PatchApi217WormDataPolicies.
type PatchApi217WormDataPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Ids A comma-separated list of resource IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `ids`, then an error is returned.
	// This cannot be provided together with the `name` or `names` query parameters.
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Names A comma-separated list of resource names.
	// If there is not at least one resource that matches
	// each of the elements of `names`, then an error is returned.
	Names *Names `form:"names,omitempty" json:"names,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApi217WormDataPoliciesParams defines parameters for PostApi217WormDataPolicies.
type PostApi217WormDataPoliciesParams struct {
	// ContextNames Performs the operation on the context specified. If specified, the context names
	// must be an array of size 1, and the single element must be the name of an array
	// in the same fleet. If not specified, the context will default to the array that
	// received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	ContextNames *ContextNames `form:"context_names,omitempty" json:"context_names,omitempty"`

	// Names A comma-separated list of resource names.
	Names NamesRequired `form:"names" json:"names"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApi217WormDataPoliciesMembersParams defines parameters for GetApi217WormDataPoliciesMembers.
type GetApi217WormDataPoliciesMembersParams struct {
	// AllowErrors If set to `true`, the API will allow the operation to continue even if there are errors.
	// Any errors will be returned in the `errors` field of the response.
	// If set to `false`, the operation will fail if there are any errors.
	AllowErrors *AllowErrors `form:"allow_errors,omitempty" json:"allow_errors,omitempty"`

	// ContextNames Performs the operation on the unique contexts specified.
	// If specified, each context name must be the name of an array in the same fleet.
	// If not specified, the context will default to the array that received this request.
	//
	// Other parameters provided with the request, such as names of volumes or snapshots,
	// are resolved relative to the provided `context`.
	//
	// Enter multiple names in comma-separated format.
	// For example, `name01,name02`.
	ContextNames *ContextNamesGet `form:"context_names,omitempty" json:"context_names,omitempty"`

	// ContinuationToken A token used to retrieve the next page of data
	// with some consistency guaranteed.
	// The token is a Base64 encoded value.
	// Set `continuation_token` to the system-generated token taken from the `x-next-token`
	// header field of the response.
	// A query has reached its last page when the response does not include a token.
	// Pagination requires the `limit` and `continuation_token`
	// query parameters.
	ContinuationToken *ContinuationToken `form:"continuation_token,omitempty" json:"continuation_token,omitempty"`

	// Filter Narrows down the results to only the response objects
	// that satisfy the filter criteria.
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Limits the size of the response to the specified number of objects on each page.
	// To return the total number of resources, set `limit=0`.
	// The total number of resources is returned as a `total_item_count` value.
	// If the page size requested is larger than the system maximum limit,
	// the server returns the maximum limit, disregarding the requested page size.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// MemberIds A comma-separated list of member IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `member_ids`, then an error is returned.
	// This cannot be provided together with the `member_names` query parameter.
	MemberIds *MemberIds `form:"member_ids,omitempty" json:"member_ids,omitempty"`

	// MemberNames A comma-separated list of member names.
	MemberNames *MemberNames `form:"member_names,omitempty" json:"member_names,omitempty"`

	// Offset The offset of the first resource to return from a collection.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// PolicyIds A comma-separated list of policy IDs.
	// If after filtering, there is not at least one resource that matches
	// each of the elements of `policy_ids`, then an error is returned.
	// This cannot be provided together with the `policy_names` query parameter.
	PolicyIds *PolicyIds `form:"policy_ids,omitempty" json:"policy_ids,omitempty"`

	// PolicyNames A comma-separated list of policy names.
	PolicyNames *PolicyNames `form:"policy_names,omitempty" json:"policy_names,omitempty"`

	// Sort Sort the response by the specified fields (in descending order if '-'
	// is appended to the field name).
	// NOTE: If you provide a sort you will not get a `continuation_token` in
	// the response.
	Sort *Sort `form:"sort,omitempty" json:"sort,omitempty"`

	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApiApiVersionParams defines parameters for GetApiApiVersion.
type GetApiApiVersionParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApiLoginParams defines parameters for PostApiLogin.
type PostApiLoginParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// GetApiLoginBannerParams defines parameters for GetApiLoginBanner.
type GetApiLoginBannerParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostApiLogoutParams defines parameters for PostApiLogout.
type PostApiLogoutParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PostOauth210TokenFormdataBody defines parameters for PostOauth210Token.
type PostOauth210TokenFormdataBody struct {
	// GrantType The method by which the access token will be obtained.
	// The Pure Storage REST API supports the OAuth 2.0 "token exchange" grant type,
	// which indicates that a token exchange is being performed.
	// Set `grant_type` to `urn:ietf:params:oauth:grant-type:token-exchange`.
	GrantType OauthGrantType `form:"grant_type" json:"grant_type"`

	// SubjectToken An encoded security ID Token representing the identity of the party on behalf of
	// whom the request is being made. The token must be issued by a trusted
	// identity provider which must be either a registered application in Pure1
	// or an enabled API client on the array. The token must be a JSON Web Token
	// and must contain the following claims:
	//
	// > | JWT claim | Location | API Client Field | Description | Required By |
	//
	// > |-|-|-|-|-|
	//
	// > | kid | Header | key_id | Key ID of the API client that issues the identity token. | FlashArray
	// and FlashBlade only. |
	//
	// > | aud | Payload | id | Client ID of the API client that issues the identity token. | FlashArray
	// and FlashBlade only. |
	//
	// > | sub | Payload | | Login name of the array user for whom the token should be issued.
	// This must be a valid user in the system. | FlashArray and FlashBlade only. |
	//
	// > | iss | Payload | issuer | Application ID for the Pure1 or API client's trusted identity
	// issuer on the array. | All products. |
	//
	// > | iat | Payload | | Timestamp of when the identity token was issued.
	// Measured in milliseconds since the UNIX epoch. | All products. |
	//
	// > | exp | Payload | | Timestamp of when the identity token will expire.
	// Measured in milliseconds since the UNIX epoch. | All products. |
	//
	//
	// Each token must also be signed with the private key that is paired with the
	// API client's public key.
	//
	SubjectToken OauthSubjectToken `form:"subject_token" json:"subject_token"`

	// SubjectTokenType An identifier that indicates the type of security token specifed in the `subject_token` parameter.
	// The Pure Storage REST API supports the JSON Web Token (JWT)
	// as the means for requesting the access token.
	// Set `subject_token_type` to `urn:ietf:params:oauth:token-type:jwt`.
	SubjectTokenType OauthSubjectTokenType `form:"subject_token_type" json:"subject_token_type"`
}

// PostOauth210TokenParams defines parameters for PostOauth210Token.
type PostOauth210TokenParams struct {
	// XRequestID Supplied by client during request or generated by server.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`
}

// PatchApi217ActiveDirectoryJSONRequestBody defines body for PatchApi217ActiveDirectory for application/json ContentType.
type PatchApi217ActiveDirectoryJSONRequestBody = ActiveDirectoryPatch

// PostApi217ActiveDirectoryJSONRequestBody defines body for PostApi217ActiveDirectory for application/json ContentType.
type PostApi217ActiveDirectoryJSONRequestBody = ActiveDirectoryPost

// PatchApi217AdminsJSONRequestBody defines body for PatchApi217Admins for application/json ContentType.
type PatchApi217AdminsJSONRequestBody = AdminPatch

// PostApi217AdminsJSONRequestBody defines body for PostApi217Admins for application/json ContentType.
type PostApi217AdminsJSONRequestBody = AdminPost

// PatchApi217AdminsSettingsJSONRequestBody defines body for PatchApi217AdminsSettings for application/json ContentType.
type PatchApi217AdminsSettingsJSONRequestBody = AdminSetting

// PatchApi217AlertWatchersJSONRequestBody defines body for PatchApi217AlertWatchers for application/json ContentType.
type PatchApi217AlertWatchersJSONRequestBody = AlertWatcher

// PostApi217AlertWatchersJSONRequestBody defines body for PostApi217AlertWatchers for application/json ContentType.
type PostApi217AlertWatchersJSONRequestBody = AlertWatcherPost

// PatchApi217AlertsJSONRequestBody defines body for PatchApi217Alerts for application/json ContentType.
type PatchApi217AlertsJSONRequestBody = Alert

// PatchApi217ApiClientsJSONRequestBody defines body for PatchApi217ApiClients for application/json ContentType.
type PatchApi217ApiClientsJSONRequestBody = ApiClient

// PostApi217ApiClientsJSONRequestBody defines body for PostApi217ApiClients for application/json ContentType.
type PostApi217ApiClientsJSONRequestBody = ApiClientsPost

// PatchApi217ArrayConnectionsJSONRequestBody defines body for PatchApi217ArrayConnections for application/json ContentType.
type PatchApi217ArrayConnectionsJSONRequestBody = ArrayConnection

// PostApi217ArrayConnectionsJSONRequestBody defines body for PostApi217ArrayConnections for application/json ContentType.
type PostApi217ArrayConnectionsJSONRequestBody = ArrayConnectionPost

// PatchApi217ArraysJSONRequestBody defines body for PatchApi217Arrays for application/json ContentType.
type PatchApi217ArraysJSONRequestBody = Array

// PatchApi217ArraysEulaJSONRequestBody defines body for PatchApi217ArraysEula for application/json ContentType.
type PatchApi217ArraysEulaJSONRequestBody = Eula

// PatchApi217AuditFileSystemsPoliciesJSONRequestBody defines body for PatchApi217AuditFileSystemsPolicies for application/json ContentType.
type PatchApi217AuditFileSystemsPoliciesJSONRequestBody = AuditFileSystemsPoliciesPatch

// PostApi217AuditFileSystemsPoliciesJSONRequestBody defines body for PostApi217AuditFileSystemsPolicies for application/json ContentType.
type PostApi217AuditFileSystemsPoliciesJSONRequestBody = AuditFileSystemsPoliciesPost

// PatchApi217BucketReplicaLinksJSONRequestBody defines body for PatchApi217BucketReplicaLinks for application/json ContentType.
type PatchApi217BucketReplicaLinksJSONRequestBody = BucketReplicaLink

// PostApi217BucketReplicaLinksJSONRequestBody defines body for PostApi217BucketReplicaLinks for application/json ContentType.
type PostApi217BucketReplicaLinksJSONRequestBody = BucketReplicaLinkPost

// PatchApi217BucketsJSONRequestBody defines body for PatchApi217Buckets for application/json ContentType.
type PatchApi217BucketsJSONRequestBody = BucketPatch

// PostApi217BucketsJSONRequestBody defines body for PostApi217Buckets for application/json ContentType.
type PostApi217BucketsJSONRequestBody = BucketPost

// PostApi217BucketsBucketAccessPoliciesJSONRequestBody defines body for PostApi217BucketsBucketAccessPolicies for application/json ContentType.
type PostApi217BucketsBucketAccessPoliciesJSONRequestBody = BucketAccessPolicyPost

// PostApi217BucketsBucketAccessPoliciesRulesJSONRequestBody defines body for PostApi217BucketsBucketAccessPoliciesRules for application/json ContentType.
type PostApi217BucketsBucketAccessPoliciesRulesJSONRequestBody = BucketAccessPolicyRulePost

// PostApi217BucketsCrossOriginResourceSharingPoliciesJSONRequestBody defines body for PostApi217BucketsCrossOriginResourceSharingPolicies for application/json ContentType.
type PostApi217BucketsCrossOriginResourceSharingPoliciesJSONRequestBody = CrossOriginResourceSharingPolicyPatch

// PostApi217BucketsCrossOriginResourceSharingPoliciesRulesJSONRequestBody defines body for PostApi217BucketsCrossOriginResourceSharingPoliciesRules for application/json ContentType.
type PostApi217BucketsCrossOriginResourceSharingPoliciesRulesJSONRequestBody = CrossOriginResourceSharingPolicyRulePost

// PatchApi217CertificatesJSONRequestBody defines body for PatchApi217Certificates for application/json ContentType.
type PatchApi217CertificatesJSONRequestBody = CertificatePatch

// PostApi217CertificatesJSONRequestBody defines body for PostApi217Certificates for application/json ContentType.
type PostApi217CertificatesJSONRequestBody = CertificatePost

// PatchApi217DirectoryServicesJSONRequestBody defines body for PatchApi217DirectoryServices for application/json ContentType.
type PatchApi217DirectoryServicesJSONRequestBody = DirectoryService

// PatchApi217DirectoryServicesRolesJSONRequestBody defines body for PatchApi217DirectoryServicesRoles for application/json ContentType.
type PatchApi217DirectoryServicesRolesJSONRequestBody = DirectoryServiceRole

// PostApi217DirectoryServicesRolesJSONRequestBody defines body for PostApi217DirectoryServicesRoles for application/json ContentType.
type PostApi217DirectoryServicesRolesJSONRequestBody = DirectoryServiceRole

// PatchApi217DirectoryServicesTestJSONRequestBody defines body for PatchApi217DirectoryServicesTest for application/json ContentType.
type PatchApi217DirectoryServicesTestJSONRequestBody = DirectoryService

// PatchApi217DnsJSONRequestBody defines body for PatchApi217Dns for application/json ContentType.
type PatchApi217DnsJSONRequestBody = Dns

// PostApi217DnsJSONRequestBody defines body for PostApi217Dns for application/json ContentType.
type PostApi217DnsJSONRequestBody = DnsPost

// PatchApi217FileSystemExportsJSONRequestBody defines body for PatchApi217FileSystemExports for application/json ContentType.
type PatchApi217FileSystemExportsJSONRequestBody = FileSystemExport

// PostApi217FileSystemExportsJSONRequestBody defines body for PostApi217FileSystemExports for application/json ContentType.
type PostApi217FileSystemExportsJSONRequestBody = FileSystemExportPost

// PostApi217FileSystemReplicaLinksJSONRequestBody defines body for PostApi217FileSystemReplicaLinks for application/json ContentType.
type PostApi217FileSystemReplicaLinksJSONRequestBody = FileSystemReplicaLink

// PatchApi217FileSystemSnapshotsJSONRequestBody defines body for PatchApi217FileSystemSnapshots for application/json ContentType.
type PatchApi217FileSystemSnapshotsJSONRequestBody = FileSystemSnapshot

// PostApi217FileSystemSnapshotsJSONRequestBody defines body for PostApi217FileSystemSnapshots for application/json ContentType.
type PostApi217FileSystemSnapshotsJSONRequestBody = FileSystemSnapshotPost

// PatchApi217FileSystemsJSONRequestBody defines body for PatchApi217FileSystems for application/json ContentType.
type PatchApi217FileSystemsJSONRequestBody = FileSystemPatch

// PostApi217FileSystemsJSONRequestBody defines body for PostApi217FileSystems for application/json ContentType.
type PostApi217FileSystemsJSONRequestBody = FileSystemPost

// PatchApi217FleetsJSONRequestBody defines body for PatchApi217Fleets for application/json ContentType.
type PatchApi217FleetsJSONRequestBody = FleetPatch

// PostApi217FleetsMembersJSONRequestBody defines body for PostApi217FleetsMembers for application/json ContentType.
type PostApi217FleetsMembersJSONRequestBody = FleetMemberPost

// PatchApi217HardwareJSONRequestBody defines body for PatchApi217Hardware for application/json ContentType.
type PatchApi217HardwareJSONRequestBody = Hardware

// PatchApi217HardwareConnectorsJSONRequestBody defines body for PatchApi217HardwareConnectors for application/json ContentType.
type PatchApi217HardwareConnectorsJSONRequestBody = HardwareConnector

// PostApi217KeytabsJSONRequestBody defines body for PostApi217Keytabs for application/json ContentType.
type PostApi217KeytabsJSONRequestBody = KeytabPost

// PostApi217KeytabsUploadMultipartRequestBody defines body for PostApi217KeytabsUpload for multipart/form-data ContentType.
type PostApi217KeytabsUploadMultipartRequestBody PostApi217KeytabsUploadMultipartBody

// PatchApi217KmipJSONRequestBody defines body for PatchApi217Kmip for application/json ContentType.
type PatchApi217KmipJSONRequestBody = KmipServer

// PostApi217KmipJSONRequestBody defines body for PostApi217Kmip for application/json ContentType.
type PostApi217KmipJSONRequestBody = KmipServer

// PatchApi217LegalHoldsJSONRequestBody defines body for PatchApi217LegalHolds for application/json ContentType.
type PatchApi217LegalHoldsJSONRequestBody = LegalHold

// PostApi217LegalHoldsJSONRequestBody defines body for PostApi217LegalHolds for application/json ContentType.
type PostApi217LegalHoldsJSONRequestBody = LegalHold

// PatchApi217LifecycleRulesJSONRequestBody defines body for PatchApi217LifecycleRules for application/json ContentType.
type PatchApi217LifecycleRulesJSONRequestBody = LifecycleRulePatch

// PostApi217LifecycleRulesJSONRequestBody defines body for PostApi217LifecycleRules for application/json ContentType.
type PostApi217LifecycleRulesJSONRequestBody = LifecycleRulePost

// PatchApi217LinkAggregationGroupsJSONRequestBody defines body for PatchApi217LinkAggregationGroups for application/json ContentType.
type PatchApi217LinkAggregationGroupsJSONRequestBody PatchApi217LinkAggregationGroupsJSONBody

// PostApi217LinkAggregationGroupsJSONRequestBody defines body for PostApi217LinkAggregationGroups for application/json ContentType.
type PostApi217LinkAggregationGroupsJSONRequestBody = LinkAggregationGroup

// PatchApi217LogsAsyncJSONRequestBody defines body for PatchApi217LogsAsync for application/json ContentType.
type PatchApi217LogsAsyncJSONRequestBody = LogsAsync

// PostApi217MaintenanceWindowsJSONRequestBody defines body for PostApi217MaintenanceWindows for application/json ContentType.
type PostApi217MaintenanceWindowsJSONRequestBody = MaintenanceWindowPost

// PatchApi217NetworkAccessPoliciesJSONRequestBody defines body for PatchApi217NetworkAccessPolicies for application/json ContentType.
type PatchApi217NetworkAccessPoliciesJSONRequestBody = NetworkAccessPolicy

// PatchApi217NetworkAccessPoliciesRulesJSONRequestBody defines body for PatchApi217NetworkAccessPoliciesRules for application/json ContentType.
type PatchApi217NetworkAccessPoliciesRulesJSONRequestBody = NetworkAccessPolicyRule

// PostApi217NetworkAccessPoliciesRulesJSONRequestBody defines body for PostApi217NetworkAccessPoliciesRules for application/json ContentType.
type PostApi217NetworkAccessPoliciesRulesJSONRequestBody = NetworkAccessPolicyRulePost

// PatchApi217NetworkInterfacesJSONRequestBody defines body for PatchApi217NetworkInterfaces for application/json ContentType.
type PatchApi217NetworkInterfacesJSONRequestBody = NetworkInterfacePatch

// PostApi217NetworkInterfacesJSONRequestBody defines body for PostApi217NetworkInterfaces for application/json ContentType.
type PostApi217NetworkInterfacesJSONRequestBody = NetworkInterface

// PatchApi217NetworkInterfacesConnectorsJSONRequestBody defines body for PatchApi217NetworkInterfacesConnectors for application/json ContentType.
type PatchApi217NetworkInterfacesConnectorsJSONRequestBody = HardwareConnector

// PatchApi217NfsExportPoliciesJSONRequestBody defines body for PatchApi217NfsExportPolicies for application/json ContentType.
type PatchApi217NfsExportPoliciesJSONRequestBody = NfsExportPolicy

// PostApi217NfsExportPoliciesJSONRequestBody defines body for PostApi217NfsExportPolicies for application/json ContentType.
type PostApi217NfsExportPoliciesJSONRequestBody = NfsExportPolicyPost

// PatchApi217NfsExportPoliciesRulesJSONRequestBody defines body for PatchApi217NfsExportPoliciesRules for application/json ContentType.
type PatchApi217NfsExportPoliciesRulesJSONRequestBody = NfsExportPolicyRule

// PostApi217NfsExportPoliciesRulesJSONRequestBody defines body for PostApi217NfsExportPoliciesRules for application/json ContentType.
type PostApi217NfsExportPoliciesRulesJSONRequestBody = NfsExportPolicyRule

// PatchApi217ObjectStoreAccessKeysJSONRequestBody defines body for PatchApi217ObjectStoreAccessKeys for application/json ContentType.
type PatchApi217ObjectStoreAccessKeysJSONRequestBody = ObjectStoreAccessKey

// PostApi217ObjectStoreAccessKeysJSONRequestBody defines body for PostApi217ObjectStoreAccessKeys for application/json ContentType.
type PostApi217ObjectStoreAccessKeysJSONRequestBody = ObjectStoreAccessKeyPost

// PatchApi217ObjectStoreAccessPoliciesJSONRequestBody defines body for PatchApi217ObjectStoreAccessPolicies for application/json ContentType.
type PatchApi217ObjectStoreAccessPoliciesJSONRequestBody = ObjectStoreAccessPolicyPatch

// PostApi217ObjectStoreAccessPoliciesJSONRequestBody defines body for PostApi217ObjectStoreAccessPolicies for application/json ContentType.
type PostApi217ObjectStoreAccessPoliciesJSONRequestBody = ObjectStoreAccessPolicyPost

// PatchApi217ObjectStoreAccessPoliciesRulesJSONRequestBody defines body for PatchApi217ObjectStoreAccessPoliciesRules for application/json ContentType.
type PatchApi217ObjectStoreAccessPoliciesRulesJSONRequestBody = PolicyRuleObjectAccessPost

// PostApi217ObjectStoreAccessPoliciesRulesJSONRequestBody defines body for PostApi217ObjectStoreAccessPoliciesRules for application/json ContentType.
type PostApi217ObjectStoreAccessPoliciesRulesJSONRequestBody = PolicyRuleObjectAccessPost

// PatchApi217ObjectStoreAccountsJSONRequestBody defines body for PatchApi217ObjectStoreAccounts for application/json ContentType.
type PatchApi217ObjectStoreAccountsJSONRequestBody = ObjectStoreAccountPatch

// PostApi217ObjectStoreAccountsJSONRequestBody defines body for PostApi217ObjectStoreAccounts for application/json ContentType.
type PostApi217ObjectStoreAccountsJSONRequestBody = ObjectStoreAccountPost

// PatchApi217ObjectStoreRemoteCredentialsJSONRequestBody defines body for PatchApi217ObjectStoreRemoteCredentials for application/json ContentType.
type PatchApi217ObjectStoreRemoteCredentialsJSONRequestBody = ObjectStoreRemoteCredentials

// PostApi217ObjectStoreRemoteCredentialsJSONRequestBody defines body for PostApi217ObjectStoreRemoteCredentials for application/json ContentType.
type PostApi217ObjectStoreRemoteCredentialsJSONRequestBody = ObjectStoreRemoteCredentialsPost

// PatchApi217ObjectStoreRolesJSONRequestBody defines body for PatchApi217ObjectStoreRoles for application/json ContentType.
type PatchApi217ObjectStoreRolesJSONRequestBody = ObjectStoreRole

// PostApi217ObjectStoreRolesJSONRequestBody defines body for PostApi217ObjectStoreRoles for application/json ContentType.
type PostApi217ObjectStoreRolesJSONRequestBody = ObjectStoreRolePost

// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody defines body for PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRules for application/json ContentType.
type PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody = TrustPolicyRulePost

// PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody defines body for PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRules for application/json ContentType.
type PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody = TrustPolicyRulePost

// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadJSONRequestBody defines body for PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUpload for application/json ContentType.
type PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadJSONRequestBody = ObjectStoreTrustPolicyIam

// PatchApi217PasswordPoliciesJSONRequestBody defines body for PatchApi217PasswordPolicies for application/json ContentType.
type PatchApi217PasswordPoliciesJSONRequestBody = PasswordPolicy

// PatchApi217PoliciesJSONRequestBody defines body for PatchApi217Policies for application/json ContentType.
type PatchApi217PoliciesJSONRequestBody = PolicyPatch

// PostApi217PoliciesJSONRequestBody defines body for PostApi217Policies for application/json ContentType.
type PostApi217PoliciesJSONRequestBody = Policy

// PostApi217PublicKeysJSONRequestBody defines body for PostApi217PublicKeys for application/json ContentType.
type PostApi217PublicKeysJSONRequestBody = PublicKeyPost

// PatchApi217QosPoliciesJSONRequestBody defines body for PatchApi217QosPolicies for application/json ContentType.
type PatchApi217QosPoliciesJSONRequestBody = QosPolicy

// PostApi217QosPoliciesJSONRequestBody defines body for PostApi217QosPolicies for application/json ContentType.
type PostApi217QosPoliciesJSONRequestBody = QosPolicy

// PatchApi217QuotasGroupsJSONRequestBody defines body for PatchApi217QuotasGroups for application/json ContentType.
type PatchApi217QuotasGroupsJSONRequestBody = GroupQuotaPatch

// PostApi217QuotasGroupsJSONRequestBody defines body for PostApi217QuotasGroups for application/json ContentType.
type PostApi217QuotasGroupsJSONRequestBody = GroupQuotaPost

// PatchApi217QuotasSettingsJSONRequestBody defines body for PatchApi217QuotasSettings for application/json ContentType.
type PatchApi217QuotasSettingsJSONRequestBody = QuotaSetting

// PatchApi217QuotasUsersJSONRequestBody defines body for PatchApi217QuotasUsers for application/json ContentType.
type PatchApi217QuotasUsersJSONRequestBody = UserQuotaPatch

// PostApi217QuotasUsersJSONRequestBody defines body for PostApi217QuotasUsers for application/json ContentType.
type PostApi217QuotasUsersJSONRequestBody = UserQuotaPost

// PatchApi217RapidDataLockingJSONRequestBody defines body for PatchApi217RapidDataLocking for application/json ContentType.
type PatchApi217RapidDataLockingJSONRequestBody = RapidDataLocking

// PatchApi217ServersJSONRequestBody defines body for PatchApi217Servers for application/json ContentType.
type PatchApi217ServersJSONRequestBody = ServerPost

// PostApi217ServersJSONRequestBody defines body for PostApi217Servers for application/json ContentType.
type PostApi217ServersJSONRequestBody = ServerPost

// PatchApi217SmbClientPoliciesJSONRequestBody defines body for PatchApi217SmbClientPolicies for application/json ContentType.
type PatchApi217SmbClientPoliciesJSONRequestBody = SmbClientPolicy

// PostApi217SmbClientPoliciesJSONRequestBody defines body for PostApi217SmbClientPolicies for application/json ContentType.
type PostApi217SmbClientPoliciesJSONRequestBody = SmbClientPolicyPost

// PatchApi217SmbClientPoliciesRulesJSONRequestBody defines body for PatchApi217SmbClientPoliciesRules for application/json ContentType.
type PatchApi217SmbClientPoliciesRulesJSONRequestBody = SmbClientPolicyRule

// PostApi217SmbClientPoliciesRulesJSONRequestBody defines body for PostApi217SmbClientPoliciesRules for application/json ContentType.
type PostApi217SmbClientPoliciesRulesJSONRequestBody = SmbClientPolicyRulePost

// PatchApi217SmbSharePoliciesJSONRequestBody defines body for PatchApi217SmbSharePolicies for application/json ContentType.
type PatchApi217SmbSharePoliciesJSONRequestBody = SmbSharePolicy

// PostApi217SmbSharePoliciesJSONRequestBody defines body for PostApi217SmbSharePolicies for application/json ContentType.
type PostApi217SmbSharePoliciesJSONRequestBody = SmbSharePolicyPost

// PatchApi217SmbSharePoliciesRulesJSONRequestBody defines body for PatchApi217SmbSharePoliciesRules for application/json ContentType.
type PatchApi217SmbSharePoliciesRulesJSONRequestBody = SmbSharePolicyRule

// PostApi217SmbSharePoliciesRulesJSONRequestBody defines body for PostApi217SmbSharePoliciesRules for application/json ContentType.
type PostApi217SmbSharePoliciesRulesJSONRequestBody = SmbSharePolicyRulePost

// PatchApi217SmtpServersJSONRequestBody defines body for PatchApi217SmtpServers for application/json ContentType.
type PatchApi217SmtpServersJSONRequestBody = SmtpServer

// PatchApi217SnmpAgentsJSONRequestBody defines body for PatchApi217SnmpAgents for application/json ContentType.
type PatchApi217SnmpAgentsJSONRequestBody = SnmpAgent

// PatchApi217SnmpManagersJSONRequestBody defines body for PatchApi217SnmpManagers for application/json ContentType.
type PatchApi217SnmpManagersJSONRequestBody = SnmpManager

// PostApi217SnmpManagersJSONRequestBody defines body for PostApi217SnmpManagers for application/json ContentType.
type PostApi217SnmpManagersJSONRequestBody = SnmpManagerPost

// PatchApi217SshCertificateAuthorityPoliciesJSONRequestBody defines body for PatchApi217SshCertificateAuthorityPolicies for application/json ContentType.
type PatchApi217SshCertificateAuthorityPoliciesJSONRequestBody = SshCertificateAuthorityPolicy

// PostApi217SshCertificateAuthorityPoliciesJSONRequestBody defines body for PostApi217SshCertificateAuthorityPolicies for application/json ContentType.
type PostApi217SshCertificateAuthorityPoliciesJSONRequestBody = SshCertificateAuthorityPolicyPost

// PatchApi217SsoOidcIdpsJSONRequestBody defines body for PatchApi217SsoOidcIdps for application/json ContentType.
type PatchApi217SsoOidcIdpsJSONRequestBody = OidcSsoPatch

// PostApi217SsoOidcIdpsJSONRequestBody defines body for PostApi217SsoOidcIdps for application/json ContentType.
type PostApi217SsoOidcIdpsJSONRequestBody = OidcSsoPost

// PatchApi217SsoSaml2IdpsJSONRequestBody defines body for PatchApi217SsoSaml2Idps for application/json ContentType.
type PatchApi217SsoSaml2IdpsJSONRequestBody = Saml2Sso

// PostApi217SsoSaml2IdpsJSONRequestBody defines body for PostApi217SsoSaml2Idps for application/json ContentType.
type PostApi217SsoSaml2IdpsJSONRequestBody = Saml2SsoPost

// PatchApi217SsoSaml2IdpsTestJSONRequestBody defines body for PatchApi217SsoSaml2IdpsTest for application/json ContentType.
type PatchApi217SsoSaml2IdpsTestJSONRequestBody = Saml2Sso

// PatchApi217SubnetsJSONRequestBody defines body for PatchApi217Subnets for application/json ContentType.
type PatchApi217SubnetsJSONRequestBody = Subnet

// PostApi217SubnetsJSONRequestBody defines body for PostApi217Subnets for application/json ContentType.
type PostApi217SubnetsJSONRequestBody = Subnet

// PatchApi217SupportJSONRequestBody defines body for PatchApi217Support for application/json ContentType.
type PatchApi217SupportJSONRequestBody = Support

// PatchApi217SupportVerificationKeysJSONRequestBody defines body for PatchApi217SupportVerificationKeys for application/json ContentType.
type PatchApi217SupportVerificationKeysJSONRequestBody = VerificationKeyPatch

// PatchApi217SyslogServersJSONRequestBody defines body for PatchApi217SyslogServers for application/json ContentType.
type PatchApi217SyslogServersJSONRequestBody = SyslogServerPatch

// PostApi217SyslogServersJSONRequestBody defines body for PostApi217SyslogServers for application/json ContentType.
type PostApi217SyslogServersJSONRequestBody = SyslogServerPost

// PatchApi217SyslogServersSettingsJSONRequestBody defines body for PatchApi217SyslogServersSettings for application/json ContentType.
type PatchApi217SyslogServersSettingsJSONRequestBody = SyslogServerSettings

// PatchApi217TargetsJSONRequestBody defines body for PatchApi217Targets for application/json ContentType.
type PatchApi217TargetsJSONRequestBody = Target

// PostApi217TargetsJSONRequestBody defines body for PostApi217Targets for application/json ContentType.
type PostApi217TargetsJSONRequestBody = TargetPost

// PatchApi217TlsPoliciesJSONRequestBody defines body for PatchApi217TlsPolicies for application/json ContentType.
type PatchApi217TlsPoliciesJSONRequestBody = TlsPolicy

// PostApi217TlsPoliciesJSONRequestBody defines body for PostApi217TlsPolicies for application/json ContentType.
type PostApi217TlsPoliciesJSONRequestBody = TlsPolicyPost

// PatchApi217WormDataPoliciesJSONRequestBody defines body for PatchApi217WormDataPolicies for application/json ContentType.
type PatchApi217WormDataPoliciesJSONRequestBody = WormDataPolicy

// PostApi217WormDataPoliciesJSONRequestBody defines body for PostApi217WormDataPolicies for application/json ContentType.
type PostApi217WormDataPoliciesJSONRequestBody = WormDataPolicy

// PostOauth210TokenFormdataRequestBody defines body for PostOauth210Token for application/x-www-form-urlencoded ContentType.
type PostOauth210TokenFormdataRequestBody PostOauth210TokenFormdataBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteApi217ActiveDirectory request
	DeleteApi217ActiveDirectory(ctx context.Context, params *DeleteApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ActiveDirectory request
	GetApi217ActiveDirectory(ctx context.Context, params *GetApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ActiveDirectoryWithBody request with any body
	PatchApi217ActiveDirectoryWithBody(ctx context.Context, params *PatchApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ActiveDirectory(ctx context.Context, params *PatchApi217ActiveDirectoryParams, body PatchApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ActiveDirectoryWithBody request with any body
	PostApi217ActiveDirectoryWithBody(ctx context.Context, params *PostApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ActiveDirectory(ctx context.Context, params *PostApi217ActiveDirectoryParams, body PostApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ActiveDirectoryTest request
	GetApi217ActiveDirectoryTest(ctx context.Context, params *GetApi217ActiveDirectoryTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Admins request
	DeleteApi217Admins(ctx context.Context, params *DeleteApi217AdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Admins request
	GetApi217Admins(ctx context.Context, params *GetApi217AdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217AdminsWithBody request with any body
	PatchApi217AdminsWithBody(ctx context.Context, params *PatchApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Admins(ctx context.Context, params *PatchApi217AdminsParams, body PatchApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217AdminsWithBody request with any body
	PostApi217AdminsWithBody(ctx context.Context, params *PostApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Admins(ctx context.Context, params *PostApi217AdminsParams, body PostApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217AdminsApiTokens request
	DeleteApi217AdminsApiTokens(ctx context.Context, params *DeleteApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AdminsApiTokens request
	GetApi217AdminsApiTokens(ctx context.Context, params *GetApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217AdminsApiTokens request
	PostApi217AdminsApiTokens(ctx context.Context, params *PostApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217AdminsCache request
	DeleteApi217AdminsCache(ctx context.Context, params *DeleteApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AdminsCache request
	GetApi217AdminsCache(ctx context.Context, params *GetApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AdminsSettings request
	GetApi217AdminsSettings(ctx context.Context, params *GetApi217AdminsSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217AdminsSettingsWithBody request with any body
	PatchApi217AdminsSettingsWithBody(ctx context.Context, params *PatchApi217AdminsSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217AdminsSettings(ctx context.Context, params *PatchApi217AdminsSettingsParams, body PatchApi217AdminsSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217AdminsSshCertificateAuthorityPolicies request
	DeleteApi217AdminsSshCertificateAuthorityPolicies(ctx context.Context, params *DeleteApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AdminsSshCertificateAuthorityPolicies request
	GetApi217AdminsSshCertificateAuthorityPolicies(ctx context.Context, params *GetApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217AdminsSshCertificateAuthorityPolicies request
	PostApi217AdminsSshCertificateAuthorityPolicies(ctx context.Context, params *PostApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217AlertWatchers request
	DeleteApi217AlertWatchers(ctx context.Context, params *DeleteApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AlertWatchers request
	GetApi217AlertWatchers(ctx context.Context, params *GetApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217AlertWatchersWithBody request with any body
	PatchApi217AlertWatchersWithBody(ctx context.Context, params *PatchApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217AlertWatchers(ctx context.Context, params *PatchApi217AlertWatchersParams, body PatchApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217AlertWatchersWithBody request with any body
	PostApi217AlertWatchersWithBody(ctx context.Context, params *PostApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217AlertWatchers(ctx context.Context, params *PostApi217AlertWatchersParams, body PostApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AlertWatchersTest request
	GetApi217AlertWatchersTest(ctx context.Context, params *GetApi217AlertWatchersTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Alerts request
	GetApi217Alerts(ctx context.Context, params *GetApi217AlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217AlertsWithBody request with any body
	PatchApi217AlertsWithBody(ctx context.Context, params *PatchApi217AlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Alerts(ctx context.Context, params *PatchApi217AlertsParams, body PatchApi217AlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ApiClients request
	DeleteApi217ApiClients(ctx context.Context, params *DeleteApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ApiClients request
	GetApi217ApiClients(ctx context.Context, params *GetApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ApiClientsWithBody request with any body
	PatchApi217ApiClientsWithBody(ctx context.Context, params *PatchApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ApiClients(ctx context.Context, params *PatchApi217ApiClientsParams, body PatchApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ApiClientsWithBody request with any body
	PostApi217ApiClientsWithBody(ctx context.Context, params *PostApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ApiClients(ctx context.Context, params *PostApi217ApiClientsParams, body PostApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ArrayConnections request
	DeleteApi217ArrayConnections(ctx context.Context, params *DeleteApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArrayConnections request
	GetApi217ArrayConnections(ctx context.Context, params *GetApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ArrayConnectionsWithBody request with any body
	PatchApi217ArrayConnectionsWithBody(ctx context.Context, params *PatchApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ArrayConnections(ctx context.Context, params *PatchApi217ArrayConnectionsParams, body PatchApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ArrayConnectionsWithBody request with any body
	PostApi217ArrayConnectionsWithBody(ctx context.Context, params *PostApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ArrayConnections(ctx context.Context, params *PostApi217ArrayConnectionsParams, body PostApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArrayConnectionsConnectionKey request
	GetApi217ArrayConnectionsConnectionKey(ctx context.Context, params *GetApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ArrayConnectionsConnectionKey request
	PostApi217ArrayConnectionsConnectionKey(ctx context.Context, params *PostApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArrayConnectionsPath request
	GetApi217ArrayConnectionsPath(ctx context.Context, params *GetApi217ArrayConnectionsPathParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArrayConnectionsPerformanceReplication request
	GetApi217ArrayConnectionsPerformanceReplication(ctx context.Context, params *GetApi217ArrayConnectionsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Arrays request
	GetApi217Arrays(ctx context.Context, params *GetApi217ArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ArraysWithBody request with any body
	PatchApi217ArraysWithBody(ctx context.Context, params *PatchApi217ArraysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Arrays(ctx context.Context, params *PatchApi217ArraysParams, body PatchApi217ArraysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysClientsPerformance request
	GetApi217ArraysClientsPerformance(ctx context.Context, params *GetApi217ArraysClientsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysEula request
	GetApi217ArraysEula(ctx context.Context, params *GetApi217ArraysEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ArraysEulaWithBody request with any body
	PatchApi217ArraysEulaWithBody(ctx context.Context, params *PatchApi217ArraysEulaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ArraysEula(ctx context.Context, params *PatchApi217ArraysEulaParams, body PatchApi217ArraysEulaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ArraysFactoryResetToken request
	DeleteApi217ArraysFactoryResetToken(ctx context.Context, params *DeleteApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysFactoryResetToken request
	GetApi217ArraysFactoryResetToken(ctx context.Context, params *GetApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ArraysFactoryResetToken request
	PostApi217ArraysFactoryResetToken(ctx context.Context, params *PostApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysHttpSpecificPerformance request
	GetApi217ArraysHttpSpecificPerformance(ctx context.Context, params *GetApi217ArraysHttpSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysNfsSpecificPerformance request
	GetApi217ArraysNfsSpecificPerformance(ctx context.Context, params *GetApi217ArraysNfsSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysPerformance request
	GetApi217ArraysPerformance(ctx context.Context, params *GetApi217ArraysPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysPerformanceReplication request
	GetApi217ArraysPerformanceReplication(ctx context.Context, params *GetApi217ArraysPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysS3SpecificPerformance request
	GetApi217ArraysS3SpecificPerformance(ctx context.Context, params *GetApi217ArraysS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysSpace request
	GetApi217ArraysSpace(ctx context.Context, params *GetApi217ArraysSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysSpaceStorageClasses request
	GetApi217ArraysSpaceStorageClasses(ctx context.Context, params *GetApi217ArraysSpaceStorageClassesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ArraysSshCertificateAuthorityPolicies request
	DeleteApi217ArraysSshCertificateAuthorityPolicies(ctx context.Context, params *DeleteApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysSshCertificateAuthorityPolicies request
	GetApi217ArraysSshCertificateAuthorityPolicies(ctx context.Context, params *GetApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ArraysSshCertificateAuthorityPolicies request
	PostApi217ArraysSshCertificateAuthorityPolicies(ctx context.Context, params *PostApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ArraysSupportedTimeZones request
	GetApi217ArraysSupportedTimeZones(ctx context.Context, params *GetApi217ArraysSupportedTimeZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217AuditFileSystemsPolicies request
	DeleteApi217AuditFileSystemsPolicies(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AuditFileSystemsPolicies request
	GetApi217AuditFileSystemsPolicies(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217AuditFileSystemsPoliciesWithBody request with any body
	PatchApi217AuditFileSystemsPoliciesWithBody(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217AuditFileSystemsPolicies(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, body PatchApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217AuditFileSystemsPoliciesWithBody request with any body
	PostApi217AuditFileSystemsPoliciesWithBody(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217AuditFileSystemsPolicies(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, body PostApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217AuditFileSystemsPoliciesMembers request
	DeleteApi217AuditFileSystemsPoliciesMembers(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217AuditFileSystemsPoliciesMembers request
	GetApi217AuditFileSystemsPoliciesMembers(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217AuditFileSystemsPoliciesMembers request
	PostApi217AuditFileSystemsPoliciesMembers(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Audits request
	GetApi217Audits(ctx context.Context, params *GetApi217AuditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Blades request
	GetApi217Blades(ctx context.Context, params *GetApi217BladesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217BucketReplicaLinks request
	DeleteApi217BucketReplicaLinks(ctx context.Context, params *DeleteApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217BucketReplicaLinks request
	GetApi217BucketReplicaLinks(ctx context.Context, params *GetApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217BucketReplicaLinksWithBody request with any body
	PatchApi217BucketReplicaLinksWithBody(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217BucketReplicaLinks(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, body PatchApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217BucketReplicaLinksWithBody request with any body
	PostApi217BucketReplicaLinksWithBody(ctx context.Context, params *PostApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217BucketReplicaLinks(ctx context.Context, params *PostApi217BucketReplicaLinksParams, body PostApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Buckets request
	DeleteApi217Buckets(ctx context.Context, params *DeleteApi217BucketsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Buckets request
	GetApi217Buckets(ctx context.Context, params *GetApi217BucketsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217BucketsWithBody request with any body
	PatchApi217BucketsWithBody(ctx context.Context, params *PatchApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Buckets(ctx context.Context, params *PatchApi217BucketsParams, body PatchApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217BucketsWithBody request with any body
	PostApi217BucketsWithBody(ctx context.Context, params *PostApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Buckets(ctx context.Context, params *PostApi217BucketsParams, body PostApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217BucketsBucketAccessPolicies request
	DeleteApi217BucketsBucketAccessPolicies(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217BucketsBucketAccessPolicies request
	GetApi217BucketsBucketAccessPolicies(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217BucketsBucketAccessPoliciesWithBody request with any body
	PostApi217BucketsBucketAccessPoliciesWithBody(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217BucketsBucketAccessPolicies(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, body PostApi217BucketsBucketAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217BucketsBucketAccessPoliciesRules request
	DeleteApi217BucketsBucketAccessPoliciesRules(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217BucketsBucketAccessPoliciesRules request
	GetApi217BucketsBucketAccessPoliciesRules(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217BucketsBucketAccessPoliciesRulesWithBody request with any body
	PostApi217BucketsBucketAccessPoliciesRulesWithBody(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217BucketsBucketAccessPoliciesRules(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, body PostApi217BucketsBucketAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217BucketsCrossOriginResourceSharingPolicies request
	DeleteApi217BucketsCrossOriginResourceSharingPolicies(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217BucketsCrossOriginResourceSharingPolicies request
	GetApi217BucketsCrossOriginResourceSharingPolicies(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217BucketsCrossOriginResourceSharingPoliciesWithBody request with any body
	PostApi217BucketsCrossOriginResourceSharingPoliciesWithBody(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217BucketsCrossOriginResourceSharingPolicies(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217BucketsCrossOriginResourceSharingPoliciesRules request
	DeleteApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217BucketsCrossOriginResourceSharingPoliciesRules request
	GetApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBody request with any body
	PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBody(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217BucketsPerformance request
	GetApi217BucketsPerformance(ctx context.Context, params *GetApi217BucketsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217BucketsS3SpecificPerformance request
	GetApi217BucketsS3SpecificPerformance(ctx context.Context, params *GetApi217BucketsS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217CertificateGroups request
	DeleteApi217CertificateGroups(ctx context.Context, params *DeleteApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217CertificateGroups request
	GetApi217CertificateGroups(ctx context.Context, params *GetApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217CertificateGroups request
	PostApi217CertificateGroups(ctx context.Context, params *PostApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217CertificateGroupsCertificates request
	DeleteApi217CertificateGroupsCertificates(ctx context.Context, params *DeleteApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217CertificateGroupsCertificates request
	GetApi217CertificateGroupsCertificates(ctx context.Context, params *GetApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217CertificateGroupsCertificates request
	PostApi217CertificateGroupsCertificates(ctx context.Context, params *PostApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217CertificateGroupsUses request
	GetApi217CertificateGroupsUses(ctx context.Context, params *GetApi217CertificateGroupsUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Certificates request
	DeleteApi217Certificates(ctx context.Context, params *DeleteApi217CertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Certificates request
	GetApi217Certificates(ctx context.Context, params *GetApi217CertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217CertificatesWithBody request with any body
	PatchApi217CertificatesWithBody(ctx context.Context, params *PatchApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Certificates(ctx context.Context, params *PatchApi217CertificatesParams, body PatchApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217CertificatesWithBody request with any body
	PostApi217CertificatesWithBody(ctx context.Context, params *PostApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Certificates(ctx context.Context, params *PostApi217CertificatesParams, body PostApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217CertificatesCertificateGroups request
	DeleteApi217CertificatesCertificateGroups(ctx context.Context, params *DeleteApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217CertificatesCertificateGroups request
	GetApi217CertificatesCertificateGroups(ctx context.Context, params *GetApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217CertificatesCertificateGroups request
	PostApi217CertificatesCertificateGroups(ctx context.Context, params *PostApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217CertificatesUses request
	GetApi217CertificatesUses(ctx context.Context, params *GetApi217CertificatesUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217DirectoryServices request
	GetApi217DirectoryServices(ctx context.Context, params *GetApi217DirectoryServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217DirectoryServicesWithBody request with any body
	PatchApi217DirectoryServicesWithBody(ctx context.Context, params *PatchApi217DirectoryServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217DirectoryServices(ctx context.Context, params *PatchApi217DirectoryServicesParams, body PatchApi217DirectoryServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217DirectoryServicesRoles request
	DeleteApi217DirectoryServicesRoles(ctx context.Context, params *DeleteApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217DirectoryServicesRoles request
	GetApi217DirectoryServicesRoles(ctx context.Context, params *GetApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217DirectoryServicesRolesWithBody request with any body
	PatchApi217DirectoryServicesRolesWithBody(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217DirectoryServicesRoles(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, body PatchApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217DirectoryServicesRolesWithBody request with any body
	PostApi217DirectoryServicesRolesWithBody(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217DirectoryServicesRoles(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, body PostApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217DirectoryServicesTest request
	GetApi217DirectoryServicesTest(ctx context.Context, params *GetApi217DirectoryServicesTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217DirectoryServicesTestWithBody request with any body
	PatchApi217DirectoryServicesTestWithBody(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217DirectoryServicesTest(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, body PatchApi217DirectoryServicesTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Dns request
	DeleteApi217Dns(ctx context.Context, params *DeleteApi217DnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Dns request
	GetApi217Dns(ctx context.Context, params *GetApi217DnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217DnsWithBody request with any body
	PatchApi217DnsWithBody(ctx context.Context, params *PatchApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Dns(ctx context.Context, params *PatchApi217DnsParams, body PatchApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217DnsWithBody request with any body
	PostApi217DnsWithBody(ctx context.Context, params *PostApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Dns(ctx context.Context, params *PostApi217DnsParams, body PostApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Drives request
	GetApi217Drives(ctx context.Context, params *GetApi217DrivesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemExports request
	DeleteApi217FileSystemExports(ctx context.Context, params *DeleteApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemExports request
	GetApi217FileSystemExports(ctx context.Context, params *GetApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217FileSystemExportsWithBody request with any body
	PatchApi217FileSystemExportsWithBody(ctx context.Context, params *PatchApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217FileSystemExports(ctx context.Context, params *PatchApi217FileSystemExportsParams, body PatchApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemExportsWithBody request with any body
	PostApi217FileSystemExportsWithBody(ctx context.Context, params *PostApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217FileSystemExports(ctx context.Context, params *PostApi217FileSystemExportsParams, body PostApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemReplicaLinks request
	DeleteApi217FileSystemReplicaLinks(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemReplicaLinks request
	GetApi217FileSystemReplicaLinks(ctx context.Context, params *GetApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217FileSystemReplicaLinks request
	PatchApi217FileSystemReplicaLinks(ctx context.Context, params *PatchApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemReplicaLinksWithBody request with any body
	PostApi217FileSystemReplicaLinksWithBody(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217FileSystemReplicaLinks(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, body PostApi217FileSystemReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemReplicaLinksPolicies request
	DeleteApi217FileSystemReplicaLinksPolicies(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemReplicaLinksPolicies request
	GetApi217FileSystemReplicaLinksPolicies(ctx context.Context, params *GetApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemReplicaLinksPolicies request
	PostApi217FileSystemReplicaLinksPolicies(ctx context.Context, params *PostApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemReplicaLinksTransfer request
	GetApi217FileSystemReplicaLinksTransfer(ctx context.Context, params *GetApi217FileSystemReplicaLinksTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemSnapshots request
	DeleteApi217FileSystemSnapshots(ctx context.Context, params *DeleteApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemSnapshots request
	GetApi217FileSystemSnapshots(ctx context.Context, params *GetApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217FileSystemSnapshotsWithBody request with any body
	PatchApi217FileSystemSnapshotsWithBody(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217FileSystemSnapshots(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, body PatchApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemSnapshotsWithBody request with any body
	PostApi217FileSystemSnapshotsWithBody(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217FileSystemSnapshots(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, body PostApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemSnapshotsPolicies request
	DeleteApi217FileSystemSnapshotsPolicies(ctx context.Context, params *DeleteApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemSnapshotsPolicies request
	GetApi217FileSystemSnapshotsPolicies(ctx context.Context, params *GetApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemSnapshotsTransfer request
	DeleteApi217FileSystemSnapshotsTransfer(ctx context.Context, params *DeleteApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemSnapshotsTransfer request
	GetApi217FileSystemSnapshotsTransfer(ctx context.Context, params *GetApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystems request
	DeleteApi217FileSystems(ctx context.Context, params *DeleteApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystems request
	GetApi217FileSystems(ctx context.Context, params *GetApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217FileSystemsWithBody request with any body
	PatchApi217FileSystemsWithBody(ctx context.Context, params *PatchApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217FileSystems(ctx context.Context, params *PatchApi217FileSystemsParams, body PatchApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemsWithBody request with any body
	PostApi217FileSystemsWithBody(ctx context.Context, params *PostApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217FileSystems(ctx context.Context, params *PostApi217FileSystemsParams, body PostApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemsAuditPolicies request
	DeleteApi217FileSystemsAuditPolicies(ctx context.Context, params *DeleteApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsAuditPolicies request
	GetApi217FileSystemsAuditPolicies(ctx context.Context, params *GetApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemsAuditPolicies request
	PostApi217FileSystemsAuditPolicies(ctx context.Context, params *PostApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsGroupsPerformance request
	GetApi217FileSystemsGroupsPerformance(ctx context.Context, params *GetApi217FileSystemsGroupsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemsLocks request
	DeleteApi217FileSystemsLocks(ctx context.Context, params *DeleteApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsLocks request
	GetApi217FileSystemsLocks(ctx context.Context, params *GetApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsLocksClients request
	GetApi217FileSystemsLocksClients(ctx context.Context, params *GetApi217FileSystemsLocksClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemsLocksNlmReclamations request
	PostApi217FileSystemsLocksNlmReclamations(ctx context.Context, params *PostApi217FileSystemsLocksNlmReclamationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemsOpenFiles request
	DeleteApi217FileSystemsOpenFiles(ctx context.Context, params *DeleteApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsOpenFiles request
	GetApi217FileSystemsOpenFiles(ctx context.Context, params *GetApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsPerformance request
	GetApi217FileSystemsPerformance(ctx context.Context, params *GetApi217FileSystemsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemsPolicies request
	DeleteApi217FileSystemsPolicies(ctx context.Context, params *DeleteApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsPolicies request
	GetApi217FileSystemsPolicies(ctx context.Context, params *GetApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FileSystemsPolicies request
	PostApi217FileSystemsPolicies(ctx context.Context, params *PostApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsPoliciesAll request
	GetApi217FileSystemsPoliciesAll(ctx context.Context, params *GetApi217FileSystemsPoliciesAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FileSystemsSessions request
	DeleteApi217FileSystemsSessions(ctx context.Context, params *DeleteApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsSessions request
	GetApi217FileSystemsSessions(ctx context.Context, params *GetApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsUsersPerformance request
	GetApi217FileSystemsUsersPerformance(ctx context.Context, params *GetApi217FileSystemsUsersPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FileSystemsWormDataPolicies request
	GetApi217FileSystemsWormDataPolicies(ctx context.Context, params *GetApi217FileSystemsWormDataPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Fleets request
	DeleteApi217Fleets(ctx context.Context, params *DeleteApi217FleetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Fleets request
	GetApi217Fleets(ctx context.Context, params *GetApi217FleetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217FleetsWithBody request with any body
	PatchApi217FleetsWithBody(ctx context.Context, params *PatchApi217FleetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Fleets(ctx context.Context, params *PatchApi217FleetsParams, body PatchApi217FleetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217Fleets request
	PostApi217Fleets(ctx context.Context, params *PostApi217FleetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FleetsFleetKey request
	GetApi217FleetsFleetKey(ctx context.Context, params *GetApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FleetsFleetKey request
	PostApi217FleetsFleetKey(ctx context.Context, params *PostApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217FleetsMembers request
	DeleteApi217FleetsMembers(ctx context.Context, params *DeleteApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217FleetsMembers request
	GetApi217FleetsMembers(ctx context.Context, params *GetApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217FleetsMembersWithBody request with any body
	PostApi217FleetsMembersWithBody(ctx context.Context, params *PostApi217FleetsMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217FleetsMembers(ctx context.Context, params *PostApi217FleetsMembersParams, body PostApi217FleetsMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Hardware request
	GetApi217Hardware(ctx context.Context, params *GetApi217HardwareParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217HardwareWithBody request with any body
	PatchApi217HardwareWithBody(ctx context.Context, params *PatchApi217HardwareParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Hardware(ctx context.Context, params *PatchApi217HardwareParams, body PatchApi217HardwareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217HardwareConnectors request
	GetApi217HardwareConnectors(ctx context.Context, params *GetApi217HardwareConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217HardwareConnectorsWithBody request with any body
	PatchApi217HardwareConnectorsWithBody(ctx context.Context, params *PatchApi217HardwareConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217HardwareConnectors(ctx context.Context, params *PatchApi217HardwareConnectorsParams, body PatchApi217HardwareConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217HardwareConnectorsPerformance request
	GetApi217HardwareConnectorsPerformance(ctx context.Context, params *GetApi217HardwareConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Keytabs request
	DeleteApi217Keytabs(ctx context.Context, params *DeleteApi217KeytabsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Keytabs request
	GetApi217Keytabs(ctx context.Context, params *GetApi217KeytabsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217KeytabsWithBody request with any body
	PostApi217KeytabsWithBody(ctx context.Context, params *PostApi217KeytabsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Keytabs(ctx context.Context, params *PostApi217KeytabsParams, body PostApi217KeytabsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217KeytabsDownload request
	GetApi217KeytabsDownload(ctx context.Context, params *GetApi217KeytabsDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217KeytabsUploadWithBody request with any body
	PostApi217KeytabsUploadWithBody(ctx context.Context, params *PostApi217KeytabsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Kmip request
	DeleteApi217Kmip(ctx context.Context, params *DeleteApi217KmipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Kmip request
	GetApi217Kmip(ctx context.Context, params *GetApi217KmipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217KmipWithBody request with any body
	PatchApi217KmipWithBody(ctx context.Context, params *PatchApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Kmip(ctx context.Context, params *PatchApi217KmipParams, body PatchApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217KmipWithBody request with any body
	PostApi217KmipWithBody(ctx context.Context, params *PostApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Kmip(ctx context.Context, params *PostApi217KmipParams, body PostApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217KmipTest request
	GetApi217KmipTest(ctx context.Context, params *GetApi217KmipTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217LegalHolds request
	DeleteApi217LegalHolds(ctx context.Context, params *DeleteApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217LegalHolds request
	GetApi217LegalHolds(ctx context.Context, params *GetApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217LegalHoldsWithBody request with any body
	PatchApi217LegalHoldsWithBody(ctx context.Context, params *PatchApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217LegalHolds(ctx context.Context, params *PatchApi217LegalHoldsParams, body PatchApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217LegalHoldsWithBody request with any body
	PostApi217LegalHoldsWithBody(ctx context.Context, params *PostApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217LegalHolds(ctx context.Context, params *PostApi217LegalHoldsParams, body PostApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217LegalHoldsHeldEntities request
	GetApi217LegalHoldsHeldEntities(ctx context.Context, params *GetApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217LegalHoldsHeldEntities request
	PatchApi217LegalHoldsHeldEntities(ctx context.Context, params *PatchApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217LegalHoldsHeldEntities request
	PostApi217LegalHoldsHeldEntities(ctx context.Context, params *PostApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217LifecycleRules request
	DeleteApi217LifecycleRules(ctx context.Context, params *DeleteApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217LifecycleRules request
	GetApi217LifecycleRules(ctx context.Context, params *GetApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217LifecycleRulesWithBody request with any body
	PatchApi217LifecycleRulesWithBody(ctx context.Context, params *PatchApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217LifecycleRules(ctx context.Context, params *PatchApi217LifecycleRulesParams, body PatchApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217LifecycleRulesWithBody request with any body
	PostApi217LifecycleRulesWithBody(ctx context.Context, params *PostApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217LifecycleRules(ctx context.Context, params *PostApi217LifecycleRulesParams, body PostApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217LinkAggregationGroups request
	DeleteApi217LinkAggregationGroups(ctx context.Context, params *DeleteApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217LinkAggregationGroups request
	GetApi217LinkAggregationGroups(ctx context.Context, params *GetApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217LinkAggregationGroupsWithBody request with any body
	PatchApi217LinkAggregationGroupsWithBody(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217LinkAggregationGroups(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, body PatchApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217LinkAggregationGroupsWithBody request with any body
	PostApi217LinkAggregationGroupsWithBody(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217LinkAggregationGroups(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, body PostApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Logs request
	GetApi217Logs(ctx context.Context, params *GetApi217LogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217LogsAsync request
	GetApi217LogsAsync(ctx context.Context, params *GetApi217LogsAsyncParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217LogsAsyncWithBody request with any body
	PatchApi217LogsAsyncWithBody(ctx context.Context, params *PatchApi217LogsAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217LogsAsync(ctx context.Context, params *PatchApi217LogsAsyncParams, body PatchApi217LogsAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217LogsAsyncDownload request
	GetApi217LogsAsyncDownload(ctx context.Context, params *GetApi217LogsAsyncDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217MaintenanceWindows request
	DeleteApi217MaintenanceWindows(ctx context.Context, params *DeleteApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217MaintenanceWindows request
	GetApi217MaintenanceWindows(ctx context.Context, params *GetApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217MaintenanceWindowsWithBody request with any body
	PostApi217MaintenanceWindowsWithBody(ctx context.Context, params *PostApi217MaintenanceWindowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217MaintenanceWindows(ctx context.Context, params *PostApi217MaintenanceWindowsParams, body PostApi217MaintenanceWindowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkAccessPolicies request
	GetApi217NetworkAccessPolicies(ctx context.Context, params *GetApi217NetworkAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217NetworkAccessPoliciesWithBody request with any body
	PatchApi217NetworkAccessPoliciesWithBody(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217NetworkAccessPolicies(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, body PatchApi217NetworkAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkAccessPoliciesMembers request
	GetApi217NetworkAccessPoliciesMembers(ctx context.Context, params *GetApi217NetworkAccessPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217NetworkAccessPoliciesRules request
	DeleteApi217NetworkAccessPoliciesRules(ctx context.Context, params *DeleteApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkAccessPoliciesRules request
	GetApi217NetworkAccessPoliciesRules(ctx context.Context, params *GetApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217NetworkAccessPoliciesRulesWithBody request with any body
	PatchApi217NetworkAccessPoliciesRulesWithBody(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217NetworkAccessPoliciesRules(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, body PatchApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217NetworkAccessPoliciesRulesWithBody request with any body
	PostApi217NetworkAccessPoliciesRulesWithBody(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217NetworkAccessPoliciesRules(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, body PostApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217NetworkInterfaces request
	DeleteApi217NetworkInterfaces(ctx context.Context, params *DeleteApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkInterfaces request
	GetApi217NetworkInterfaces(ctx context.Context, params *GetApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217NetworkInterfacesWithBody request with any body
	PatchApi217NetworkInterfacesWithBody(ctx context.Context, params *PatchApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217NetworkInterfaces(ctx context.Context, params *PatchApi217NetworkInterfacesParams, body PatchApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217NetworkInterfacesWithBody request with any body
	PostApi217NetworkInterfacesWithBody(ctx context.Context, params *PostApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217NetworkInterfaces(ctx context.Context, params *PostApi217NetworkInterfacesParams, body PostApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkInterfacesConnectors request
	GetApi217NetworkInterfacesConnectors(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217NetworkInterfacesConnectorsWithBody request with any body
	PatchApi217NetworkInterfacesConnectorsWithBody(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217NetworkInterfacesConnectors(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, body PatchApi217NetworkInterfacesConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkInterfacesConnectorsPerformance request
	GetApi217NetworkInterfacesConnectorsPerformance(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkInterfacesConnectorsSettings request
	GetApi217NetworkInterfacesConnectorsSettings(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkInterfacesPing request
	GetApi217NetworkInterfacesPing(ctx context.Context, params *GetApi217NetworkInterfacesPingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217NetworkInterfacesTlsPolicies request
	DeleteApi217NetworkInterfacesTlsPolicies(ctx context.Context, params *DeleteApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkInterfacesTlsPolicies request
	GetApi217NetworkInterfacesTlsPolicies(ctx context.Context, params *GetApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217NetworkInterfacesTlsPolicies request
	PostApi217NetworkInterfacesTlsPolicies(ctx context.Context, params *PostApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NetworkInterfacesTrace request
	GetApi217NetworkInterfacesTrace(ctx context.Context, params *GetApi217NetworkInterfacesTraceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217NfsExportPolicies request
	DeleteApi217NfsExportPolicies(ctx context.Context, params *DeleteApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NfsExportPolicies request
	GetApi217NfsExportPolicies(ctx context.Context, params *GetApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217NfsExportPoliciesWithBody request with any body
	PatchApi217NfsExportPoliciesWithBody(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217NfsExportPolicies(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, body PatchApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217NfsExportPoliciesWithBody request with any body
	PostApi217NfsExportPoliciesWithBody(ctx context.Context, params *PostApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217NfsExportPolicies(ctx context.Context, params *PostApi217NfsExportPoliciesParams, body PostApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217NfsExportPoliciesRules request
	DeleteApi217NfsExportPoliciesRules(ctx context.Context, params *DeleteApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217NfsExportPoliciesRules request
	GetApi217NfsExportPoliciesRules(ctx context.Context, params *GetApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217NfsExportPoliciesRulesWithBody request with any body
	PatchApi217NfsExportPoliciesRulesWithBody(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217NfsExportPoliciesRules(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, body PatchApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217NfsExportPoliciesRulesWithBody request with any body
	PostApi217NfsExportPoliciesRulesWithBody(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217NfsExportPoliciesRules(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, body PostApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreAccessKeys request
	DeleteApi217ObjectStoreAccessKeys(ctx context.Context, params *DeleteApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreAccessKeys request
	GetApi217ObjectStoreAccessKeys(ctx context.Context, params *GetApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreAccessKeysWithBody request with any body
	PatchApi217ObjectStoreAccessKeysWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreAccessKeys(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, body PatchApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreAccessKeysWithBody request with any body
	PostApi217ObjectStoreAccessKeysWithBody(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ObjectStoreAccessKeys(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, body PostApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreAccessPolicies request
	DeleteApi217ObjectStoreAccessPolicies(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreAccessPolicies request
	GetApi217ObjectStoreAccessPolicies(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreAccessPoliciesWithBody request with any body
	PatchApi217ObjectStoreAccessPoliciesWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreAccessPolicies(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, body PatchApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreAccessPoliciesWithBody request with any body
	PostApi217ObjectStoreAccessPoliciesWithBody(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ObjectStoreAccessPolicies(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, body PostApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreAccessPoliciesObjectStoreRoles request
	DeleteApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreAccessPoliciesObjectStoreRoles request
	GetApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreAccessPoliciesObjectStoreRoles request
	PostApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsers request
	DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreAccessPoliciesObjectStoreUsers request
	GetApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreAccessPoliciesObjectStoreUsers request
	PostApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreAccessPoliciesRules request
	DeleteApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreAccessPoliciesRules request
	GetApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreAccessPoliciesRulesWithBody request with any body
	PatchApi217ObjectStoreAccessPoliciesRulesWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, body PatchApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreAccessPoliciesRulesWithBody request with any body
	PostApi217ObjectStoreAccessPoliciesRulesWithBody(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, body PostApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreAccessPolicyActions request
	GetApi217ObjectStoreAccessPolicyActions(ctx context.Context, params *GetApi217ObjectStoreAccessPolicyActionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreAccounts request
	DeleteApi217ObjectStoreAccounts(ctx context.Context, params *DeleteApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreAccounts request
	GetApi217ObjectStoreAccounts(ctx context.Context, params *GetApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreAccountsWithBody request with any body
	PatchApi217ObjectStoreAccountsWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreAccounts(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, body PatchApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreAccountsWithBody request with any body
	PostApi217ObjectStoreAccountsWithBody(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ObjectStoreAccounts(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, body PostApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreRemoteCredentials request
	DeleteApi217ObjectStoreRemoteCredentials(ctx context.Context, params *DeleteApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreRemoteCredentials request
	GetApi217ObjectStoreRemoteCredentials(ctx context.Context, params *GetApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreRemoteCredentialsWithBody request with any body
	PatchApi217ObjectStoreRemoteCredentialsWithBody(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreRemoteCredentials(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, body PatchApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreRemoteCredentialsWithBody request with any body
	PostApi217ObjectStoreRemoteCredentialsWithBody(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ObjectStoreRemoteCredentials(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, body PostApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreRoles request
	DeleteApi217ObjectStoreRoles(ctx context.Context, params *DeleteApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreRoles request
	GetApi217ObjectStoreRoles(ctx context.Context, params *GetApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreRolesWithBody request with any body
	PatchApi217ObjectStoreRolesWithBody(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreRoles(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, body PatchApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreRolesWithBody request with any body
	PostApi217ObjectStoreRolesWithBody(ctx context.Context, params *PostApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ObjectStoreRoles(ctx context.Context, params *PostApi217ObjectStoreRolesParams, body PostApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreRolesObjectStoreAccessPolicies request
	DeleteApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreRolesObjectStoreAccessPolicies request
	GetApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreRolesObjectStoreAccessPolicies request
	PostApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreRolesObjectStoreTrustPolicies request
	GetApi217ObjectStoreRolesObjectStoreTrustPolicies(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownload request
	GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownload(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRules request
	DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRules request
	GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody request with any body
	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody request with any body
	PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBody request with any body
	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBody(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUpload(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreUsers request
	DeleteApi217ObjectStoreUsers(ctx context.Context, params *DeleteApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreUsers request
	GetApi217ObjectStoreUsers(ctx context.Context, params *GetApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreUsers request
	PostApi217ObjectStoreUsers(ctx context.Context, params *PostApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreUsersObjectStoreAccessPolicies request
	DeleteApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx context.Context, params *DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreUsersObjectStoreAccessPolicies request
	GetApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx context.Context, params *GetApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreUsersObjectStoreAccessPolicies request
	PostApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx context.Context, params *PostApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217ObjectStoreVirtualHosts request
	DeleteApi217ObjectStoreVirtualHosts(ctx context.Context, params *DeleteApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217ObjectStoreVirtualHosts request
	GetApi217ObjectStoreVirtualHosts(ctx context.Context, params *GetApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ObjectStoreVirtualHosts request
	PostApi217ObjectStoreVirtualHosts(ctx context.Context, params *PostApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PasswordPolicies request
	GetApi217PasswordPolicies(ctx context.Context, params *GetApi217PasswordPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217PasswordPoliciesWithBody request with any body
	PatchApi217PasswordPoliciesWithBody(ctx context.Context, params *PatchApi217PasswordPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217PasswordPolicies(ctx context.Context, params *PatchApi217PasswordPoliciesParams, body PatchApi217PasswordPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Policies request
	DeleteApi217Policies(ctx context.Context, params *DeleteApi217PoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Policies request
	GetApi217Policies(ctx context.Context, params *GetApi217PoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217PoliciesWithBody request with any body
	PatchApi217PoliciesWithBody(ctx context.Context, params *PatchApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Policies(ctx context.Context, params *PatchApi217PoliciesParams, body PatchApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217PoliciesWithBody request with any body
	PostApi217PoliciesWithBody(ctx context.Context, params *PostApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Policies(ctx context.Context, params *PostApi217PoliciesParams, body PostApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PoliciesAll request
	GetApi217PoliciesAll(ctx context.Context, params *GetApi217PoliciesAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PoliciesAllMembers request
	GetApi217PoliciesAllMembers(ctx context.Context, params *GetApi217PoliciesAllMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217PoliciesFileSystemReplicaLinks request
	DeleteApi217PoliciesFileSystemReplicaLinks(ctx context.Context, params *DeleteApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PoliciesFileSystemReplicaLinks request
	GetApi217PoliciesFileSystemReplicaLinks(ctx context.Context, params *GetApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217PoliciesFileSystemReplicaLinks request
	PostApi217PoliciesFileSystemReplicaLinks(ctx context.Context, params *PostApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217PoliciesFileSystemSnapshots request
	DeleteApi217PoliciesFileSystemSnapshots(ctx context.Context, params *DeleteApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PoliciesFileSystemSnapshots request
	GetApi217PoliciesFileSystemSnapshots(ctx context.Context, params *GetApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217PoliciesFileSystems request
	DeleteApi217PoliciesFileSystems(ctx context.Context, params *DeleteApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PoliciesFileSystems request
	GetApi217PoliciesFileSystems(ctx context.Context, params *GetApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217PoliciesFileSystems request
	PostApi217PoliciesFileSystems(ctx context.Context, params *PostApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PoliciesMembers request
	GetApi217PoliciesMembers(ctx context.Context, params *GetApi217PoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217PublicKeys request
	DeleteApi217PublicKeys(ctx context.Context, params *DeleteApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PublicKeys request
	GetApi217PublicKeys(ctx context.Context, params *GetApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217PublicKeysWithBody request with any body
	PostApi217PublicKeysWithBody(ctx context.Context, params *PostApi217PublicKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217PublicKeys(ctx context.Context, params *PostApi217PublicKeysParams, body PostApi217PublicKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217PublicKeysUses request
	GetApi217PublicKeysUses(ctx context.Context, params *GetApi217PublicKeysUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217QosPolicies request
	DeleteApi217QosPolicies(ctx context.Context, params *DeleteApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217QosPolicies request
	GetApi217QosPolicies(ctx context.Context, params *GetApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217QosPoliciesWithBody request with any body
	PatchApi217QosPoliciesWithBody(ctx context.Context, params *PatchApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217QosPolicies(ctx context.Context, params *PatchApi217QosPoliciesParams, body PatchApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217QosPoliciesWithBody request with any body
	PostApi217QosPoliciesWithBody(ctx context.Context, params *PostApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217QosPolicies(ctx context.Context, params *PostApi217QosPoliciesParams, body PostApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217QosPoliciesFileSystems request
	GetApi217QosPoliciesFileSystems(ctx context.Context, params *GetApi217QosPoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217QosPoliciesMembers request
	GetApi217QosPoliciesMembers(ctx context.Context, params *GetApi217QosPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217QuotasGroups request
	DeleteApi217QuotasGroups(ctx context.Context, params *DeleteApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217QuotasGroups request
	GetApi217QuotasGroups(ctx context.Context, params *GetApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217QuotasGroupsWithBody request with any body
	PatchApi217QuotasGroupsWithBody(ctx context.Context, params *PatchApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217QuotasGroups(ctx context.Context, params *PatchApi217QuotasGroupsParams, body PatchApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217QuotasGroupsWithBody request with any body
	PostApi217QuotasGroupsWithBody(ctx context.Context, params *PostApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217QuotasGroups(ctx context.Context, params *PostApi217QuotasGroupsParams, body PostApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217QuotasSettings request
	GetApi217QuotasSettings(ctx context.Context, params *GetApi217QuotasSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217QuotasSettingsWithBody request with any body
	PatchApi217QuotasSettingsWithBody(ctx context.Context, params *PatchApi217QuotasSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217QuotasSettings(ctx context.Context, params *PatchApi217QuotasSettingsParams, body PatchApi217QuotasSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217QuotasUsers request
	DeleteApi217QuotasUsers(ctx context.Context, params *DeleteApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217QuotasUsers request
	GetApi217QuotasUsers(ctx context.Context, params *GetApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217QuotasUsersWithBody request with any body
	PatchApi217QuotasUsersWithBody(ctx context.Context, params *PatchApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217QuotasUsers(ctx context.Context, params *PatchApi217QuotasUsersParams, body PatchApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217QuotasUsersWithBody request with any body
	PostApi217QuotasUsersWithBody(ctx context.Context, params *PostApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217QuotasUsers(ctx context.Context, params *PostApi217QuotasUsersParams, body PostApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217RapidDataLocking request
	GetApi217RapidDataLocking(ctx context.Context, params *GetApi217RapidDataLockingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217RapidDataLockingWithBody request with any body
	PatchApi217RapidDataLockingWithBody(ctx context.Context, params *PatchApi217RapidDataLockingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217RapidDataLocking(ctx context.Context, params *PatchApi217RapidDataLockingParams, body PatchApi217RapidDataLockingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217RapidDataLockingRotate request
	PostApi217RapidDataLockingRotate(ctx context.Context, params *PostApi217RapidDataLockingRotateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217RapidDataLockingTest request
	GetApi217RapidDataLockingTest(ctx context.Context, params *GetApi217RapidDataLockingTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217RemoteArrays request
	GetApi217RemoteArrays(ctx context.Context, params *GetApi217RemoteArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Roles request
	GetApi217Roles(ctx context.Context, params *GetApi217RolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Servers request
	DeleteApi217Servers(ctx context.Context, params *DeleteApi217ServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Servers request
	GetApi217Servers(ctx context.Context, params *GetApi217ServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217ServersWithBody request with any body
	PatchApi217ServersWithBody(ctx context.Context, params *PatchApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Servers(ctx context.Context, params *PatchApi217ServersParams, body PatchApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217ServersWithBody request with any body
	PostApi217ServersWithBody(ctx context.Context, params *PostApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Servers(ctx context.Context, params *PostApi217ServersParams, body PostApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Sessions request
	GetApi217Sessions(ctx context.Context, params *GetApi217SessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SmbClientPolicies request
	DeleteApi217SmbClientPolicies(ctx context.Context, params *DeleteApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SmbClientPolicies request
	GetApi217SmbClientPolicies(ctx context.Context, params *GetApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SmbClientPoliciesWithBody request with any body
	PatchApi217SmbClientPoliciesWithBody(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SmbClientPolicies(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, body PatchApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SmbClientPoliciesWithBody request with any body
	PostApi217SmbClientPoliciesWithBody(ctx context.Context, params *PostApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SmbClientPolicies(ctx context.Context, params *PostApi217SmbClientPoliciesParams, body PostApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SmbClientPoliciesRules request
	DeleteApi217SmbClientPoliciesRules(ctx context.Context, params *DeleteApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SmbClientPoliciesRules request
	GetApi217SmbClientPoliciesRules(ctx context.Context, params *GetApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SmbClientPoliciesRulesWithBody request with any body
	PatchApi217SmbClientPoliciesRulesWithBody(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SmbClientPoliciesRules(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, body PatchApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SmbClientPoliciesRulesWithBody request with any body
	PostApi217SmbClientPoliciesRulesWithBody(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SmbClientPoliciesRules(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, body PostApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SmbSharePolicies request
	DeleteApi217SmbSharePolicies(ctx context.Context, params *DeleteApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SmbSharePolicies request
	GetApi217SmbSharePolicies(ctx context.Context, params *GetApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SmbSharePoliciesWithBody request with any body
	PatchApi217SmbSharePoliciesWithBody(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SmbSharePolicies(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, body PatchApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SmbSharePoliciesWithBody request with any body
	PostApi217SmbSharePoliciesWithBody(ctx context.Context, params *PostApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SmbSharePolicies(ctx context.Context, params *PostApi217SmbSharePoliciesParams, body PostApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SmbSharePoliciesRules request
	DeleteApi217SmbSharePoliciesRules(ctx context.Context, params *DeleteApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SmbSharePoliciesRules request
	GetApi217SmbSharePoliciesRules(ctx context.Context, params *GetApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SmbSharePoliciesRulesWithBody request with any body
	PatchApi217SmbSharePoliciesRulesWithBody(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SmbSharePoliciesRules(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, body PatchApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SmbSharePoliciesRulesWithBody request with any body
	PostApi217SmbSharePoliciesRulesWithBody(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SmbSharePoliciesRules(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, body PostApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SmtpServers request
	GetApi217SmtpServers(ctx context.Context, params *GetApi217SmtpServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SmtpServersWithBody request with any body
	PatchApi217SmtpServersWithBody(ctx context.Context, params *PatchApi217SmtpServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SmtpServers(ctx context.Context, params *PatchApi217SmtpServersParams, body PatchApi217SmtpServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SnmpAgents request
	GetApi217SnmpAgents(ctx context.Context, params *GetApi217SnmpAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SnmpAgentsWithBody request with any body
	PatchApi217SnmpAgentsWithBody(ctx context.Context, params *PatchApi217SnmpAgentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SnmpAgents(ctx context.Context, params *PatchApi217SnmpAgentsParams, body PatchApi217SnmpAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SnmpAgentsMib request
	GetApi217SnmpAgentsMib(ctx context.Context, params *GetApi217SnmpAgentsMibParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SnmpManagers request
	DeleteApi217SnmpManagers(ctx context.Context, params *DeleteApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SnmpManagers request
	GetApi217SnmpManagers(ctx context.Context, params *GetApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SnmpManagersWithBody request with any body
	PatchApi217SnmpManagersWithBody(ctx context.Context, params *PatchApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SnmpManagers(ctx context.Context, params *PatchApi217SnmpManagersParams, body PatchApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SnmpManagersWithBody request with any body
	PostApi217SnmpManagersWithBody(ctx context.Context, params *PostApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SnmpManagers(ctx context.Context, params *PostApi217SnmpManagersParams, body PostApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SnmpManagersTest request
	GetApi217SnmpManagersTest(ctx context.Context, params *GetApi217SnmpManagersTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SoftwareCheck request
	GetApi217SoftwareCheck(ctx context.Context, params *GetApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SoftwareCheck request
	PostApi217SoftwareCheck(ctx context.Context, params *PostApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SshCertificateAuthorityPolicies request
	DeleteApi217SshCertificateAuthorityPolicies(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SshCertificateAuthorityPolicies request
	GetApi217SshCertificateAuthorityPolicies(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SshCertificateAuthorityPoliciesWithBody request with any body
	PatchApi217SshCertificateAuthorityPoliciesWithBody(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SshCertificateAuthorityPolicies(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, body PatchApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SshCertificateAuthorityPoliciesWithBody request with any body
	PostApi217SshCertificateAuthorityPoliciesWithBody(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SshCertificateAuthorityPolicies(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, body PostApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SshCertificateAuthorityPoliciesAdmins request
	DeleteApi217SshCertificateAuthorityPoliciesAdmins(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SshCertificateAuthorityPoliciesAdmins request
	GetApi217SshCertificateAuthorityPoliciesAdmins(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SshCertificateAuthorityPoliciesAdmins request
	PostApi217SshCertificateAuthorityPoliciesAdmins(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SshCertificateAuthorityPoliciesArrays request
	DeleteApi217SshCertificateAuthorityPoliciesArrays(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SshCertificateAuthorityPoliciesArrays request
	GetApi217SshCertificateAuthorityPoliciesArrays(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SshCertificateAuthorityPoliciesArrays request
	PostApi217SshCertificateAuthorityPoliciesArrays(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SshCertificateAuthorityPoliciesMembers request
	GetApi217SshCertificateAuthorityPoliciesMembers(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SsoOidcIdps request
	DeleteApi217SsoOidcIdps(ctx context.Context, params *DeleteApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SsoOidcIdps request
	GetApi217SsoOidcIdps(ctx context.Context, params *GetApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SsoOidcIdpsWithBody request with any body
	PatchApi217SsoOidcIdpsWithBody(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SsoOidcIdps(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, body PatchApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SsoOidcIdpsWithBody request with any body
	PostApi217SsoOidcIdpsWithBody(ctx context.Context, params *PostApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SsoOidcIdps(ctx context.Context, params *PostApi217SsoOidcIdpsParams, body PostApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SsoSaml2Idps request
	DeleteApi217SsoSaml2Idps(ctx context.Context, params *DeleteApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SsoSaml2Idps request
	GetApi217SsoSaml2Idps(ctx context.Context, params *GetApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SsoSaml2IdpsWithBody request with any body
	PatchApi217SsoSaml2IdpsWithBody(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SsoSaml2Idps(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, body PatchApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SsoSaml2IdpsWithBody request with any body
	PostApi217SsoSaml2IdpsWithBody(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SsoSaml2Idps(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, body PostApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SsoSaml2IdpsTest request
	GetApi217SsoSaml2IdpsTest(ctx context.Context, params *GetApi217SsoSaml2IdpsTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SsoSaml2IdpsTestWithBody request with any body
	PatchApi217SsoSaml2IdpsTestWithBody(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SsoSaml2IdpsTest(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, body PatchApi217SsoSaml2IdpsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Subnets request
	DeleteApi217Subnets(ctx context.Context, params *DeleteApi217SubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Subnets request
	GetApi217Subnets(ctx context.Context, params *GetApi217SubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SubnetsWithBody request with any body
	PatchApi217SubnetsWithBody(ctx context.Context, params *PatchApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Subnets(ctx context.Context, params *PatchApi217SubnetsParams, body PatchApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SubnetsWithBody request with any body
	PostApi217SubnetsWithBody(ctx context.Context, params *PostApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Subnets(ctx context.Context, params *PostApi217SubnetsParams, body PostApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Support request
	GetApi217Support(ctx context.Context, params *GetApi217SupportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SupportWithBody request with any body
	PatchApi217SupportWithBody(ctx context.Context, params *PatchApi217SupportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Support(ctx context.Context, params *PatchApi217SupportParams, body PatchApi217SupportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SupportDiagnostics request
	GetApi217SupportDiagnostics(ctx context.Context, params *GetApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SupportDiagnostics request
	PostApi217SupportDiagnostics(ctx context.Context, params *PostApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SupportDiagnosticsDetails request
	GetApi217SupportDiagnosticsDetails(ctx context.Context, params *GetApi217SupportDiagnosticsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SupportTest request
	GetApi217SupportTest(ctx context.Context, params *GetApi217SupportTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SupportVerificationKeys request
	GetApi217SupportVerificationKeys(ctx context.Context, params *GetApi217SupportVerificationKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SupportVerificationKeysWithBody request with any body
	PatchApi217SupportVerificationKeysWithBody(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SupportVerificationKeys(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, body PatchApi217SupportVerificationKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217SyslogServers request
	DeleteApi217SyslogServers(ctx context.Context, params *DeleteApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SyslogServers request
	GetApi217SyslogServers(ctx context.Context, params *GetApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SyslogServersWithBody request with any body
	PatchApi217SyslogServersWithBody(ctx context.Context, params *PatchApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SyslogServers(ctx context.Context, params *PatchApi217SyslogServersParams, body PatchApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217SyslogServersWithBody request with any body
	PostApi217SyslogServersWithBody(ctx context.Context, params *PostApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217SyslogServers(ctx context.Context, params *PostApi217SyslogServersParams, body PostApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SyslogServersSettings request
	GetApi217SyslogServersSettings(ctx context.Context, params *GetApi217SyslogServersSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217SyslogServersSettingsWithBody request with any body
	PatchApi217SyslogServersSettingsWithBody(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217SyslogServersSettings(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, body PatchApi217SyslogServersSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217SyslogServersTest request
	GetApi217SyslogServersTest(ctx context.Context, params *GetApi217SyslogServersTestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217Targets request
	DeleteApi217Targets(ctx context.Context, params *DeleteApi217TargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217Targets request
	GetApi217Targets(ctx context.Context, params *GetApi217TargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217TargetsWithBody request with any body
	PatchApi217TargetsWithBody(ctx context.Context, params *PatchApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217Targets(ctx context.Context, params *PatchApi217TargetsParams, body PatchApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217TargetsWithBody request with any body
	PostApi217TargetsWithBody(ctx context.Context, params *PostApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217Targets(ctx context.Context, params *PostApi217TargetsParams, body PostApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217TargetsPerformanceReplication request
	GetApi217TargetsPerformanceReplication(ctx context.Context, params *GetApi217TargetsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217TlsPolicies request
	DeleteApi217TlsPolicies(ctx context.Context, params *DeleteApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217TlsPolicies request
	GetApi217TlsPolicies(ctx context.Context, params *GetApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217TlsPoliciesWithBody request with any body
	PatchApi217TlsPoliciesWithBody(ctx context.Context, params *PatchApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217TlsPolicies(ctx context.Context, params *PatchApi217TlsPoliciesParams, body PatchApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217TlsPoliciesWithBody request with any body
	PostApi217TlsPoliciesWithBody(ctx context.Context, params *PostApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217TlsPolicies(ctx context.Context, params *PostApi217TlsPoliciesParams, body PostApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217TlsPoliciesMembers request
	GetApi217TlsPoliciesMembers(ctx context.Context, params *GetApi217TlsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217TlsPoliciesNetworkInterfaces request
	DeleteApi217TlsPoliciesNetworkInterfaces(ctx context.Context, params *DeleteApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217TlsPoliciesNetworkInterfaces request
	GetApi217TlsPoliciesNetworkInterfaces(ctx context.Context, params *GetApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217TlsPoliciesNetworkInterfaces request
	PostApi217TlsPoliciesNetworkInterfaces(ctx context.Context, params *PostApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217UsageGroups request
	GetApi217UsageGroups(ctx context.Context, params *GetApi217UsageGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217UsageUsers request
	GetApi217UsageUsers(ctx context.Context, params *GetApi217UsageUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApi217WormDataPolicies request
	DeleteApi217WormDataPolicies(ctx context.Context, params *DeleteApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217WormDataPolicies request
	GetApi217WormDataPolicies(ctx context.Context, params *GetApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApi217WormDataPoliciesWithBody request with any body
	PatchApi217WormDataPoliciesWithBody(ctx context.Context, params *PatchApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApi217WormDataPolicies(ctx context.Context, params *PatchApi217WormDataPoliciesParams, body PatchApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApi217WormDataPoliciesWithBody request with any body
	PostApi217WormDataPoliciesWithBody(ctx context.Context, params *PostApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostApi217WormDataPolicies(ctx context.Context, params *PostApi217WormDataPoliciesParams, body PostApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApi217WormDataPoliciesMembers request
	GetApi217WormDataPoliciesMembers(ctx context.Context, params *GetApi217WormDataPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiApiVersion request
	GetApiApiVersion(ctx context.Context, params *GetApiApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiLogin request
	PostApiLogin(ctx context.Context, params *PostApiLoginParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiLoginBanner request
	GetApiLoginBanner(ctx context.Context, params *GetApiLoginBannerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostApiLogout request
	PostApiLogout(ctx context.Context, params *PostApiLogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOauth210TokenWithBody request with any body
	PostOauth210TokenWithBody(ctx context.Context, params *PostOauth210TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOauth210TokenWithFormdataBody(ctx context.Context, params *PostOauth210TokenParams, body PostOauth210TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteApi217ActiveDirectory(ctx context.Context, params *DeleteApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ActiveDirectoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ActiveDirectory(ctx context.Context, params *GetApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ActiveDirectoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ActiveDirectoryWithBody(ctx context.Context, params *PatchApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ActiveDirectoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ActiveDirectory(ctx context.Context, params *PatchApi217ActiveDirectoryParams, body PatchApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ActiveDirectoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ActiveDirectoryWithBody(ctx context.Context, params *PostApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ActiveDirectoryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ActiveDirectory(ctx context.Context, params *PostApi217ActiveDirectoryParams, body PostApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ActiveDirectoryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ActiveDirectoryTest(ctx context.Context, params *GetApi217ActiveDirectoryTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ActiveDirectoryTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Admins(ctx context.Context, params *DeleteApi217AdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217AdminsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Admins(ctx context.Context, params *GetApi217AdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AdminsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AdminsWithBody(ctx context.Context, params *PatchApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AdminsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Admins(ctx context.Context, params *PatchApi217AdminsParams, body PatchApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AdminsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AdminsWithBody(ctx context.Context, params *PostApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AdminsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Admins(ctx context.Context, params *PostApi217AdminsParams, body PostApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AdminsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217AdminsApiTokens(ctx context.Context, params *DeleteApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217AdminsApiTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AdminsApiTokens(ctx context.Context, params *GetApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AdminsApiTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AdminsApiTokens(ctx context.Context, params *PostApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AdminsApiTokensRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217AdminsCache(ctx context.Context, params *DeleteApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217AdminsCacheRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AdminsCache(ctx context.Context, params *GetApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AdminsCacheRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AdminsSettings(ctx context.Context, params *GetApi217AdminsSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AdminsSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AdminsSettingsWithBody(ctx context.Context, params *PatchApi217AdminsSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AdminsSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AdminsSettings(ctx context.Context, params *PatchApi217AdminsSettingsParams, body PatchApi217AdminsSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AdminsSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217AdminsSshCertificateAuthorityPolicies(ctx context.Context, params *DeleteApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217AdminsSshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AdminsSshCertificateAuthorityPolicies(ctx context.Context, params *GetApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AdminsSshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AdminsSshCertificateAuthorityPolicies(ctx context.Context, params *PostApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AdminsSshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217AlertWatchers(ctx context.Context, params *DeleteApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217AlertWatchersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AlertWatchers(ctx context.Context, params *GetApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AlertWatchersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AlertWatchersWithBody(ctx context.Context, params *PatchApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AlertWatchersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AlertWatchers(ctx context.Context, params *PatchApi217AlertWatchersParams, body PatchApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AlertWatchersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AlertWatchersWithBody(ctx context.Context, params *PostApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AlertWatchersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AlertWatchers(ctx context.Context, params *PostApi217AlertWatchersParams, body PostApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AlertWatchersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AlertWatchersTest(ctx context.Context, params *GetApi217AlertWatchersTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AlertWatchersTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Alerts(ctx context.Context, params *GetApi217AlertsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AlertsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AlertsWithBody(ctx context.Context, params *PatchApi217AlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AlertsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Alerts(ctx context.Context, params *PatchApi217AlertsParams, body PatchApi217AlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AlertsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ApiClients(ctx context.Context, params *DeleteApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ApiClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ApiClients(ctx context.Context, params *GetApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ApiClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ApiClientsWithBody(ctx context.Context, params *PatchApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ApiClientsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ApiClients(ctx context.Context, params *PatchApi217ApiClientsParams, body PatchApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ApiClientsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ApiClientsWithBody(ctx context.Context, params *PostApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ApiClientsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ApiClients(ctx context.Context, params *PostApi217ApiClientsParams, body PostApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ApiClientsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ArrayConnections(ctx context.Context, params *DeleteApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ArrayConnectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArrayConnections(ctx context.Context, params *GetApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArrayConnectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ArrayConnectionsWithBody(ctx context.Context, params *PatchApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ArrayConnectionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ArrayConnections(ctx context.Context, params *PatchApi217ArrayConnectionsParams, body PatchApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ArrayConnectionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ArrayConnectionsWithBody(ctx context.Context, params *PostApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ArrayConnectionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ArrayConnections(ctx context.Context, params *PostApi217ArrayConnectionsParams, body PostApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ArrayConnectionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArrayConnectionsConnectionKey(ctx context.Context, params *GetApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArrayConnectionsConnectionKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ArrayConnectionsConnectionKey(ctx context.Context, params *PostApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ArrayConnectionsConnectionKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArrayConnectionsPath(ctx context.Context, params *GetApi217ArrayConnectionsPathParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArrayConnectionsPathRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArrayConnectionsPerformanceReplication(ctx context.Context, params *GetApi217ArrayConnectionsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArrayConnectionsPerformanceReplicationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Arrays(ctx context.Context, params *GetApi217ArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ArraysWithBody(ctx context.Context, params *PatchApi217ArraysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ArraysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Arrays(ctx context.Context, params *PatchApi217ArraysParams, body PatchApi217ArraysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ArraysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysClientsPerformance(ctx context.Context, params *GetApi217ArraysClientsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysClientsPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysEula(ctx context.Context, params *GetApi217ArraysEulaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysEulaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ArraysEulaWithBody(ctx context.Context, params *PatchApi217ArraysEulaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ArraysEulaRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ArraysEula(ctx context.Context, params *PatchApi217ArraysEulaParams, body PatchApi217ArraysEulaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ArraysEulaRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ArraysFactoryResetToken(ctx context.Context, params *DeleteApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ArraysFactoryResetTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysFactoryResetToken(ctx context.Context, params *GetApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysFactoryResetTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ArraysFactoryResetToken(ctx context.Context, params *PostApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ArraysFactoryResetTokenRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysHttpSpecificPerformance(ctx context.Context, params *GetApi217ArraysHttpSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysHttpSpecificPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysNfsSpecificPerformance(ctx context.Context, params *GetApi217ArraysNfsSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysNfsSpecificPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysPerformance(ctx context.Context, params *GetApi217ArraysPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysPerformanceReplication(ctx context.Context, params *GetApi217ArraysPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysPerformanceReplicationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysS3SpecificPerformance(ctx context.Context, params *GetApi217ArraysS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysS3SpecificPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysSpace(ctx context.Context, params *GetApi217ArraysSpaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysSpaceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysSpaceStorageClasses(ctx context.Context, params *GetApi217ArraysSpaceStorageClassesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysSpaceStorageClassesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ArraysSshCertificateAuthorityPolicies(ctx context.Context, params *DeleteApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ArraysSshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysSshCertificateAuthorityPolicies(ctx context.Context, params *GetApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysSshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ArraysSshCertificateAuthorityPolicies(ctx context.Context, params *PostApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ArraysSshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ArraysSupportedTimeZones(ctx context.Context, params *GetApi217ArraysSupportedTimeZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ArraysSupportedTimeZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217AuditFileSystemsPolicies(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217AuditFileSystemsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AuditFileSystemsPolicies(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AuditFileSystemsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AuditFileSystemsPoliciesWithBody(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AuditFileSystemsPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217AuditFileSystemsPolicies(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, body PatchApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217AuditFileSystemsPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AuditFileSystemsPoliciesWithBody(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AuditFileSystemsPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AuditFileSystemsPolicies(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, body PostApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AuditFileSystemsPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217AuditFileSystemsPoliciesMembers(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217AuditFileSystemsPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217AuditFileSystemsPoliciesMembers(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AuditFileSystemsPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217AuditFileSystemsPoliciesMembers(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217AuditFileSystemsPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Audits(ctx context.Context, params *GetApi217AuditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217AuditsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Blades(ctx context.Context, params *GetApi217BladesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BladesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217BucketReplicaLinks(ctx context.Context, params *DeleteApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217BucketReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217BucketReplicaLinks(ctx context.Context, params *GetApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217BucketReplicaLinksWithBody(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217BucketReplicaLinksRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217BucketReplicaLinks(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, body PatchApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217BucketReplicaLinksRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketReplicaLinksWithBody(ctx context.Context, params *PostApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketReplicaLinksRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketReplicaLinks(ctx context.Context, params *PostApi217BucketReplicaLinksParams, body PostApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketReplicaLinksRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Buckets(ctx context.Context, params *DeleteApi217BucketsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217BucketsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Buckets(ctx context.Context, params *GetApi217BucketsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217BucketsWithBody(ctx context.Context, params *PatchApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217BucketsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Buckets(ctx context.Context, params *PatchApi217BucketsParams, body PatchApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217BucketsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsWithBody(ctx context.Context, params *PostApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Buckets(ctx context.Context, params *PostApi217BucketsParams, body PostApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217BucketsBucketAccessPolicies(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217BucketsBucketAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217BucketsBucketAccessPolicies(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketsBucketAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsBucketAccessPoliciesWithBody(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsBucketAccessPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsBucketAccessPolicies(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, body PostApi217BucketsBucketAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsBucketAccessPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217BucketsBucketAccessPoliciesRules(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217BucketsBucketAccessPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217BucketsBucketAccessPoliciesRules(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketsBucketAccessPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsBucketAccessPoliciesRulesWithBody(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsBucketAccessPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsBucketAccessPoliciesRules(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, body PostApi217BucketsBucketAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsBucketAccessPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217BucketsCrossOriginResourceSharingPolicies(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217BucketsCrossOriginResourceSharingPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217BucketsCrossOriginResourceSharingPolicies(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketsCrossOriginResourceSharingPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsCrossOriginResourceSharingPoliciesWithBody(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsCrossOriginResourceSharingPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsCrossOriginResourceSharingPolicies(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsCrossOriginResourceSharingPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBody(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsCrossOriginResourceSharingPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217BucketsPerformance(ctx context.Context, params *GetApi217BucketsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketsPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217BucketsS3SpecificPerformance(ctx context.Context, params *GetApi217BucketsS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217BucketsS3SpecificPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217CertificateGroups(ctx context.Context, params *DeleteApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217CertificateGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217CertificateGroups(ctx context.Context, params *GetApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217CertificateGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217CertificateGroups(ctx context.Context, params *PostApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217CertificateGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217CertificateGroupsCertificates(ctx context.Context, params *DeleteApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217CertificateGroupsCertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217CertificateGroupsCertificates(ctx context.Context, params *GetApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217CertificateGroupsCertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217CertificateGroupsCertificates(ctx context.Context, params *PostApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217CertificateGroupsCertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217CertificateGroupsUses(ctx context.Context, params *GetApi217CertificateGroupsUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217CertificateGroupsUsesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Certificates(ctx context.Context, params *DeleteApi217CertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217CertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Certificates(ctx context.Context, params *GetApi217CertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217CertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217CertificatesWithBody(ctx context.Context, params *PatchApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217CertificatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Certificates(ctx context.Context, params *PatchApi217CertificatesParams, body PatchApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217CertificatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217CertificatesWithBody(ctx context.Context, params *PostApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217CertificatesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Certificates(ctx context.Context, params *PostApi217CertificatesParams, body PostApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217CertificatesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217CertificatesCertificateGroups(ctx context.Context, params *DeleteApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217CertificatesCertificateGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217CertificatesCertificateGroups(ctx context.Context, params *GetApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217CertificatesCertificateGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217CertificatesCertificateGroups(ctx context.Context, params *PostApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217CertificatesCertificateGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217CertificatesUses(ctx context.Context, params *GetApi217CertificatesUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217CertificatesUsesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217DirectoryServices(ctx context.Context, params *GetApi217DirectoryServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217DirectoryServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217DirectoryServicesWithBody(ctx context.Context, params *PatchApi217DirectoryServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DirectoryServicesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217DirectoryServices(ctx context.Context, params *PatchApi217DirectoryServicesParams, body PatchApi217DirectoryServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DirectoryServicesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217DirectoryServicesRoles(ctx context.Context, params *DeleteApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217DirectoryServicesRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217DirectoryServicesRoles(ctx context.Context, params *GetApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217DirectoryServicesRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217DirectoryServicesRolesWithBody(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DirectoryServicesRolesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217DirectoryServicesRoles(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, body PatchApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DirectoryServicesRolesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217DirectoryServicesRolesWithBody(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217DirectoryServicesRolesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217DirectoryServicesRoles(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, body PostApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217DirectoryServicesRolesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217DirectoryServicesTest(ctx context.Context, params *GetApi217DirectoryServicesTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217DirectoryServicesTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217DirectoryServicesTestWithBody(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DirectoryServicesTestRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217DirectoryServicesTest(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, body PatchApi217DirectoryServicesTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DirectoryServicesTestRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Dns(ctx context.Context, params *DeleteApi217DnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217DnsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Dns(ctx context.Context, params *GetApi217DnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217DnsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217DnsWithBody(ctx context.Context, params *PatchApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DnsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Dns(ctx context.Context, params *PatchApi217DnsParams, body PatchApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217DnsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217DnsWithBody(ctx context.Context, params *PostApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217DnsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Dns(ctx context.Context, params *PostApi217DnsParams, body PostApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217DnsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Drives(ctx context.Context, params *GetApi217DrivesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217DrivesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemExports(ctx context.Context, params *DeleteApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemExportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemExports(ctx context.Context, params *GetApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemExportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FileSystemExportsWithBody(ctx context.Context, params *PatchApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FileSystemExportsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FileSystemExports(ctx context.Context, params *PatchApi217FileSystemExportsParams, body PatchApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FileSystemExportsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemExportsWithBody(ctx context.Context, params *PostApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemExportsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemExports(ctx context.Context, params *PostApi217FileSystemExportsParams, body PostApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemExportsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemReplicaLinks(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemReplicaLinks(ctx context.Context, params *GetApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FileSystemReplicaLinks(ctx context.Context, params *PatchApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FileSystemReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemReplicaLinksWithBody(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemReplicaLinksRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemReplicaLinks(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, body PostApi217FileSystemReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemReplicaLinksRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemReplicaLinksPolicies(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemReplicaLinksPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemReplicaLinksPolicies(ctx context.Context, params *GetApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemReplicaLinksPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemReplicaLinksPolicies(ctx context.Context, params *PostApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemReplicaLinksPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemReplicaLinksTransfer(ctx context.Context, params *GetApi217FileSystemReplicaLinksTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemReplicaLinksTransferRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemSnapshots(ctx context.Context, params *DeleteApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemSnapshotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemSnapshots(ctx context.Context, params *GetApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemSnapshotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FileSystemSnapshotsWithBody(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FileSystemSnapshotsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FileSystemSnapshots(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, body PatchApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FileSystemSnapshotsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemSnapshotsWithBody(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemSnapshotsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemSnapshots(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, body PostApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemSnapshotsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemSnapshotsPolicies(ctx context.Context, params *DeleteApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemSnapshotsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemSnapshotsPolicies(ctx context.Context, params *GetApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemSnapshotsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemSnapshotsTransfer(ctx context.Context, params *DeleteApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemSnapshotsTransferRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemSnapshotsTransfer(ctx context.Context, params *GetApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemSnapshotsTransferRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystems(ctx context.Context, params *DeleteApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystems(ctx context.Context, params *GetApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FileSystemsWithBody(ctx context.Context, params *PatchApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FileSystemsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FileSystems(ctx context.Context, params *PatchApi217FileSystemsParams, body PatchApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FileSystemsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemsWithBody(ctx context.Context, params *PostApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystems(ctx context.Context, params *PostApi217FileSystemsParams, body PostApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemsAuditPolicies(ctx context.Context, params *DeleteApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemsAuditPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsAuditPolicies(ctx context.Context, params *GetApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsAuditPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemsAuditPolicies(ctx context.Context, params *PostApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemsAuditPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsGroupsPerformance(ctx context.Context, params *GetApi217FileSystemsGroupsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsGroupsPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemsLocks(ctx context.Context, params *DeleteApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemsLocksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsLocks(ctx context.Context, params *GetApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsLocksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsLocksClients(ctx context.Context, params *GetApi217FileSystemsLocksClientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsLocksClientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemsLocksNlmReclamations(ctx context.Context, params *PostApi217FileSystemsLocksNlmReclamationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemsLocksNlmReclamationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemsOpenFiles(ctx context.Context, params *DeleteApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemsOpenFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsOpenFiles(ctx context.Context, params *GetApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsOpenFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsPerformance(ctx context.Context, params *GetApi217FileSystemsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemsPolicies(ctx context.Context, params *DeleteApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsPolicies(ctx context.Context, params *GetApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FileSystemsPolicies(ctx context.Context, params *PostApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FileSystemsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsPoliciesAll(ctx context.Context, params *GetApi217FileSystemsPoliciesAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsPoliciesAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FileSystemsSessions(ctx context.Context, params *DeleteApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FileSystemsSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsSessions(ctx context.Context, params *GetApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsSessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsUsersPerformance(ctx context.Context, params *GetApi217FileSystemsUsersPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsUsersPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FileSystemsWormDataPolicies(ctx context.Context, params *GetApi217FileSystemsWormDataPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FileSystemsWormDataPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Fleets(ctx context.Context, params *DeleteApi217FleetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FleetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Fleets(ctx context.Context, params *GetApi217FleetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FleetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217FleetsWithBody(ctx context.Context, params *PatchApi217FleetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FleetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Fleets(ctx context.Context, params *PatchApi217FleetsParams, body PatchApi217FleetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217FleetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Fleets(ctx context.Context, params *PostApi217FleetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FleetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FleetsFleetKey(ctx context.Context, params *GetApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FleetsFleetKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FleetsFleetKey(ctx context.Context, params *PostApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FleetsFleetKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217FleetsMembers(ctx context.Context, params *DeleteApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217FleetsMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217FleetsMembers(ctx context.Context, params *GetApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217FleetsMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FleetsMembersWithBody(ctx context.Context, params *PostApi217FleetsMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FleetsMembersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217FleetsMembers(ctx context.Context, params *PostApi217FleetsMembersParams, body PostApi217FleetsMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217FleetsMembersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Hardware(ctx context.Context, params *GetApi217HardwareParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217HardwareRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217HardwareWithBody(ctx context.Context, params *PatchApi217HardwareParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217HardwareRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Hardware(ctx context.Context, params *PatchApi217HardwareParams, body PatchApi217HardwareJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217HardwareRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217HardwareConnectors(ctx context.Context, params *GetApi217HardwareConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217HardwareConnectorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217HardwareConnectorsWithBody(ctx context.Context, params *PatchApi217HardwareConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217HardwareConnectorsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217HardwareConnectors(ctx context.Context, params *PatchApi217HardwareConnectorsParams, body PatchApi217HardwareConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217HardwareConnectorsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217HardwareConnectorsPerformance(ctx context.Context, params *GetApi217HardwareConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217HardwareConnectorsPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Keytabs(ctx context.Context, params *DeleteApi217KeytabsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217KeytabsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Keytabs(ctx context.Context, params *GetApi217KeytabsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217KeytabsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217KeytabsWithBody(ctx context.Context, params *PostApi217KeytabsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217KeytabsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Keytabs(ctx context.Context, params *PostApi217KeytabsParams, body PostApi217KeytabsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217KeytabsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217KeytabsDownload(ctx context.Context, params *GetApi217KeytabsDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217KeytabsDownloadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217KeytabsUploadWithBody(ctx context.Context, params *PostApi217KeytabsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217KeytabsUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Kmip(ctx context.Context, params *DeleteApi217KmipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217KmipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Kmip(ctx context.Context, params *GetApi217KmipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217KmipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217KmipWithBody(ctx context.Context, params *PatchApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217KmipRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Kmip(ctx context.Context, params *PatchApi217KmipParams, body PatchApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217KmipRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217KmipWithBody(ctx context.Context, params *PostApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217KmipRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Kmip(ctx context.Context, params *PostApi217KmipParams, body PostApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217KmipRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217KmipTest(ctx context.Context, params *GetApi217KmipTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217KmipTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217LegalHolds(ctx context.Context, params *DeleteApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217LegalHoldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217LegalHolds(ctx context.Context, params *GetApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217LegalHoldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LegalHoldsWithBody(ctx context.Context, params *PatchApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LegalHoldsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LegalHolds(ctx context.Context, params *PatchApi217LegalHoldsParams, body PatchApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LegalHoldsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217LegalHoldsWithBody(ctx context.Context, params *PostApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217LegalHoldsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217LegalHolds(ctx context.Context, params *PostApi217LegalHoldsParams, body PostApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217LegalHoldsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217LegalHoldsHeldEntities(ctx context.Context, params *GetApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217LegalHoldsHeldEntitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LegalHoldsHeldEntities(ctx context.Context, params *PatchApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LegalHoldsHeldEntitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217LegalHoldsHeldEntities(ctx context.Context, params *PostApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217LegalHoldsHeldEntitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217LifecycleRules(ctx context.Context, params *DeleteApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217LifecycleRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217LifecycleRules(ctx context.Context, params *GetApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217LifecycleRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LifecycleRulesWithBody(ctx context.Context, params *PatchApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LifecycleRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LifecycleRules(ctx context.Context, params *PatchApi217LifecycleRulesParams, body PatchApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LifecycleRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217LifecycleRulesWithBody(ctx context.Context, params *PostApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217LifecycleRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217LifecycleRules(ctx context.Context, params *PostApi217LifecycleRulesParams, body PostApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217LifecycleRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217LinkAggregationGroups(ctx context.Context, params *DeleteApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217LinkAggregationGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217LinkAggregationGroups(ctx context.Context, params *GetApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217LinkAggregationGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LinkAggregationGroupsWithBody(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LinkAggregationGroupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LinkAggregationGroups(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, body PatchApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LinkAggregationGroupsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217LinkAggregationGroupsWithBody(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217LinkAggregationGroupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217LinkAggregationGroups(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, body PostApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217LinkAggregationGroupsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Logs(ctx context.Context, params *GetApi217LogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217LogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217LogsAsync(ctx context.Context, params *GetApi217LogsAsyncParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217LogsAsyncRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LogsAsyncWithBody(ctx context.Context, params *PatchApi217LogsAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LogsAsyncRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217LogsAsync(ctx context.Context, params *PatchApi217LogsAsyncParams, body PatchApi217LogsAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217LogsAsyncRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217LogsAsyncDownload(ctx context.Context, params *GetApi217LogsAsyncDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217LogsAsyncDownloadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217MaintenanceWindows(ctx context.Context, params *DeleteApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217MaintenanceWindowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217MaintenanceWindows(ctx context.Context, params *GetApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217MaintenanceWindowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217MaintenanceWindowsWithBody(ctx context.Context, params *PostApi217MaintenanceWindowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217MaintenanceWindowsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217MaintenanceWindows(ctx context.Context, params *PostApi217MaintenanceWindowsParams, body PostApi217MaintenanceWindowsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217MaintenanceWindowsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkAccessPolicies(ctx context.Context, params *GetApi217NetworkAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkAccessPoliciesWithBody(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkAccessPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkAccessPolicies(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, body PatchApi217NetworkAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkAccessPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkAccessPoliciesMembers(ctx context.Context, params *GetApi217NetworkAccessPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkAccessPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217NetworkAccessPoliciesRules(ctx context.Context, params *DeleteApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217NetworkAccessPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkAccessPoliciesRules(ctx context.Context, params *GetApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkAccessPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkAccessPoliciesRulesWithBody(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkAccessPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkAccessPoliciesRules(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, body PatchApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkAccessPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NetworkAccessPoliciesRulesWithBody(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NetworkAccessPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NetworkAccessPoliciesRules(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, body PostApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NetworkAccessPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217NetworkInterfaces(ctx context.Context, params *DeleteApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217NetworkInterfacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkInterfaces(ctx context.Context, params *GetApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkInterfacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkInterfacesWithBody(ctx context.Context, params *PatchApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkInterfacesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkInterfaces(ctx context.Context, params *PatchApi217NetworkInterfacesParams, body PatchApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkInterfacesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NetworkInterfacesWithBody(ctx context.Context, params *PostApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NetworkInterfacesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NetworkInterfaces(ctx context.Context, params *PostApi217NetworkInterfacesParams, body PostApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NetworkInterfacesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkInterfacesConnectors(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkInterfacesConnectorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkInterfacesConnectorsWithBody(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkInterfacesConnectorsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NetworkInterfacesConnectors(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, body PatchApi217NetworkInterfacesConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NetworkInterfacesConnectorsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkInterfacesConnectorsPerformance(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkInterfacesConnectorsPerformanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkInterfacesConnectorsSettings(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkInterfacesConnectorsSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkInterfacesPing(ctx context.Context, params *GetApi217NetworkInterfacesPingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkInterfacesPingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217NetworkInterfacesTlsPolicies(ctx context.Context, params *DeleteApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217NetworkInterfacesTlsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkInterfacesTlsPolicies(ctx context.Context, params *GetApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkInterfacesTlsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NetworkInterfacesTlsPolicies(ctx context.Context, params *PostApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NetworkInterfacesTlsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NetworkInterfacesTrace(ctx context.Context, params *GetApi217NetworkInterfacesTraceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NetworkInterfacesTraceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217NfsExportPolicies(ctx context.Context, params *DeleteApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217NfsExportPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NfsExportPolicies(ctx context.Context, params *GetApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NfsExportPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NfsExportPoliciesWithBody(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NfsExportPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NfsExportPolicies(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, body PatchApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NfsExportPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NfsExportPoliciesWithBody(ctx context.Context, params *PostApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NfsExportPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NfsExportPolicies(ctx context.Context, params *PostApi217NfsExportPoliciesParams, body PostApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NfsExportPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217NfsExportPoliciesRules(ctx context.Context, params *DeleteApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217NfsExportPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217NfsExportPoliciesRules(ctx context.Context, params *GetApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217NfsExportPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NfsExportPoliciesRulesWithBody(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NfsExportPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217NfsExportPoliciesRules(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, body PatchApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217NfsExportPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NfsExportPoliciesRulesWithBody(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NfsExportPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217NfsExportPoliciesRules(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, body PostApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217NfsExportPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreAccessKeys(ctx context.Context, params *DeleteApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreAccessKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreAccessKeys(ctx context.Context, params *GetApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreAccessKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccessKeysWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccessKeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccessKeys(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, body PatchApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccessKeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessKeysWithBody(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessKeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessKeys(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, body PostApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessKeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreAccessPolicies(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreAccessPolicies(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccessPoliciesWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccessPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccessPolicies(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, body PatchApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccessPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessPoliciesWithBody(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessPolicies(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, body PostApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreAccessPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreAccessPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccessPoliciesRulesWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccessPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, body PatchApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccessPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessPoliciesRulesWithBody(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccessPoliciesRules(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, body PostApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccessPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreAccessPolicyActions(ctx context.Context, params *GetApi217ObjectStoreAccessPolicyActionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreAccessPolicyActionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreAccounts(ctx context.Context, params *DeleteApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreAccounts(ctx context.Context, params *GetApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccountsWithBody(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreAccounts(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, body PatchApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccountsWithBody(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreAccounts(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, body PostApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreRemoteCredentials(ctx context.Context, params *DeleteApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreRemoteCredentialsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreRemoteCredentials(ctx context.Context, params *GetApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreRemoteCredentialsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRemoteCredentialsWithBody(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRemoteCredentialsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRemoteCredentials(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, body PatchApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRemoteCredentialsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreRemoteCredentialsWithBody(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreRemoteCredentialsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreRemoteCredentials(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, body PostApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreRemoteCredentialsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreRoles(ctx context.Context, params *DeleteApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreRoles(ctx context.Context, params *GetApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRolesWithBody(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRolesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRoles(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, body PatchApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRolesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreRolesWithBody(ctx context.Context, params *PostApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreRolesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreRoles(ctx context.Context, params *PostApi217ObjectStoreRolesParams, body PostApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreRolesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreRolesObjectStoreTrustPolicies(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownload(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBody(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUpload(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreUsers(ctx context.Context, params *DeleteApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreUsers(ctx context.Context, params *GetApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreUsers(ctx context.Context, params *PostApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx context.Context, params *DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx context.Context, params *GetApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx context.Context, params *PostApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217ObjectStoreVirtualHosts(ctx context.Context, params *DeleteApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ObjectStoreVirtualHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217ObjectStoreVirtualHosts(ctx context.Context, params *GetApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ObjectStoreVirtualHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ObjectStoreVirtualHosts(ctx context.Context, params *PostApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ObjectStoreVirtualHostsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PasswordPolicies(ctx context.Context, params *GetApi217PasswordPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PasswordPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217PasswordPoliciesWithBody(ctx context.Context, params *PatchApi217PasswordPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217PasswordPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217PasswordPolicies(ctx context.Context, params *PatchApi217PasswordPoliciesParams, body PatchApi217PasswordPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217PasswordPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Policies(ctx context.Context, params *DeleteApi217PoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217PoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Policies(ctx context.Context, params *GetApi217PoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217PoliciesWithBody(ctx context.Context, params *PatchApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217PoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Policies(ctx context.Context, params *PatchApi217PoliciesParams, body PatchApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217PoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217PoliciesWithBody(ctx context.Context, params *PostApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217PoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Policies(ctx context.Context, params *PostApi217PoliciesParams, body PostApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217PoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PoliciesAll(ctx context.Context, params *GetApi217PoliciesAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PoliciesAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PoliciesAllMembers(ctx context.Context, params *GetApi217PoliciesAllMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PoliciesAllMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217PoliciesFileSystemReplicaLinks(ctx context.Context, params *DeleteApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217PoliciesFileSystemReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PoliciesFileSystemReplicaLinks(ctx context.Context, params *GetApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PoliciesFileSystemReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217PoliciesFileSystemReplicaLinks(ctx context.Context, params *PostApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217PoliciesFileSystemReplicaLinksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217PoliciesFileSystemSnapshots(ctx context.Context, params *DeleteApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217PoliciesFileSystemSnapshotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PoliciesFileSystemSnapshots(ctx context.Context, params *GetApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PoliciesFileSystemSnapshotsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217PoliciesFileSystems(ctx context.Context, params *DeleteApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217PoliciesFileSystemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PoliciesFileSystems(ctx context.Context, params *GetApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PoliciesFileSystemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217PoliciesFileSystems(ctx context.Context, params *PostApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217PoliciesFileSystemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PoliciesMembers(ctx context.Context, params *GetApi217PoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217PublicKeys(ctx context.Context, params *DeleteApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217PublicKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PublicKeys(ctx context.Context, params *GetApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PublicKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217PublicKeysWithBody(ctx context.Context, params *PostApi217PublicKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217PublicKeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217PublicKeys(ctx context.Context, params *PostApi217PublicKeysParams, body PostApi217PublicKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217PublicKeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217PublicKeysUses(ctx context.Context, params *GetApi217PublicKeysUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217PublicKeysUsesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217QosPolicies(ctx context.Context, params *DeleteApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217QosPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217QosPolicies(ctx context.Context, params *GetApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217QosPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QosPoliciesWithBody(ctx context.Context, params *PatchApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QosPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QosPolicies(ctx context.Context, params *PatchApi217QosPoliciesParams, body PatchApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QosPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217QosPoliciesWithBody(ctx context.Context, params *PostApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217QosPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217QosPolicies(ctx context.Context, params *PostApi217QosPoliciesParams, body PostApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217QosPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217QosPoliciesFileSystems(ctx context.Context, params *GetApi217QosPoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217QosPoliciesFileSystemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217QosPoliciesMembers(ctx context.Context, params *GetApi217QosPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217QosPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217QuotasGroups(ctx context.Context, params *DeleteApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217QuotasGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217QuotasGroups(ctx context.Context, params *GetApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217QuotasGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QuotasGroupsWithBody(ctx context.Context, params *PatchApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QuotasGroupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QuotasGroups(ctx context.Context, params *PatchApi217QuotasGroupsParams, body PatchApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QuotasGroupsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217QuotasGroupsWithBody(ctx context.Context, params *PostApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217QuotasGroupsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217QuotasGroups(ctx context.Context, params *PostApi217QuotasGroupsParams, body PostApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217QuotasGroupsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217QuotasSettings(ctx context.Context, params *GetApi217QuotasSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217QuotasSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QuotasSettingsWithBody(ctx context.Context, params *PatchApi217QuotasSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QuotasSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QuotasSettings(ctx context.Context, params *PatchApi217QuotasSettingsParams, body PatchApi217QuotasSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QuotasSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217QuotasUsers(ctx context.Context, params *DeleteApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217QuotasUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217QuotasUsers(ctx context.Context, params *GetApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217QuotasUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QuotasUsersWithBody(ctx context.Context, params *PatchApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QuotasUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217QuotasUsers(ctx context.Context, params *PatchApi217QuotasUsersParams, body PatchApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217QuotasUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217QuotasUsersWithBody(ctx context.Context, params *PostApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217QuotasUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217QuotasUsers(ctx context.Context, params *PostApi217QuotasUsersParams, body PostApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217QuotasUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217RapidDataLocking(ctx context.Context, params *GetApi217RapidDataLockingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217RapidDataLockingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217RapidDataLockingWithBody(ctx context.Context, params *PatchApi217RapidDataLockingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217RapidDataLockingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217RapidDataLocking(ctx context.Context, params *PatchApi217RapidDataLockingParams, body PatchApi217RapidDataLockingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217RapidDataLockingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217RapidDataLockingRotate(ctx context.Context, params *PostApi217RapidDataLockingRotateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217RapidDataLockingRotateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217RapidDataLockingTest(ctx context.Context, params *GetApi217RapidDataLockingTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217RapidDataLockingTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217RemoteArrays(ctx context.Context, params *GetApi217RemoteArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217RemoteArraysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Roles(ctx context.Context, params *GetApi217RolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217RolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Servers(ctx context.Context, params *DeleteApi217ServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217ServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Servers(ctx context.Context, params *GetApi217ServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217ServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217ServersWithBody(ctx context.Context, params *PatchApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ServersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Servers(ctx context.Context, params *PatchApi217ServersParams, body PatchApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217ServersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217ServersWithBody(ctx context.Context, params *PostApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ServersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Servers(ctx context.Context, params *PostApi217ServersParams, body PostApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217ServersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Sessions(ctx context.Context, params *GetApi217SessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SessionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SmbClientPolicies(ctx context.Context, params *DeleteApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SmbClientPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SmbClientPolicies(ctx context.Context, params *GetApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SmbClientPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbClientPoliciesWithBody(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbClientPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbClientPolicies(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, body PatchApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbClientPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbClientPoliciesWithBody(ctx context.Context, params *PostApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbClientPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbClientPolicies(ctx context.Context, params *PostApi217SmbClientPoliciesParams, body PostApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbClientPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SmbClientPoliciesRules(ctx context.Context, params *DeleteApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SmbClientPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SmbClientPoliciesRules(ctx context.Context, params *GetApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SmbClientPoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbClientPoliciesRulesWithBody(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbClientPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbClientPoliciesRules(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, body PatchApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbClientPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbClientPoliciesRulesWithBody(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbClientPoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbClientPoliciesRules(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, body PostApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbClientPoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SmbSharePolicies(ctx context.Context, params *DeleteApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SmbSharePoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SmbSharePolicies(ctx context.Context, params *GetApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SmbSharePoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbSharePoliciesWithBody(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbSharePoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbSharePolicies(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, body PatchApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbSharePoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbSharePoliciesWithBody(ctx context.Context, params *PostApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbSharePoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbSharePolicies(ctx context.Context, params *PostApi217SmbSharePoliciesParams, body PostApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbSharePoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SmbSharePoliciesRules(ctx context.Context, params *DeleteApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SmbSharePoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SmbSharePoliciesRules(ctx context.Context, params *GetApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SmbSharePoliciesRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbSharePoliciesRulesWithBody(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbSharePoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmbSharePoliciesRules(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, body PatchApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmbSharePoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbSharePoliciesRulesWithBody(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbSharePoliciesRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SmbSharePoliciesRules(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, body PostApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SmbSharePoliciesRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SmtpServers(ctx context.Context, params *GetApi217SmtpServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SmtpServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmtpServersWithBody(ctx context.Context, params *PatchApi217SmtpServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmtpServersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SmtpServers(ctx context.Context, params *PatchApi217SmtpServersParams, body PatchApi217SmtpServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SmtpServersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SnmpAgents(ctx context.Context, params *GetApi217SnmpAgentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SnmpAgentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SnmpAgentsWithBody(ctx context.Context, params *PatchApi217SnmpAgentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SnmpAgentsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SnmpAgents(ctx context.Context, params *PatchApi217SnmpAgentsParams, body PatchApi217SnmpAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SnmpAgentsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SnmpAgentsMib(ctx context.Context, params *GetApi217SnmpAgentsMibParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SnmpAgentsMibRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SnmpManagers(ctx context.Context, params *DeleteApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SnmpManagersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SnmpManagers(ctx context.Context, params *GetApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SnmpManagersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SnmpManagersWithBody(ctx context.Context, params *PatchApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SnmpManagersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SnmpManagers(ctx context.Context, params *PatchApi217SnmpManagersParams, body PatchApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SnmpManagersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SnmpManagersWithBody(ctx context.Context, params *PostApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SnmpManagersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SnmpManagers(ctx context.Context, params *PostApi217SnmpManagersParams, body PostApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SnmpManagersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SnmpManagersTest(ctx context.Context, params *GetApi217SnmpManagersTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SnmpManagersTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SoftwareCheck(ctx context.Context, params *GetApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SoftwareCheckRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SoftwareCheck(ctx context.Context, params *PostApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SoftwareCheckRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SshCertificateAuthorityPolicies(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SshCertificateAuthorityPolicies(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SshCertificateAuthorityPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SshCertificateAuthorityPoliciesWithBody(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SshCertificateAuthorityPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SshCertificateAuthorityPolicies(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, body PatchApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SshCertificateAuthorityPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SshCertificateAuthorityPoliciesWithBody(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SshCertificateAuthorityPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SshCertificateAuthorityPolicies(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, body PostApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SshCertificateAuthorityPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SshCertificateAuthorityPoliciesAdmins(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SshCertificateAuthorityPoliciesAdminsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SshCertificateAuthorityPoliciesAdmins(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SshCertificateAuthorityPoliciesAdminsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SshCertificateAuthorityPoliciesAdmins(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SshCertificateAuthorityPoliciesAdminsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SshCertificateAuthorityPoliciesArrays(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SshCertificateAuthorityPoliciesArraysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SshCertificateAuthorityPoliciesArrays(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SshCertificateAuthorityPoliciesArraysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SshCertificateAuthorityPoliciesArrays(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SshCertificateAuthorityPoliciesArraysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SshCertificateAuthorityPoliciesMembers(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SshCertificateAuthorityPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SsoOidcIdps(ctx context.Context, params *DeleteApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SsoOidcIdpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SsoOidcIdps(ctx context.Context, params *GetApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SsoOidcIdpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SsoOidcIdpsWithBody(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SsoOidcIdpsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SsoOidcIdps(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, body PatchApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SsoOidcIdpsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SsoOidcIdpsWithBody(ctx context.Context, params *PostApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SsoOidcIdpsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SsoOidcIdps(ctx context.Context, params *PostApi217SsoOidcIdpsParams, body PostApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SsoOidcIdpsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SsoSaml2Idps(ctx context.Context, params *DeleteApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SsoSaml2IdpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SsoSaml2Idps(ctx context.Context, params *GetApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SsoSaml2IdpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SsoSaml2IdpsWithBody(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SsoSaml2IdpsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SsoSaml2Idps(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, body PatchApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SsoSaml2IdpsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SsoSaml2IdpsWithBody(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SsoSaml2IdpsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SsoSaml2Idps(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, body PostApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SsoSaml2IdpsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SsoSaml2IdpsTest(ctx context.Context, params *GetApi217SsoSaml2IdpsTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SsoSaml2IdpsTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SsoSaml2IdpsTestWithBody(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SsoSaml2IdpsTestRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SsoSaml2IdpsTest(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, body PatchApi217SsoSaml2IdpsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SsoSaml2IdpsTestRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Subnets(ctx context.Context, params *DeleteApi217SubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SubnetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Subnets(ctx context.Context, params *GetApi217SubnetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SubnetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SubnetsWithBody(ctx context.Context, params *PatchApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SubnetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Subnets(ctx context.Context, params *PatchApi217SubnetsParams, body PatchApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SubnetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SubnetsWithBody(ctx context.Context, params *PostApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SubnetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Subnets(ctx context.Context, params *PostApi217SubnetsParams, body PostApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SubnetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Support(ctx context.Context, params *GetApi217SupportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SupportRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SupportWithBody(ctx context.Context, params *PatchApi217SupportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SupportRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Support(ctx context.Context, params *PatchApi217SupportParams, body PatchApi217SupportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SupportRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SupportDiagnostics(ctx context.Context, params *GetApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SupportDiagnosticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SupportDiagnostics(ctx context.Context, params *PostApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SupportDiagnosticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SupportDiagnosticsDetails(ctx context.Context, params *GetApi217SupportDiagnosticsDetailsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SupportDiagnosticsDetailsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SupportTest(ctx context.Context, params *GetApi217SupportTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SupportTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SupportVerificationKeys(ctx context.Context, params *GetApi217SupportVerificationKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SupportVerificationKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SupportVerificationKeysWithBody(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SupportVerificationKeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SupportVerificationKeys(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, body PatchApi217SupportVerificationKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SupportVerificationKeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217SyslogServers(ctx context.Context, params *DeleteApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217SyslogServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SyslogServers(ctx context.Context, params *GetApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SyslogServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SyslogServersWithBody(ctx context.Context, params *PatchApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SyslogServersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SyslogServers(ctx context.Context, params *PatchApi217SyslogServersParams, body PatchApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SyslogServersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SyslogServersWithBody(ctx context.Context, params *PostApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SyslogServersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217SyslogServers(ctx context.Context, params *PostApi217SyslogServersParams, body PostApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217SyslogServersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SyslogServersSettings(ctx context.Context, params *GetApi217SyslogServersSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SyslogServersSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SyslogServersSettingsWithBody(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SyslogServersSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217SyslogServersSettings(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, body PatchApi217SyslogServersSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217SyslogServersSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217SyslogServersTest(ctx context.Context, params *GetApi217SyslogServersTestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217SyslogServersTestRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217Targets(ctx context.Context, params *DeleteApi217TargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217TargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217Targets(ctx context.Context, params *GetApi217TargetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217TargetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217TargetsWithBody(ctx context.Context, params *PatchApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217TargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217Targets(ctx context.Context, params *PatchApi217TargetsParams, body PatchApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217TargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217TargetsWithBody(ctx context.Context, params *PostApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217TargetsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217Targets(ctx context.Context, params *PostApi217TargetsParams, body PostApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217TargetsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217TargetsPerformanceReplication(ctx context.Context, params *GetApi217TargetsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217TargetsPerformanceReplicationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217TlsPolicies(ctx context.Context, params *DeleteApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217TlsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217TlsPolicies(ctx context.Context, params *GetApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217TlsPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217TlsPoliciesWithBody(ctx context.Context, params *PatchApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217TlsPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217TlsPolicies(ctx context.Context, params *PatchApi217TlsPoliciesParams, body PatchApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217TlsPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217TlsPoliciesWithBody(ctx context.Context, params *PostApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217TlsPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217TlsPolicies(ctx context.Context, params *PostApi217TlsPoliciesParams, body PostApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217TlsPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217TlsPoliciesMembers(ctx context.Context, params *GetApi217TlsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217TlsPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217TlsPoliciesNetworkInterfaces(ctx context.Context, params *DeleteApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217TlsPoliciesNetworkInterfacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217TlsPoliciesNetworkInterfaces(ctx context.Context, params *GetApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217TlsPoliciesNetworkInterfacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217TlsPoliciesNetworkInterfaces(ctx context.Context, params *PostApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217TlsPoliciesNetworkInterfacesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217UsageGroups(ctx context.Context, params *GetApi217UsageGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217UsageGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217UsageUsers(ctx context.Context, params *GetApi217UsageUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217UsageUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApi217WormDataPolicies(ctx context.Context, params *DeleteApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApi217WormDataPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217WormDataPolicies(ctx context.Context, params *GetApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217WormDataPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217WormDataPoliciesWithBody(ctx context.Context, params *PatchApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217WormDataPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApi217WormDataPolicies(ctx context.Context, params *PatchApi217WormDataPoliciesParams, body PatchApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApi217WormDataPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217WormDataPoliciesWithBody(ctx context.Context, params *PostApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217WormDataPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApi217WormDataPolicies(ctx context.Context, params *PostApi217WormDataPoliciesParams, body PostApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApi217WormDataPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApi217WormDataPoliciesMembers(ctx context.Context, params *GetApi217WormDataPoliciesMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApi217WormDataPoliciesMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiApiVersion(ctx context.Context, params *GetApiApiVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiApiVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiLogin(ctx context.Context, params *PostApiLoginParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiLoginRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiLoginBanner(ctx context.Context, params *GetApiLoginBannerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiLoginBannerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostApiLogout(ctx context.Context, params *PostApiLogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostApiLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth210TokenWithBody(ctx context.Context, params *PostOauth210TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth210TokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth210TokenWithFormdataBody(ctx context.Context, params *PostOauth210TokenParams, body PostOauth210TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth210TokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteApi217ActiveDirectoryRequest generates requests for DeleteApi217ActiveDirectory
func NewDeleteApi217ActiveDirectoryRequest(server string, params *DeleteApi217ActiveDirectoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/active-directory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "local_only", runtime.ParamLocationQuery, *params.LocalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ActiveDirectoryRequest generates requests for GetApi217ActiveDirectory
func NewGetApi217ActiveDirectoryRequest(server string, params *GetApi217ActiveDirectoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/active-directory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ActiveDirectoryRequest calls the generic PatchApi217ActiveDirectory builder with application/json body
func NewPatchApi217ActiveDirectoryRequest(server string, params *PatchApi217ActiveDirectoryParams, body PatchApi217ActiveDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ActiveDirectoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ActiveDirectoryRequestWithBody generates requests for PatchApi217ActiveDirectory with any type of body
func NewPatchApi217ActiveDirectoryRequestWithBody(server string, params *PatchApi217ActiveDirectoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/active-directory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ActiveDirectoryRequest calls the generic PostApi217ActiveDirectory builder with application/json body
func NewPostApi217ActiveDirectoryRequest(server string, params *PostApi217ActiveDirectoryParams, body PostApi217ActiveDirectoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ActiveDirectoryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ActiveDirectoryRequestWithBody generates requests for PostApi217ActiveDirectory with any type of body
func NewPostApi217ActiveDirectoryRequestWithBody(server string, params *PostApi217ActiveDirectoryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/active-directory")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.JoinExistingAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "join_existing_account", runtime.ParamLocationQuery, *params.JoinExistingAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ActiveDirectoryTestRequest generates requests for GetApi217ActiveDirectoryTest
func NewGetApi217ActiveDirectoryTestRequest(server string, params *GetApi217ActiveDirectoryTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/active-directory/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217AdminsRequest generates requests for DeleteApi217Admins
func NewDeleteApi217AdminsRequest(server string, params *DeleteApi217AdminsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AdminsRequest generates requests for GetApi217Admins
func NewGetApi217AdminsRequest(server string, params *GetApi217AdminsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExposeApiToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expose_api_token", runtime.ParamLocationQuery, *params.ExposeApiToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217AdminsRequest calls the generic PatchApi217Admins builder with application/json body
func NewPatchApi217AdminsRequest(server string, params *PatchApi217AdminsParams, body PatchApi217AdminsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217AdminsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217AdminsRequestWithBody generates requests for PatchApi217Admins with any type of body
func NewPatchApi217AdminsRequestWithBody(server string, params *PatchApi217AdminsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217AdminsRequest calls the generic PostApi217Admins builder with application/json body
func NewPostApi217AdminsRequest(server string, params *PostApi217AdminsParams, body PostApi217AdminsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217AdminsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217AdminsRequestWithBody generates requests for PostApi217Admins with any type of body
func NewPostApi217AdminsRequestWithBody(server string, params *PostApi217AdminsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217AdminsApiTokensRequest generates requests for DeleteApi217AdminsApiTokens
func NewDeleteApi217AdminsApiTokensRequest(server string, params *DeleteApi217AdminsApiTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/api-tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_ids", runtime.ParamLocationQuery, *params.AdminIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdminNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_names", runtime.ParamLocationQuery, *params.AdminNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AdminsApiTokensRequest generates requests for GetApi217AdminsApiTokens
func NewGetApi217AdminsApiTokensRequest(server string, params *GetApi217AdminsApiTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/api-tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_ids", runtime.ParamLocationQuery, *params.AdminIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdminNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_names", runtime.ParamLocationQuery, *params.AdminNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExposeApiToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expose_api_token", runtime.ParamLocationQuery, *params.ExposeApiToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217AdminsApiTokensRequest generates requests for PostApi217AdminsApiTokens
func NewPostApi217AdminsApiTokensRequest(server string, params *PostApi217AdminsApiTokensParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/api-tokens")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_ids", runtime.ParamLocationQuery, *params.AdminIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdminNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_names", runtime.ParamLocationQuery, *params.AdminNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timeout != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeout", runtime.ParamLocationQuery, *params.Timeout); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217AdminsCacheRequest generates requests for DeleteApi217AdminsCache
func NewDeleteApi217AdminsCacheRequest(server string, params *DeleteApi217AdminsCacheParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/cache")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AdminsCacheRequest generates requests for GetApi217AdminsCache
func NewGetApi217AdminsCacheRequest(server string, params *GetApi217AdminsCacheParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/cache")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AdminsSettingsRequest generates requests for GetApi217AdminsSettings
func NewGetApi217AdminsSettingsRequest(server string, params *GetApi217AdminsSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217AdminsSettingsRequest calls the generic PatchApi217AdminsSettings builder with application/json body
func NewPatchApi217AdminsSettingsRequest(server string, params *PatchApi217AdminsSettingsParams, body PatchApi217AdminsSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217AdminsSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217AdminsSettingsRequestWithBody generates requests for PatchApi217AdminsSettings with any type of body
func NewPatchApi217AdminsSettingsRequestWithBody(server string, params *PatchApi217AdminsSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217AdminsSshCertificateAuthorityPoliciesRequest generates requests for DeleteApi217AdminsSshCertificateAuthorityPolicies
func NewDeleteApi217AdminsSshCertificateAuthorityPoliciesRequest(server string, params *DeleteApi217AdminsSshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AdminsSshCertificateAuthorityPoliciesRequest generates requests for GetApi217AdminsSshCertificateAuthorityPolicies
func NewGetApi217AdminsSshCertificateAuthorityPoliciesRequest(server string, params *GetApi217AdminsSshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217AdminsSshCertificateAuthorityPoliciesRequest generates requests for PostApi217AdminsSshCertificateAuthorityPolicies
func NewPostApi217AdminsSshCertificateAuthorityPoliciesRequest(server string, params *PostApi217AdminsSshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/admins/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217AlertWatchersRequest generates requests for DeleteApi217AlertWatchers
func NewDeleteApi217AlertWatchersRequest(server string, params *DeleteApi217AlertWatchersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/alert-watchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AlertWatchersRequest generates requests for GetApi217AlertWatchers
func NewGetApi217AlertWatchersRequest(server string, params *GetApi217AlertWatchersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/alert-watchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217AlertWatchersRequest calls the generic PatchApi217AlertWatchers builder with application/json body
func NewPatchApi217AlertWatchersRequest(server string, params *PatchApi217AlertWatchersParams, body PatchApi217AlertWatchersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217AlertWatchersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217AlertWatchersRequestWithBody generates requests for PatchApi217AlertWatchers with any type of body
func NewPatchApi217AlertWatchersRequestWithBody(server string, params *PatchApi217AlertWatchersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/alert-watchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217AlertWatchersRequest calls the generic PostApi217AlertWatchers builder with application/json body
func NewPostApi217AlertWatchersRequest(server string, params *PostApi217AlertWatchersParams, body PostApi217AlertWatchersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217AlertWatchersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217AlertWatchersRequestWithBody generates requests for PostApi217AlertWatchers with any type of body
func NewPostApi217AlertWatchersRequestWithBody(server string, params *PostApi217AlertWatchersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/alert-watchers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AlertWatchersTestRequest generates requests for GetApi217AlertWatchersTest
func NewGetApi217AlertWatchersTestRequest(server string, params *GetApi217AlertWatchersTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/alert-watchers/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AlertsRequest generates requests for GetApi217Alerts
func NewGetApi217AlertsRequest(server string, params *GetApi217AlertsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217AlertsRequest calls the generic PatchApi217Alerts builder with application/json body
func NewPatchApi217AlertsRequest(server string, params *PatchApi217AlertsParams, body PatchApi217AlertsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217AlertsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217AlertsRequestWithBody generates requests for PatchApi217Alerts with any type of body
func NewPatchApi217AlertsRequestWithBody(server string, params *PatchApi217AlertsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ApiClientsRequest generates requests for DeleteApi217ApiClients
func NewDeleteApi217ApiClientsRequest(server string, params *DeleteApi217ApiClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/api-clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ApiClientsRequest generates requests for GetApi217ApiClients
func NewGetApi217ApiClientsRequest(server string, params *GetApi217ApiClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/api-clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ApiClientsRequest calls the generic PatchApi217ApiClients builder with application/json body
func NewPatchApi217ApiClientsRequest(server string, params *PatchApi217ApiClientsParams, body PatchApi217ApiClientsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ApiClientsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ApiClientsRequestWithBody generates requests for PatchApi217ApiClients with any type of body
func NewPatchApi217ApiClientsRequestWithBody(server string, params *PatchApi217ApiClientsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/api-clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ApiClientsRequest calls the generic PostApi217ApiClients builder with application/json body
func NewPostApi217ApiClientsRequest(server string, params *PostApi217ApiClientsParams, body PostApi217ApiClientsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ApiClientsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ApiClientsRequestWithBody generates requests for PostApi217ApiClients with any type of body
func NewPostApi217ApiClientsRequestWithBody(server string, params *PostApi217ApiClientsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/api-clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ArrayConnectionsRequest generates requests for DeleteApi217ArrayConnections
func NewDeleteApi217ArrayConnectionsRequest(server string, params *DeleteApi217ArrayConnectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArrayConnectionsRequest generates requests for GetApi217ArrayConnections
func NewGetApi217ArrayConnectionsRequest(server string, params *GetApi217ArrayConnectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ArrayConnectionsRequest calls the generic PatchApi217ArrayConnections builder with application/json body
func NewPatchApi217ArrayConnectionsRequest(server string, params *PatchApi217ArrayConnectionsParams, body PatchApi217ArrayConnectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ArrayConnectionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ArrayConnectionsRequestWithBody generates requests for PatchApi217ArrayConnections with any type of body
func NewPatchApi217ArrayConnectionsRequestWithBody(server string, params *PatchApi217ArrayConnectionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ArrayConnectionsRequest calls the generic PostApi217ArrayConnections builder with application/json body
func NewPostApi217ArrayConnectionsRequest(server string, params *PostApi217ArrayConnectionsParams, body PostApi217ArrayConnectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ArrayConnectionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ArrayConnectionsRequestWithBody generates requests for PostApi217ArrayConnections with any type of body
func NewPostApi217ArrayConnectionsRequestWithBody(server string, params *PostApi217ArrayConnectionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArrayConnectionsConnectionKeyRequest generates requests for GetApi217ArrayConnectionsConnectionKey
func NewGetApi217ArrayConnectionsConnectionKeyRequest(server string, params *GetApi217ArrayConnectionsConnectionKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections/connection-key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ArrayConnectionsConnectionKeyRequest generates requests for PostApi217ArrayConnectionsConnectionKey
func NewPostApi217ArrayConnectionsConnectionKeyRequest(server string, params *PostApi217ArrayConnectionsConnectionKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections/connection-key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArrayConnectionsPathRequest generates requests for GetApi217ArrayConnectionsPath
func NewGetApi217ArrayConnectionsPathRequest(server string, params *GetApi217ArrayConnectionsPathParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections/path")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArrayConnectionsPerformanceReplicationRequest generates requests for GetApi217ArrayConnectionsPerformanceReplication
func NewGetApi217ArrayConnectionsPerformanceReplicationRequest(server string, params *GetApi217ArrayConnectionsPerformanceReplicationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/array-connections/performance/replication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysRequest generates requests for GetApi217Arrays
func NewGetApi217ArraysRequest(server string, params *GetApi217ArraysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ArraysRequest calls the generic PatchApi217Arrays builder with application/json body
func NewPatchApi217ArraysRequest(server string, params *PatchApi217ArraysParams, body PatchApi217ArraysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ArraysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ArraysRequestWithBody generates requests for PatchApi217Arrays with any type of body
func NewPatchApi217ArraysRequestWithBody(server string, params *PatchApi217ArraysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysClientsPerformanceRequest generates requests for GetApi217ArraysClientsPerformance
func NewGetApi217ArraysClientsPerformanceRequest(server string, params *GetApi217ArraysClientsPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/clients/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysEulaRequest generates requests for GetApi217ArraysEula
func NewGetApi217ArraysEulaRequest(server string, params *GetApi217ArraysEulaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/eula")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ArraysEulaRequest calls the generic PatchApi217ArraysEula builder with application/json body
func NewPatchApi217ArraysEulaRequest(server string, params *PatchApi217ArraysEulaParams, body PatchApi217ArraysEulaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ArraysEulaRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ArraysEulaRequestWithBody generates requests for PatchApi217ArraysEula with any type of body
func NewPatchApi217ArraysEulaRequestWithBody(server string, params *PatchApi217ArraysEulaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/eula")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ArraysFactoryResetTokenRequest generates requests for DeleteApi217ArraysFactoryResetToken
func NewDeleteApi217ArraysFactoryResetTokenRequest(server string, params *DeleteApi217ArraysFactoryResetTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/factory-reset-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysFactoryResetTokenRequest generates requests for GetApi217ArraysFactoryResetToken
func NewGetApi217ArraysFactoryResetTokenRequest(server string, params *GetApi217ArraysFactoryResetTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/factory-reset-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ArraysFactoryResetTokenRequest generates requests for PostApi217ArraysFactoryResetToken
func NewPostApi217ArraysFactoryResetTokenRequest(server string, params *PostApi217ArraysFactoryResetTokenParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/factory-reset-token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysHttpSpecificPerformanceRequest generates requests for GetApi217ArraysHttpSpecificPerformance
func NewGetApi217ArraysHttpSpecificPerformanceRequest(server string, params *GetApi217ArraysHttpSpecificPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/http-specific-performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysNfsSpecificPerformanceRequest generates requests for GetApi217ArraysNfsSpecificPerformance
func NewGetApi217ArraysNfsSpecificPerformanceRequest(server string, params *GetApi217ArraysNfsSpecificPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/nfs-specific-performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysPerformanceRequest generates requests for GetApi217ArraysPerformance
func NewGetApi217ArraysPerformanceRequest(server string, params *GetApi217ArraysPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Protocol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "protocol", runtime.ParamLocationQuery, *params.Protocol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysPerformanceReplicationRequest generates requests for GetApi217ArraysPerformanceReplication
func NewGetApi217ArraysPerformanceReplicationRequest(server string, params *GetApi217ArraysPerformanceReplicationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/performance/replication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysS3SpecificPerformanceRequest generates requests for GetApi217ArraysS3SpecificPerformance
func NewGetApi217ArraysS3SpecificPerformanceRequest(server string, params *GetApi217ArraysS3SpecificPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/s3-specific-performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysSpaceRequest generates requests for GetApi217ArraysSpace
func NewGetApi217ArraysSpaceRequest(server string, params *GetApi217ArraysSpaceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/space")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysSpaceStorageClassesRequest generates requests for GetApi217ArraysSpaceStorageClasses
func NewGetApi217ArraysSpaceStorageClassesRequest(server string, params *GetApi217ArraysSpaceStorageClassesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/space/storage-classes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageClassNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "storage_class_names", runtime.ParamLocationQuery, *params.StorageClassNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ArraysSshCertificateAuthorityPoliciesRequest generates requests for DeleteApi217ArraysSshCertificateAuthorityPolicies
func NewDeleteApi217ArraysSshCertificateAuthorityPoliciesRequest(server string, params *DeleteApi217ArraysSshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysSshCertificateAuthorityPoliciesRequest generates requests for GetApi217ArraysSshCertificateAuthorityPolicies
func NewGetApi217ArraysSshCertificateAuthorityPoliciesRequest(server string, params *GetApi217ArraysSshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ArraysSshCertificateAuthorityPoliciesRequest generates requests for PostApi217ArraysSshCertificateAuthorityPolicies
func NewPostApi217ArraysSshCertificateAuthorityPoliciesRequest(server string, params *PostApi217ArraysSshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ArraysSupportedTimeZonesRequest generates requests for GetApi217ArraysSupportedTimeZones
func NewGetApi217ArraysSupportedTimeZonesRequest(server string, params *GetApi217ArraysSupportedTimeZonesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/arrays/supported-time-zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217AuditFileSystemsPoliciesRequest generates requests for DeleteApi217AuditFileSystemsPolicies
func NewDeleteApi217AuditFileSystemsPoliciesRequest(server string, params *DeleteApi217AuditFileSystemsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audit-file-systems-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AuditFileSystemsPoliciesRequest generates requests for GetApi217AuditFileSystemsPolicies
func NewGetApi217AuditFileSystemsPoliciesRequest(server string, params *GetApi217AuditFileSystemsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audit-file-systems-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217AuditFileSystemsPoliciesRequest calls the generic PatchApi217AuditFileSystemsPolicies builder with application/json body
func NewPatchApi217AuditFileSystemsPoliciesRequest(server string, params *PatchApi217AuditFileSystemsPoliciesParams, body PatchApi217AuditFileSystemsPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217AuditFileSystemsPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217AuditFileSystemsPoliciesRequestWithBody generates requests for PatchApi217AuditFileSystemsPolicies with any type of body
func NewPatchApi217AuditFileSystemsPoliciesRequestWithBody(server string, params *PatchApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audit-file-systems-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217AuditFileSystemsPoliciesRequest calls the generic PostApi217AuditFileSystemsPolicies builder with application/json body
func NewPostApi217AuditFileSystemsPoliciesRequest(server string, params *PostApi217AuditFileSystemsPoliciesParams, body PostApi217AuditFileSystemsPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217AuditFileSystemsPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217AuditFileSystemsPoliciesRequestWithBody generates requests for PostApi217AuditFileSystemsPolicies with any type of body
func NewPostApi217AuditFileSystemsPoliciesRequestWithBody(server string, params *PostApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audit-file-systems-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217AuditFileSystemsPoliciesMembersRequest generates requests for DeleteApi217AuditFileSystemsPoliciesMembers
func NewDeleteApi217AuditFileSystemsPoliciesMembersRequest(server string, params *DeleteApi217AuditFileSystemsPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audit-file-systems-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AuditFileSystemsPoliciesMembersRequest generates requests for GetApi217AuditFileSystemsPoliciesMembers
func NewGetApi217AuditFileSystemsPoliciesMembersRequest(server string, params *GetApi217AuditFileSystemsPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audit-file-systems-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217AuditFileSystemsPoliciesMembersRequest generates requests for PostApi217AuditFileSystemsPoliciesMembers
func NewPostApi217AuditFileSystemsPoliciesMembersRequest(server string, params *PostApi217AuditFileSystemsPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audit-file-systems-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217AuditsRequest generates requests for GetApi217Audits
func NewGetApi217AuditsRequest(server string, params *GetApi217AuditsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/audits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BladesRequest generates requests for GetApi217Blades
func NewGetApi217BladesRequest(server string, params *GetApi217BladesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/blades")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217BucketReplicaLinksRequest generates requests for DeleteApi217BucketReplicaLinks
func NewDeleteApi217BucketReplicaLinksRequest(server string, params *DeleteApi217BucketReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/bucket-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_ids", runtime.ParamLocationQuery, *params.LocalBucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_names", runtime.ParamLocationQuery, *params.LocalBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_bucket_names", runtime.ParamLocationQuery, *params.RemoteBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketReplicaLinksRequest generates requests for GetApi217BucketReplicaLinks
func NewGetApi217BucketReplicaLinksRequest(server string, params *GetApi217BucketReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/bucket-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_ids", runtime.ParamLocationQuery, *params.LocalBucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_names", runtime.ParamLocationQuery, *params.LocalBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_bucket_names", runtime.ParamLocationQuery, *params.RemoteBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217BucketReplicaLinksRequest calls the generic PatchApi217BucketReplicaLinks builder with application/json body
func NewPatchApi217BucketReplicaLinksRequest(server string, params *PatchApi217BucketReplicaLinksParams, body PatchApi217BucketReplicaLinksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217BucketReplicaLinksRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217BucketReplicaLinksRequestWithBody generates requests for PatchApi217BucketReplicaLinks with any type of body
func NewPatchApi217BucketReplicaLinksRequestWithBody(server string, params *PatchApi217BucketReplicaLinksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/bucket-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_ids", runtime.ParamLocationQuery, *params.LocalBucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_names", runtime.ParamLocationQuery, *params.LocalBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_bucket_names", runtime.ParamLocationQuery, *params.RemoteBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217BucketReplicaLinksRequest calls the generic PostApi217BucketReplicaLinks builder with application/json body
func NewPostApi217BucketReplicaLinksRequest(server string, params *PostApi217BucketReplicaLinksParams, body PostApi217BucketReplicaLinksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217BucketReplicaLinksRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217BucketReplicaLinksRequestWithBody generates requests for PostApi217BucketReplicaLinks with any type of body
func NewPostApi217BucketReplicaLinksRequestWithBody(server string, params *PostApi217BucketReplicaLinksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/bucket-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_ids", runtime.ParamLocationQuery, *params.LocalBucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_bucket_names", runtime.ParamLocationQuery, *params.LocalBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteBucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_bucket_names", runtime.ParamLocationQuery, *params.RemoteBucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteCredentialsIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_credentials_ids", runtime.ParamLocationQuery, *params.RemoteCredentialsIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteCredentialsNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_credentials_names", runtime.ParamLocationQuery, *params.RemoteCredentialsNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217BucketsRequest generates requests for DeleteApi217Buckets
func NewDeleteApi217BucketsRequest(server string, params *DeleteApi217BucketsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketsRequest generates requests for GetApi217Buckets
func NewGetApi217BucketsRequest(server string, params *GetApi217BucketsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Destroyed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destroyed", runtime.ParamLocationQuery, *params.Destroyed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217BucketsRequest calls the generic PatchApi217Buckets builder with application/json body
func NewPatchApi217BucketsRequest(server string, params *PatchApi217BucketsParams, body PatchApi217BucketsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217BucketsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217BucketsRequestWithBody generates requests for PatchApi217Buckets with any type of body
func NewPatchApi217BucketsRequestWithBody(server string, params *PatchApi217BucketsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignore_usage", runtime.ParamLocationQuery, *params.IgnoreUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217BucketsRequest calls the generic PostApi217Buckets builder with application/json body
func NewPostApi217BucketsRequest(server string, params *PostApi217BucketsParams, body PostApi217BucketsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217BucketsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217BucketsRequestWithBody generates requests for PostApi217Buckets with any type of body
func NewPostApi217BucketsRequestWithBody(server string, params *PostApi217BucketsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217BucketsBucketAccessPoliciesRequest generates requests for DeleteApi217BucketsBucketAccessPolicies
func NewDeleteApi217BucketsBucketAccessPoliciesRequest(server string, params *DeleteApi217BucketsBucketAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/bucket-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketsBucketAccessPoliciesRequest generates requests for GetApi217BucketsBucketAccessPolicies
func NewGetApi217BucketsBucketAccessPoliciesRequest(server string, params *GetApi217BucketsBucketAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/bucket-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217BucketsBucketAccessPoliciesRequest calls the generic PostApi217BucketsBucketAccessPolicies builder with application/json body
func NewPostApi217BucketsBucketAccessPoliciesRequest(server string, params *PostApi217BucketsBucketAccessPoliciesParams, body PostApi217BucketsBucketAccessPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217BucketsBucketAccessPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217BucketsBucketAccessPoliciesRequestWithBody generates requests for PostApi217BucketsBucketAccessPolicies with any type of body
func NewPostApi217BucketsBucketAccessPoliciesRequestWithBody(server string, params *PostApi217BucketsBucketAccessPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/bucket-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217BucketsBucketAccessPoliciesRulesRequest generates requests for DeleteApi217BucketsBucketAccessPoliciesRules
func NewDeleteApi217BucketsBucketAccessPoliciesRulesRequest(server string, params *DeleteApi217BucketsBucketAccessPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/bucket-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketsBucketAccessPoliciesRulesRequest generates requests for GetApi217BucketsBucketAccessPoliciesRules
func NewGetApi217BucketsBucketAccessPoliciesRulesRequest(server string, params *GetApi217BucketsBucketAccessPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/bucket-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217BucketsBucketAccessPoliciesRulesRequest calls the generic PostApi217BucketsBucketAccessPoliciesRules builder with application/json body
func NewPostApi217BucketsBucketAccessPoliciesRulesRequest(server string, params *PostApi217BucketsBucketAccessPoliciesRulesParams, body PostApi217BucketsBucketAccessPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217BucketsBucketAccessPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217BucketsBucketAccessPoliciesRulesRequestWithBody generates requests for PostApi217BucketsBucketAccessPoliciesRules with any type of body
func NewPostApi217BucketsBucketAccessPoliciesRulesRequestWithBody(server string, params *PostApi217BucketsBucketAccessPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/bucket-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217BucketsCrossOriginResourceSharingPoliciesRequest generates requests for DeleteApi217BucketsCrossOriginResourceSharingPolicies
func NewDeleteApi217BucketsCrossOriginResourceSharingPoliciesRequest(server string, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/cross-origin-resource-sharing-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketsCrossOriginResourceSharingPoliciesRequest generates requests for GetApi217BucketsCrossOriginResourceSharingPolicies
func NewGetApi217BucketsCrossOriginResourceSharingPoliciesRequest(server string, params *GetApi217BucketsCrossOriginResourceSharingPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/cross-origin-resource-sharing-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217BucketsCrossOriginResourceSharingPoliciesRequest calls the generic PostApi217BucketsCrossOriginResourceSharingPolicies builder with application/json body
func NewPostApi217BucketsCrossOriginResourceSharingPoliciesRequest(server string, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217BucketsCrossOriginResourceSharingPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217BucketsCrossOriginResourceSharingPoliciesRequestWithBody generates requests for PostApi217BucketsCrossOriginResourceSharingPolicies with any type of body
func NewPostApi217BucketsCrossOriginResourceSharingPoliciesRequestWithBody(server string, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/cross-origin-resource-sharing-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest generates requests for DeleteApi217BucketsCrossOriginResourceSharingPoliciesRules
func NewDeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest(server string, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/cross-origin-resource-sharing-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest generates requests for GetApi217BucketsCrossOriginResourceSharingPoliciesRules
func NewGetApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest(server string, params *GetApi217BucketsCrossOriginResourceSharingPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/cross-origin-resource-sharing-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest calls the generic PostApi217BucketsCrossOriginResourceSharingPoliciesRules builder with application/json body
func NewPostApi217BucketsCrossOriginResourceSharingPoliciesRulesRequest(server string, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217BucketsCrossOriginResourceSharingPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217BucketsCrossOriginResourceSharingPoliciesRulesRequestWithBody generates requests for PostApi217BucketsCrossOriginResourceSharingPoliciesRules with any type of body
func NewPostApi217BucketsCrossOriginResourceSharingPoliciesRulesRequestWithBody(server string, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/cross-origin-resource-sharing-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketsPerformanceRequest generates requests for GetApi217BucketsPerformance
func NewGetApi217BucketsPerformanceRequest(server string, params *GetApi217BucketsPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217BucketsS3SpecificPerformanceRequest generates requests for GetApi217BucketsS3SpecificPerformance
func NewGetApi217BucketsS3SpecificPerformanceRequest(server string, params *GetApi217BucketsS3SpecificPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/buckets/s3-specific-performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217CertificateGroupsRequest generates requests for DeleteApi217CertificateGroups
func NewDeleteApi217CertificateGroupsRequest(server string, params *DeleteApi217CertificateGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificate-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217CertificateGroupsRequest generates requests for GetApi217CertificateGroups
func NewGetApi217CertificateGroupsRequest(server string, params *GetApi217CertificateGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificate-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217CertificateGroupsRequest generates requests for PostApi217CertificateGroups
func NewPostApi217CertificateGroupsRequest(server string, params *PostApi217CertificateGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificate-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217CertificateGroupsCertificatesRequest generates requests for DeleteApi217CertificateGroupsCertificates
func NewDeleteApi217CertificateGroupsCertificatesRequest(server string, params *DeleteApi217CertificateGroupsCertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificate-groups/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CertificateGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_ids", runtime.ParamLocationQuery, *params.CertificateGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_names", runtime.ParamLocationQuery, *params.CertificateGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_ids", runtime.ParamLocationQuery, *params.CertificateIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_names", runtime.ParamLocationQuery, *params.CertificateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217CertificateGroupsCertificatesRequest generates requests for GetApi217CertificateGroupsCertificates
func NewGetApi217CertificateGroupsCertificatesRequest(server string, params *GetApi217CertificateGroupsCertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificate-groups/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CertificateGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_ids", runtime.ParamLocationQuery, *params.CertificateGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_names", runtime.ParamLocationQuery, *params.CertificateGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_ids", runtime.ParamLocationQuery, *params.CertificateIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_names", runtime.ParamLocationQuery, *params.CertificateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217CertificateGroupsCertificatesRequest generates requests for PostApi217CertificateGroupsCertificates
func NewPostApi217CertificateGroupsCertificatesRequest(server string, params *PostApi217CertificateGroupsCertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificate-groups/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CertificateGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_ids", runtime.ParamLocationQuery, *params.CertificateGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_names", runtime.ParamLocationQuery, *params.CertificateGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_ids", runtime.ParamLocationQuery, *params.CertificateIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_names", runtime.ParamLocationQuery, *params.CertificateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217CertificateGroupsUsesRequest generates requests for GetApi217CertificateGroupsUses
func NewGetApi217CertificateGroupsUsesRequest(server string, params *GetApi217CertificateGroupsUsesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificate-groups/uses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217CertificatesRequest generates requests for DeleteApi217Certificates
func NewDeleteApi217CertificatesRequest(server string, params *DeleteApi217CertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217CertificatesRequest generates requests for GetApi217Certificates
func NewGetApi217CertificatesRequest(server string, params *GetApi217CertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217CertificatesRequest calls the generic PatchApi217Certificates builder with application/json body
func NewPatchApi217CertificatesRequest(server string, params *PatchApi217CertificatesParams, body PatchApi217CertificatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217CertificatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217CertificatesRequestWithBody generates requests for PatchApi217Certificates with any type of body
func NewPatchApi217CertificatesRequestWithBody(server string, params *PatchApi217CertificatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217CertificatesRequest calls the generic PostApi217Certificates builder with application/json body
func NewPostApi217CertificatesRequest(server string, params *PostApi217CertificatesParams, body PostApi217CertificatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217CertificatesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217CertificatesRequestWithBody generates requests for PostApi217Certificates with any type of body
func NewPostApi217CertificatesRequestWithBody(server string, params *PostApi217CertificatesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217CertificatesCertificateGroupsRequest generates requests for DeleteApi217CertificatesCertificateGroups
func NewDeleteApi217CertificatesCertificateGroupsRequest(server string, params *DeleteApi217CertificatesCertificateGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates/certificate-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CertificateGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_ids", runtime.ParamLocationQuery, *params.CertificateGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_names", runtime.ParamLocationQuery, *params.CertificateGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_ids", runtime.ParamLocationQuery, *params.CertificateIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_names", runtime.ParamLocationQuery, *params.CertificateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217CertificatesCertificateGroupsRequest generates requests for GetApi217CertificatesCertificateGroups
func NewGetApi217CertificatesCertificateGroupsRequest(server string, params *GetApi217CertificatesCertificateGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates/certificate-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CertificateGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_ids", runtime.ParamLocationQuery, *params.CertificateGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_names", runtime.ParamLocationQuery, *params.CertificateGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_ids", runtime.ParamLocationQuery, *params.CertificateIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_names", runtime.ParamLocationQuery, *params.CertificateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217CertificatesCertificateGroupsRequest generates requests for PostApi217CertificatesCertificateGroups
func NewPostApi217CertificatesCertificateGroupsRequest(server string, params *PostApi217CertificatesCertificateGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates/certificate-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CertificateGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_ids", runtime.ParamLocationQuery, *params.CertificateGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateGroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_group_names", runtime.ParamLocationQuery, *params.CertificateGroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_ids", runtime.ParamLocationQuery, *params.CertificateIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CertificateNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certificate_names", runtime.ParamLocationQuery, *params.CertificateNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217CertificatesUsesRequest generates requests for GetApi217CertificatesUses
func NewGetApi217CertificatesUsesRequest(server string, params *GetApi217CertificatesUsesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/certificates/uses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217DirectoryServicesRequest generates requests for GetApi217DirectoryServices
func NewGetApi217DirectoryServicesRequest(server string, params *GetApi217DirectoryServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217DirectoryServicesRequest calls the generic PatchApi217DirectoryServices builder with application/json body
func NewPatchApi217DirectoryServicesRequest(server string, params *PatchApi217DirectoryServicesParams, body PatchApi217DirectoryServicesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217DirectoryServicesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217DirectoryServicesRequestWithBody generates requests for PatchApi217DirectoryServices with any type of body
func NewPatchApi217DirectoryServicesRequestWithBody(server string, params *PatchApi217DirectoryServicesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217DirectoryServicesRolesRequest generates requests for DeleteApi217DirectoryServicesRoles
func NewDeleteApi217DirectoryServicesRolesRequest(server string, params *DeleteApi217DirectoryServicesRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217DirectoryServicesRolesRequest generates requests for GetApi217DirectoryServicesRoles
func NewGetApi217DirectoryServicesRolesRequest(server string, params *GetApi217DirectoryServicesRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217DirectoryServicesRolesRequest calls the generic PatchApi217DirectoryServicesRoles builder with application/json body
func NewPatchApi217DirectoryServicesRolesRequest(server string, params *PatchApi217DirectoryServicesRolesParams, body PatchApi217DirectoryServicesRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217DirectoryServicesRolesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217DirectoryServicesRolesRequestWithBody generates requests for PatchApi217DirectoryServicesRoles with any type of body
func NewPatchApi217DirectoryServicesRolesRequestWithBody(server string, params *PatchApi217DirectoryServicesRolesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217DirectoryServicesRolesRequest calls the generic PostApi217DirectoryServicesRoles builder with application/json body
func NewPostApi217DirectoryServicesRolesRequest(server string, params *PostApi217DirectoryServicesRolesParams, body PostApi217DirectoryServicesRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217DirectoryServicesRolesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217DirectoryServicesRolesRequestWithBody generates requests for PostApi217DirectoryServicesRoles with any type of body
func NewPostApi217DirectoryServicesRolesRequestWithBody(server string, params *PostApi217DirectoryServicesRolesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217DirectoryServicesTestRequest generates requests for GetApi217DirectoryServicesTest
func NewGetApi217DirectoryServicesTestRequest(server string, params *GetApi217DirectoryServicesTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217DirectoryServicesTestRequest calls the generic PatchApi217DirectoryServicesTest builder with application/json body
func NewPatchApi217DirectoryServicesTestRequest(server string, params *PatchApi217DirectoryServicesTestParams, body PatchApi217DirectoryServicesTestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217DirectoryServicesTestRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217DirectoryServicesTestRequestWithBody generates requests for PatchApi217DirectoryServicesTest with any type of body
func NewPatchApi217DirectoryServicesTestRequestWithBody(server string, params *PatchApi217DirectoryServicesTestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/directory-services/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217DnsRequest generates requests for DeleteApi217Dns
func NewDeleteApi217DnsRequest(server string, params *DeleteApi217DnsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/dns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217DnsRequest generates requests for GetApi217Dns
func NewGetApi217DnsRequest(server string, params *GetApi217DnsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/dns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217DnsRequest calls the generic PatchApi217Dns builder with application/json body
func NewPatchApi217DnsRequest(server string, params *PatchApi217DnsParams, body PatchApi217DnsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217DnsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217DnsRequestWithBody generates requests for PatchApi217Dns with any type of body
func NewPatchApi217DnsRequestWithBody(server string, params *PatchApi217DnsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/dns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217DnsRequest calls the generic PostApi217Dns builder with application/json body
func NewPostApi217DnsRequest(server string, params *PostApi217DnsParams, body PostApi217DnsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217DnsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217DnsRequestWithBody generates requests for PostApi217Dns with any type of body
func NewPostApi217DnsRequestWithBody(server string, params *PostApi217DnsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/dns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217DrivesRequest generates requests for GetApi217Drives
func NewGetApi217DrivesRequest(server string, params *GetApi217DrivesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/drives")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemExportsRequest generates requests for DeleteApi217FileSystemExports
func NewDeleteApi217FileSystemExportsRequest(server string, params *DeleteApi217FileSystemExportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemExportsRequest generates requests for GetApi217FileSystemExports
func NewGetApi217FileSystemExportsRequest(server string, params *GetApi217FileSystemExportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217FileSystemExportsRequest calls the generic PatchApi217FileSystemExports builder with application/json body
func NewPatchApi217FileSystemExportsRequest(server string, params *PatchApi217FileSystemExportsParams, body PatchApi217FileSystemExportsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217FileSystemExportsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217FileSystemExportsRequestWithBody generates requests for PatchApi217FileSystemExports with any type of body
func NewPatchApi217FileSystemExportsRequestWithBody(server string, params *PatchApi217FileSystemExportsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemExportsRequest calls the generic PostApi217FileSystemExports builder with application/json body
func NewPostApi217FileSystemExportsRequest(server string, params *PostApi217FileSystemExportsParams, body PostApi217FileSystemExportsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217FileSystemExportsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217FileSystemExportsRequestWithBody generates requests for PostApi217FileSystemExports with any type of body
func NewPostApi217FileSystemExportsRequestWithBody(server string, params *PostApi217FileSystemExportsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemReplicaLinksRequest generates requests for DeleteApi217FileSystemReplicaLinks
func NewDeleteApi217FileSystemReplicaLinksRequest(server string, params *DeleteApi217FileSystemReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CancelInProgressTransfers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cancel_in_progress_transfers", runtime.ParamLocationQuery, *params.CancelInProgressTransfers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_ids", runtime.ParamLocationQuery, *params.RemoteFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_names", runtime.ParamLocationQuery, *params.RemoteFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemReplicaLinksRequest generates requests for GetApi217FileSystemReplicaLinks
func NewGetApi217FileSystemReplicaLinksRequest(server string, params *GetApi217FileSystemReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_ids", runtime.ParamLocationQuery, *params.RemoteFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_names", runtime.ParamLocationQuery, *params.RemoteFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217FileSystemReplicaLinksRequest generates requests for PatchApi217FileSystemReplicaLinks
func NewPatchApi217FileSystemReplicaLinksRequest(server string, params *PatchApi217FileSystemReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReplicateNow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replicate_now", runtime.ParamLocationQuery, *params.ReplicateNow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemReplicaLinksRequest calls the generic PostApi217FileSystemReplicaLinks builder with application/json body
func NewPostApi217FileSystemReplicaLinksRequest(server string, params *PostApi217FileSystemReplicaLinksParams, body PostApi217FileSystemReplicaLinksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217FileSystemReplicaLinksRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217FileSystemReplicaLinksRequestWithBody generates requests for PostApi217FileSystemReplicaLinks with any type of body
func NewPostApi217FileSystemReplicaLinksRequestWithBody(server string, params *PostApi217FileSystemReplicaLinksParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_names", runtime.ParamLocationQuery, *params.RemoteFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemReplicaLinksPoliciesRequest generates requests for DeleteApi217FileSystemReplicaLinksPolicies
func NewDeleteApi217FileSystemReplicaLinksPoliciesRequest(server string, params *DeleteApi217FileSystemReplicaLinksPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemReplicaLinksPoliciesRequest generates requests for GetApi217FileSystemReplicaLinksPolicies
func NewGetApi217FileSystemReplicaLinksPoliciesRequest(server string, params *GetApi217FileSystemReplicaLinksPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_ids", runtime.ParamLocationQuery, *params.RemoteFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_names", runtime.ParamLocationQuery, *params.RemoteFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemReplicaLinksPoliciesRequest generates requests for PostApi217FileSystemReplicaLinksPolicies
func NewPostApi217FileSystemReplicaLinksPoliciesRequest(server string, params *PostApi217FileSystemReplicaLinksPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemReplicaLinksTransferRequest generates requests for GetApi217FileSystemReplicaLinksTransfer
func NewGetApi217FileSystemReplicaLinksTransferRequest(server string, params *GetApi217FileSystemReplicaLinksTransferParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-replica-links/transfer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesOrOwnerNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names_or_owner_names", runtime.ParamLocationQuery, *params.NamesOrOwnerNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemSnapshotsRequest generates requests for DeleteApi217FileSystemSnapshots
func NewDeleteApi217FileSystemSnapshotsRequest(server string, params *DeleteApi217FileSystemSnapshotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemSnapshotsRequest generates requests for GetApi217FileSystemSnapshots
func NewGetApi217FileSystemSnapshotsRequest(server string, params *GetApi217FileSystemSnapshotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Destroyed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destroyed", runtime.ParamLocationQuery, *params.Destroyed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesOrOwnerNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names_or_owner_names", runtime.ParamLocationQuery, *params.NamesOrOwnerNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OwnerIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "owner_ids", runtime.ParamLocationQuery, *params.OwnerIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217FileSystemSnapshotsRequest calls the generic PatchApi217FileSystemSnapshots builder with application/json body
func NewPatchApi217FileSystemSnapshotsRequest(server string, params *PatchApi217FileSystemSnapshotsParams, body PatchApi217FileSystemSnapshotsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217FileSystemSnapshotsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217FileSystemSnapshotsRequestWithBody generates requests for PatchApi217FileSystemSnapshots with any type of body
func NewPatchApi217FileSystemSnapshotsRequestWithBody(server string, params *PatchApi217FileSystemSnapshotsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LatestReplica != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "latest_replica", runtime.ParamLocationQuery, *params.LatestReplica); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemSnapshotsRequest calls the generic PostApi217FileSystemSnapshots builder with application/json body
func NewPostApi217FileSystemSnapshotsRequest(server string, params *PostApi217FileSystemSnapshotsParams, body PostApi217FileSystemSnapshotsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217FileSystemSnapshotsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217FileSystemSnapshotsRequestWithBody generates requests for PostApi217FileSystemSnapshots with any type of body
func NewPostApi217FileSystemSnapshotsRequestWithBody(server string, params *PostApi217FileSystemSnapshotsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Send != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "send", runtime.ParamLocationQuery, *params.Send); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_ids", runtime.ParamLocationQuery, *params.SourceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SourceNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "source_names", runtime.ParamLocationQuery, *params.SourceNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Targets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "targets", runtime.ParamLocationQuery, *params.Targets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemSnapshotsPoliciesRequest generates requests for DeleteApi217FileSystemSnapshotsPolicies
func NewDeleteApi217FileSystemSnapshotsPoliciesRequest(server string, params *DeleteApi217FileSystemSnapshotsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemSnapshotsPoliciesRequest generates requests for GetApi217FileSystemSnapshotsPolicies
func NewGetApi217FileSystemSnapshotsPoliciesRequest(server string, params *GetApi217FileSystemSnapshotsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemSnapshotsTransferRequest generates requests for DeleteApi217FileSystemSnapshotsTransfer
func NewDeleteApi217FileSystemSnapshotsTransferRequest(server string, params *DeleteApi217FileSystemSnapshotsTransferParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots/transfer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemSnapshotsTransferRequest generates requests for GetApi217FileSystemSnapshotsTransfer
func NewGetApi217FileSystemSnapshotsTransferRequest(server string, params *GetApi217FileSystemSnapshotsTransferParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-system-snapshots/transfer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesOrOwnerNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names_or_owner_names", runtime.ParamLocationQuery, *params.NamesOrOwnerNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemsRequest generates requests for DeleteApi217FileSystems
func NewDeleteApi217FileSystemsRequest(server string, params *DeleteApi217FileSystemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsRequest generates requests for GetApi217FileSystems
func NewGetApi217FileSystemsRequest(server string, params *GetApi217FileSystemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Destroyed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destroyed", runtime.ParamLocationQuery, *params.Destroyed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217FileSystemsRequest calls the generic PatchApi217FileSystems builder with application/json body
func NewPatchApi217FileSystemsRequest(server string, params *PatchApi217FileSystemsParams, body PatchApi217FileSystemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217FileSystemsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217FileSystemsRequestWithBody generates requests for PatchApi217FileSystems with any type of body
func NewPatchApi217FileSystemsRequestWithBody(server string, params *PatchApi217FileSystemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CancelInProgressStorageClassTransition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cancel_in_progress_storage_class_transition", runtime.ParamLocationQuery, *params.CancelInProgressStorageClassTransition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeleteLinkOnEradication != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_link_on_eradication", runtime.ParamLocationQuery, *params.DeleteLinkOnEradication); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscardDetailedPermissions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discard_detailed_permissions", runtime.ParamLocationQuery, *params.DiscardDetailedPermissions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscardNonSnapshottedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discard_non_snapshotted_data", runtime.ParamLocationQuery, *params.DiscardNonSnapshottedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignore_usage", runtime.ParamLocationQuery, *params.IgnoreUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemsRequest calls the generic PostApi217FileSystems builder with application/json body
func NewPostApi217FileSystemsRequest(server string, params *PostApi217FileSystemsParams, body PostApi217FileSystemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217FileSystemsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217FileSystemsRequestWithBody generates requests for PostApi217FileSystems with any type of body
func NewPostApi217FileSystemsRequestWithBody(server string, params *PostApi217FileSystemsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultExports != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_exports", runtime.ParamLocationQuery, *params.DefaultExports); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DiscardNonSnapshottedData != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discard_non_snapshotted_data", runtime.ParamLocationQuery, *params.DiscardNonSnapshottedData); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Overwrite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite", runtime.ParamLocationQuery, *params.Overwrite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemsAuditPoliciesRequest generates requests for DeleteApi217FileSystemsAuditPolicies
func NewDeleteApi217FileSystemsAuditPoliciesRequest(server string, params *DeleteApi217FileSystemsAuditPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/audit-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsAuditPoliciesRequest generates requests for GetApi217FileSystemsAuditPolicies
func NewGetApi217FileSystemsAuditPoliciesRequest(server string, params *GetApi217FileSystemsAuditPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/audit-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemsAuditPoliciesRequest generates requests for PostApi217FileSystemsAuditPolicies
func NewPostApi217FileSystemsAuditPoliciesRequest(server string, params *PostApi217FileSystemsAuditPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/audit-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsGroupsPerformanceRequest generates requests for GetApi217FileSystemsGroupsPerformance
func NewGetApi217FileSystemsGroupsPerformanceRequest(server string, params *GetApi217FileSystemsGroupsPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/groups/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "gids", runtime.ParamLocationQuery, *params.Gids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_names", runtime.ParamLocationQuery, *params.GroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemsLocksRequest generates requests for DeleteApi217FileSystemsLocks
func NewDeleteApi217FileSystemsLocksRequest(server string, params *DeleteApi217FileSystemsLocksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/locks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "client_names", runtime.ParamLocationQuery, *params.ClientNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Inodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "inodes", runtime.ParamLocationQuery, *params.Inodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsLocksRequest generates requests for GetApi217FileSystemsLocks
func NewGetApi217FileSystemsLocksRequest(server string, params *GetApi217FileSystemsLocksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/locks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "client_names", runtime.ParamLocationQuery, *params.ClientNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Inodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "inodes", runtime.ParamLocationQuery, *params.Inodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsLocksClientsRequest generates requests for GetApi217FileSystemsLocksClients
func NewGetApi217FileSystemsLocksClientsRequest(server string, params *GetApi217FileSystemsLocksClientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/locks/clients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemsLocksNlmReclamationsRequest generates requests for PostApi217FileSystemsLocksNlmReclamations
func NewPostApi217FileSystemsLocksNlmReclamationsRequest(server string, params *PostApi217FileSystemsLocksNlmReclamationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/locks/nlm-reclamations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemsOpenFilesRequest generates requests for DeleteApi217FileSystemsOpenFiles
func NewDeleteApi217FileSystemsOpenFilesRequest(server string, params *DeleteApi217FileSystemsOpenFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/open-files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsOpenFilesRequest generates requests for GetApi217FileSystemsOpenFiles
func NewGetApi217FileSystemsOpenFilesRequest(server string, params *GetApi217FileSystemsOpenFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/open-files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "client_names", runtime.ParamLocationQuery, *params.ClientNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "protocols", runtime.ParamLocationQuery, params.Protocols); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SessionNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "session_names", runtime.ParamLocationQuery, *params.SessionNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsPerformanceRequest generates requests for GetApi217FileSystemsPerformance
func NewGetApi217FileSystemsPerformanceRequest(server string, params *GetApi217FileSystemsPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Protocol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "protocol", runtime.ParamLocationQuery, *params.Protocol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemsPoliciesRequest generates requests for DeleteApi217FileSystemsPolicies
func NewDeleteApi217FileSystemsPoliciesRequest(server string, params *DeleteApi217FileSystemsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsPoliciesRequest generates requests for GetApi217FileSystemsPolicies
func NewGetApi217FileSystemsPoliciesRequest(server string, params *GetApi217FileSystemsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FileSystemsPoliciesRequest generates requests for PostApi217FileSystemsPolicies
func NewPostApi217FileSystemsPoliciesRequest(server string, params *PostApi217FileSystemsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsPoliciesAllRequest generates requests for GetApi217FileSystemsPoliciesAll
func NewGetApi217FileSystemsPoliciesAllRequest(server string, params *GetApi217FileSystemsPoliciesAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/policies-all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FileSystemsSessionsRequest generates requests for DeleteApi217FileSystemsSessions
func NewDeleteApi217FileSystemsSessionsRequest(server string, params *DeleteApi217FileSystemsSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "client_names", runtime.ParamLocationQuery, *params.ClientNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Disruptive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "disruptive", runtime.ParamLocationQuery, *params.Disruptive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Protocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "protocols", runtime.ParamLocationQuery, *params.Protocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsSessionsRequest generates requests for GetApi217FileSystemsSessions
func NewGetApi217FileSystemsSessionsRequest(server string, params *GetApi217FileSystemsSessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClientNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "client_names", runtime.ParamLocationQuery, *params.ClientNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Protocols != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "protocols", runtime.ParamLocationQuery, *params.Protocols); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsUsersPerformanceRequest generates requests for GetApi217FileSystemsUsersPerformance
func NewGetApi217FileSystemsUsersPerformanceRequest(server string, params *GetApi217FileSystemsUsersPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/users/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "uids", runtime.ParamLocationQuery, *params.Uids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FileSystemsWormDataPoliciesRequest generates requests for GetApi217FileSystemsWormDataPolicies
func NewGetApi217FileSystemsWormDataPoliciesRequest(server string, params *GetApi217FileSystemsWormDataPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/file-systems/worm-data-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FleetsRequest generates requests for DeleteApi217Fleets
func NewDeleteApi217FleetsRequest(server string, params *DeleteApi217FleetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FleetsRequest generates requests for GetApi217Fleets
func NewGetApi217FleetsRequest(server string, params *GetApi217FleetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217FleetsRequest calls the generic PatchApi217Fleets builder with application/json body
func NewPatchApi217FleetsRequest(server string, params *PatchApi217FleetsParams, body PatchApi217FleetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217FleetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217FleetsRequestWithBody generates requests for PatchApi217Fleets with any type of body
func NewPatchApi217FleetsRequestWithBody(server string, params *PatchApi217FleetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FleetsRequest generates requests for PostApi217Fleets
func NewPostApi217FleetsRequest(server string, params *PostApi217FleetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FleetsFleetKeyRequest generates requests for GetApi217FleetsFleetKey
func NewGetApi217FleetsFleetKeyRequest(server string, params *GetApi217FleetsFleetKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets/fleet-key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FleetsFleetKeyRequest generates requests for PostApi217FleetsFleetKey
func NewPostApi217FleetsFleetKeyRequest(server string, params *PostApi217FleetsFleetKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets/fleet-key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217FleetsMembersRequest generates requests for DeleteApi217FleetsMembers
func NewDeleteApi217FleetsMembersRequest(server string, params *DeleteApi217FleetsMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unreachable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unreachable", runtime.ParamLocationQuery, *params.Unreachable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217FleetsMembersRequest generates requests for GetApi217FleetsMembers
func NewGetApi217FleetsMembersRequest(server string, params *GetApi217FleetsMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FleetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fleet_ids", runtime.ParamLocationQuery, *params.FleetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FleetNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fleet_names", runtime.ParamLocationQuery, *params.FleetNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217FleetsMembersRequest calls the generic PostApi217FleetsMembers builder with application/json body
func NewPostApi217FleetsMembersRequest(server string, params *PostApi217FleetsMembersParams, body PostApi217FleetsMembersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217FleetsMembersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217FleetsMembersRequestWithBody generates requests for PostApi217FleetsMembers with any type of body
func NewPostApi217FleetsMembersRequestWithBody(server string, params *PostApi217FleetsMembersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/fleets/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FleetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fleet_ids", runtime.ParamLocationQuery, *params.FleetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FleetNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fleet_names", runtime.ParamLocationQuery, *params.FleetNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217HardwareRequest generates requests for GetApi217Hardware
func NewGetApi217HardwareRequest(server string, params *GetApi217HardwareParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/hardware")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217HardwareRequest calls the generic PatchApi217Hardware builder with application/json body
func NewPatchApi217HardwareRequest(server string, params *PatchApi217HardwareParams, body PatchApi217HardwareJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217HardwareRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217HardwareRequestWithBody generates requests for PatchApi217Hardware with any type of body
func NewPatchApi217HardwareRequestWithBody(server string, params *PatchApi217HardwareParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/hardware")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217HardwareConnectorsRequest generates requests for GetApi217HardwareConnectors
func NewGetApi217HardwareConnectorsRequest(server string, params *GetApi217HardwareConnectorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/hardware-connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217HardwareConnectorsRequest calls the generic PatchApi217HardwareConnectors builder with application/json body
func NewPatchApi217HardwareConnectorsRequest(server string, params *PatchApi217HardwareConnectorsParams, body PatchApi217HardwareConnectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217HardwareConnectorsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217HardwareConnectorsRequestWithBody generates requests for PatchApi217HardwareConnectors with any type of body
func NewPatchApi217HardwareConnectorsRequestWithBody(server string, params *PatchApi217HardwareConnectorsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/hardware-connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217HardwareConnectorsPerformanceRequest generates requests for GetApi217HardwareConnectorsPerformance
func NewGetApi217HardwareConnectorsPerformanceRequest(server string, params *GetApi217HardwareConnectorsPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/hardware-connectors/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217KeytabsRequest generates requests for DeleteApi217Keytabs
func NewDeleteApi217KeytabsRequest(server string, params *DeleteApi217KeytabsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/keytabs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217KeytabsRequest generates requests for GetApi217Keytabs
func NewGetApi217KeytabsRequest(server string, params *GetApi217KeytabsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/keytabs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217KeytabsRequest calls the generic PostApi217Keytabs builder with application/json body
func NewPostApi217KeytabsRequest(server string, params *PostApi217KeytabsParams, body PostApi217KeytabsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217KeytabsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217KeytabsRequestWithBody generates requests for PostApi217Keytabs with any type of body
func NewPostApi217KeytabsRequestWithBody(server string, params *PostApi217KeytabsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/keytabs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NamePrefixes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_prefixes", runtime.ParamLocationQuery, *params.NamePrefixes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217KeytabsDownloadRequest generates requests for GetApi217KeytabsDownload
func NewGetApi217KeytabsDownloadRequest(server string, params *GetApi217KeytabsDownloadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/keytabs/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.KeytabIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "keytab_ids", runtime.ParamLocationQuery, *params.KeytabIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.KeytabNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "keytab_names", runtime.ParamLocationQuery, *params.KeytabNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217KeytabsUploadRequestWithBody generates requests for PostApi217KeytabsUpload with any type of body
func NewPostApi217KeytabsUploadRequestWithBody(server string, params *PostApi217KeytabsUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/keytabs/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NamePrefixes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_prefixes", runtime.ParamLocationQuery, *params.NamePrefixes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217KmipRequest generates requests for DeleteApi217Kmip
func NewDeleteApi217KmipRequest(server string, params *DeleteApi217KmipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/kmip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217KmipRequest generates requests for GetApi217Kmip
func NewGetApi217KmipRequest(server string, params *GetApi217KmipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/kmip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217KmipRequest calls the generic PatchApi217Kmip builder with application/json body
func NewPatchApi217KmipRequest(server string, params *PatchApi217KmipParams, body PatchApi217KmipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217KmipRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217KmipRequestWithBody generates requests for PatchApi217Kmip with any type of body
func NewPatchApi217KmipRequestWithBody(server string, params *PatchApi217KmipParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/kmip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217KmipRequest calls the generic PostApi217Kmip builder with application/json body
func NewPostApi217KmipRequest(server string, params *PostApi217KmipParams, body PostApi217KmipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217KmipRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217KmipRequestWithBody generates requests for PostApi217Kmip with any type of body
func NewPostApi217KmipRequestWithBody(server string, params *PostApi217KmipParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/kmip")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217KmipTestRequest generates requests for GetApi217KmipTest
func NewGetApi217KmipTestRequest(server string, params *GetApi217KmipTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/kmip/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217LegalHoldsRequest generates requests for DeleteApi217LegalHolds
func NewDeleteApi217LegalHoldsRequest(server string, params *DeleteApi217LegalHoldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/legal-holds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217LegalHoldsRequest generates requests for GetApi217LegalHolds
func NewGetApi217LegalHoldsRequest(server string, params *GetApi217LegalHoldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/legal-holds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217LegalHoldsRequest calls the generic PatchApi217LegalHolds builder with application/json body
func NewPatchApi217LegalHoldsRequest(server string, params *PatchApi217LegalHoldsParams, body PatchApi217LegalHoldsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217LegalHoldsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217LegalHoldsRequestWithBody generates requests for PatchApi217LegalHolds with any type of body
func NewPatchApi217LegalHoldsRequestWithBody(server string, params *PatchApi217LegalHoldsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/legal-holds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217LegalHoldsRequest calls the generic PostApi217LegalHolds builder with application/json body
func NewPostApi217LegalHoldsRequest(server string, params *PostApi217LegalHoldsParams, body PostApi217LegalHoldsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217LegalHoldsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217LegalHoldsRequestWithBody generates requests for PostApi217LegalHolds with any type of body
func NewPostApi217LegalHoldsRequestWithBody(server string, params *PostApi217LegalHoldsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/legal-holds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217LegalHoldsHeldEntitiesRequest generates requests for GetApi217LegalHoldsHeldEntities
func NewGetApi217LegalHoldsHeldEntitiesRequest(server string, params *GetApi217LegalHoldsHeldEntitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/legal-holds/held-entities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217LegalHoldsHeldEntitiesRequest generates requests for PatchApi217LegalHoldsHeldEntities
func NewPatchApi217LegalHoldsHeldEntitiesRequest(server string, params *PatchApi217LegalHoldsHeldEntitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/legal-holds/held-entities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "released", runtime.ParamLocationQuery, params.Released); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217LegalHoldsHeldEntitiesRequest generates requests for PostApi217LegalHoldsHeldEntities
func NewPostApi217LegalHoldsHeldEntitiesRequest(server string, params *PostApi217LegalHoldsHeldEntitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/legal-holds/held-entities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Paths != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "paths", runtime.ParamLocationQuery, *params.Paths); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Recursive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217LifecycleRulesRequest generates requests for DeleteApi217LifecycleRules
func NewDeleteApi217LifecycleRulesRequest(server string, params *DeleteApi217LifecycleRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/lifecycle-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217LifecycleRulesRequest generates requests for GetApi217LifecycleRules
func NewGetApi217LifecycleRulesRequest(server string, params *GetApi217LifecycleRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/lifecycle-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217LifecycleRulesRequest calls the generic PatchApi217LifecycleRules builder with application/json body
func NewPatchApi217LifecycleRulesRequest(server string, params *PatchApi217LifecycleRulesParams, body PatchApi217LifecycleRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217LifecycleRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217LifecycleRulesRequestWithBody generates requests for PatchApi217LifecycleRules with any type of body
func NewPatchApi217LifecycleRulesRequestWithBody(server string, params *PatchApi217LifecycleRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/lifecycle-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BucketIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_ids", runtime.ParamLocationQuery, *params.BucketIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BucketNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bucket_names", runtime.ParamLocationQuery, *params.BucketNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ConfirmDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "confirm_date", runtime.ParamLocationQuery, *params.ConfirmDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217LifecycleRulesRequest calls the generic PostApi217LifecycleRules builder with application/json body
func NewPostApi217LifecycleRulesRequest(server string, params *PostApi217LifecycleRulesParams, body PostApi217LifecycleRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217LifecycleRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217LifecycleRulesRequestWithBody generates requests for PostApi217LifecycleRules with any type of body
func NewPostApi217LifecycleRulesRequestWithBody(server string, params *PostApi217LifecycleRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/lifecycle-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ConfirmDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "confirm_date", runtime.ParamLocationQuery, *params.ConfirmDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217LinkAggregationGroupsRequest generates requests for DeleteApi217LinkAggregationGroups
func NewDeleteApi217LinkAggregationGroupsRequest(server string, params *DeleteApi217LinkAggregationGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/link-aggregation-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217LinkAggregationGroupsRequest generates requests for GetApi217LinkAggregationGroups
func NewGetApi217LinkAggregationGroupsRequest(server string, params *GetApi217LinkAggregationGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/link-aggregation-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217LinkAggregationGroupsRequest calls the generic PatchApi217LinkAggregationGroups builder with application/json body
func NewPatchApi217LinkAggregationGroupsRequest(server string, params *PatchApi217LinkAggregationGroupsParams, body PatchApi217LinkAggregationGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217LinkAggregationGroupsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217LinkAggregationGroupsRequestWithBody generates requests for PatchApi217LinkAggregationGroups with any type of body
func NewPatchApi217LinkAggregationGroupsRequestWithBody(server string, params *PatchApi217LinkAggregationGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/link-aggregation-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217LinkAggregationGroupsRequest calls the generic PostApi217LinkAggregationGroups builder with application/json body
func NewPostApi217LinkAggregationGroupsRequest(server string, params *PostApi217LinkAggregationGroupsParams, body PostApi217LinkAggregationGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217LinkAggregationGroupsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217LinkAggregationGroupsRequestWithBody generates requests for PostApi217LinkAggregationGroups with any type of body
func NewPostApi217LinkAggregationGroupsRequestWithBody(server string, params *PostApi217LinkAggregationGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/link-aggregation-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217LogsRequest generates requests for GetApi217Logs
func NewGetApi217LogsRequest(server string, params *GetApi217LogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217LogsAsyncRequest generates requests for GetApi217LogsAsync
func NewGetApi217LogsAsyncRequest(server string, params *GetApi217LogsAsyncParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/logs-async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217LogsAsyncRequest calls the generic PatchApi217LogsAsync builder with application/json body
func NewPatchApi217LogsAsyncRequest(server string, params *PatchApi217LogsAsyncParams, body PatchApi217LogsAsyncJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217LogsAsyncRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217LogsAsyncRequestWithBody generates requests for PatchApi217LogsAsync with any type of body
func NewPatchApi217LogsAsyncRequestWithBody(server string, params *PatchApi217LogsAsyncParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/logs-async")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217LogsAsyncDownloadRequest generates requests for GetApi217LogsAsyncDownload
func NewGetApi217LogsAsyncDownloadRequest(server string, params *GetApi217LogsAsyncDownloadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/logs-async/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217MaintenanceWindowsRequest generates requests for DeleteApi217MaintenanceWindows
func NewDeleteApi217MaintenanceWindowsRequest(server string, params *DeleteApi217MaintenanceWindowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/maintenance-windows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217MaintenanceWindowsRequest generates requests for GetApi217MaintenanceWindows
func NewGetApi217MaintenanceWindowsRequest(server string, params *GetApi217MaintenanceWindowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/maintenance-windows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217MaintenanceWindowsRequest calls the generic PostApi217MaintenanceWindows builder with application/json body
func NewPostApi217MaintenanceWindowsRequest(server string, params *PostApi217MaintenanceWindowsParams, body PostApi217MaintenanceWindowsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217MaintenanceWindowsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217MaintenanceWindowsRequestWithBody generates requests for PostApi217MaintenanceWindows with any type of body
func NewPostApi217MaintenanceWindowsRequestWithBody(server string, params *PostApi217MaintenanceWindowsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/maintenance-windows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkAccessPoliciesRequest generates requests for GetApi217NetworkAccessPolicies
func NewGetApi217NetworkAccessPoliciesRequest(server string, params *GetApi217NetworkAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217NetworkAccessPoliciesRequest calls the generic PatchApi217NetworkAccessPolicies builder with application/json body
func NewPatchApi217NetworkAccessPoliciesRequest(server string, params *PatchApi217NetworkAccessPoliciesParams, body PatchApi217NetworkAccessPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217NetworkAccessPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217NetworkAccessPoliciesRequestWithBody generates requests for PatchApi217NetworkAccessPolicies with any type of body
func NewPatchApi217NetworkAccessPoliciesRequestWithBody(server string, params *PatchApi217NetworkAccessPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkAccessPoliciesMembersRequest generates requests for GetApi217NetworkAccessPoliciesMembers
func NewGetApi217NetworkAccessPoliciesMembersRequest(server string, params *GetApi217NetworkAccessPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-access-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217NetworkAccessPoliciesRulesRequest generates requests for DeleteApi217NetworkAccessPoliciesRules
func NewDeleteApi217NetworkAccessPoliciesRulesRequest(server string, params *DeleteApi217NetworkAccessPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkAccessPoliciesRulesRequest generates requests for GetApi217NetworkAccessPoliciesRules
func NewGetApi217NetworkAccessPoliciesRulesRequest(server string, params *GetApi217NetworkAccessPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217NetworkAccessPoliciesRulesRequest calls the generic PatchApi217NetworkAccessPoliciesRules builder with application/json body
func NewPatchApi217NetworkAccessPoliciesRulesRequest(server string, params *PatchApi217NetworkAccessPoliciesRulesParams, body PatchApi217NetworkAccessPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217NetworkAccessPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217NetworkAccessPoliciesRulesRequestWithBody generates requests for PatchApi217NetworkAccessPoliciesRules with any type of body
func NewPatchApi217NetworkAccessPoliciesRulesRequestWithBody(server string, params *PatchApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeforeRuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_id", runtime.ParamLocationQuery, *params.BeforeRuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeRuleName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_name", runtime.ParamLocationQuery, *params.BeforeRuleName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217NetworkAccessPoliciesRulesRequest calls the generic PostApi217NetworkAccessPoliciesRules builder with application/json body
func NewPostApi217NetworkAccessPoliciesRulesRequest(server string, params *PostApi217NetworkAccessPoliciesRulesParams, body PostApi217NetworkAccessPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217NetworkAccessPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217NetworkAccessPoliciesRulesRequestWithBody generates requests for PostApi217NetworkAccessPoliciesRules with any type of body
func NewPostApi217NetworkAccessPoliciesRulesRequestWithBody(server string, params *PostApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeforeRuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_id", runtime.ParamLocationQuery, *params.BeforeRuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeRuleName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_name", runtime.ParamLocationQuery, *params.BeforeRuleName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217NetworkInterfacesRequest generates requests for DeleteApi217NetworkInterfaces
func NewDeleteApi217NetworkInterfacesRequest(server string, params *DeleteApi217NetworkInterfacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkInterfacesRequest generates requests for GetApi217NetworkInterfaces
func NewGetApi217NetworkInterfacesRequest(server string, params *GetApi217NetworkInterfacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217NetworkInterfacesRequest calls the generic PatchApi217NetworkInterfaces builder with application/json body
func NewPatchApi217NetworkInterfacesRequest(server string, params *PatchApi217NetworkInterfacesParams, body PatchApi217NetworkInterfacesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217NetworkInterfacesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217NetworkInterfacesRequestWithBody generates requests for PatchApi217NetworkInterfaces with any type of body
func NewPatchApi217NetworkInterfacesRequestWithBody(server string, params *PatchApi217NetworkInterfacesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217NetworkInterfacesRequest calls the generic PostApi217NetworkInterfaces builder with application/json body
func NewPostApi217NetworkInterfacesRequest(server string, params *PostApi217NetworkInterfacesParams, body PostApi217NetworkInterfacesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217NetworkInterfacesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217NetworkInterfacesRequestWithBody generates requests for PostApi217NetworkInterfaces with any type of body
func NewPostApi217NetworkInterfacesRequestWithBody(server string, params *PostApi217NetworkInterfacesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkInterfacesConnectorsRequest generates requests for GetApi217NetworkInterfacesConnectors
func NewGetApi217NetworkInterfacesConnectorsRequest(server string, params *GetApi217NetworkInterfacesConnectorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217NetworkInterfacesConnectorsRequest calls the generic PatchApi217NetworkInterfacesConnectors builder with application/json body
func NewPatchApi217NetworkInterfacesConnectorsRequest(server string, params *PatchApi217NetworkInterfacesConnectorsParams, body PatchApi217NetworkInterfacesConnectorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217NetworkInterfacesConnectorsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217NetworkInterfacesConnectorsRequestWithBody generates requests for PatchApi217NetworkInterfacesConnectors with any type of body
func NewPatchApi217NetworkInterfacesConnectorsRequestWithBody(server string, params *PatchApi217NetworkInterfacesConnectorsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkInterfacesConnectorsPerformanceRequest generates requests for GetApi217NetworkInterfacesConnectorsPerformance
func NewGetApi217NetworkInterfacesConnectorsPerformanceRequest(server string, params *GetApi217NetworkInterfacesConnectorsPerformanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/connectors/performance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkInterfacesConnectorsSettingsRequest generates requests for GetApi217NetworkInterfacesConnectorsSettings
func NewGetApi217NetworkInterfacesConnectorsSettingsRequest(server string, params *GetApi217NetworkInterfacesConnectorsSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/connectors/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkInterfacesPingRequest generates requests for GetApi217NetworkInterfacesPing
func NewGetApi217NetworkInterfacesPingRequest(server string, params *GetApi217NetworkInterfacesPingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ComponentName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component_name", runtime.ParamLocationQuery, *params.ComponentName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destination", runtime.ParamLocationQuery, params.Destination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PacketSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packet_size", runtime.ParamLocationQuery, *params.PacketSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PrintLatency != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "print_latency", runtime.ParamLocationQuery, *params.PrintLatency); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResolveHostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolve_hostname", runtime.ParamLocationQuery, *params.ResolveHostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217NetworkInterfacesTlsPoliciesRequest generates requests for DeleteApi217NetworkInterfacesTlsPolicies
func NewDeleteApi217NetworkInterfacesTlsPoliciesRequest(server string, params *DeleteApi217NetworkInterfacesTlsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/tls-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkInterfacesTlsPoliciesRequest generates requests for GetApi217NetworkInterfacesTlsPolicies
func NewGetApi217NetworkInterfacesTlsPoliciesRequest(server string, params *GetApi217NetworkInterfacesTlsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/tls-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217NetworkInterfacesTlsPoliciesRequest generates requests for PostApi217NetworkInterfacesTlsPolicies
func NewPostApi217NetworkInterfacesTlsPoliciesRequest(server string, params *PostApi217NetworkInterfacesTlsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/tls-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NetworkInterfacesTraceRequest generates requests for GetApi217NetworkInterfacesTrace
func NewGetApi217NetworkInterfacesTraceRequest(server string, params *GetApi217NetworkInterfacesTraceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/network-interfaces/trace")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ComponentName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component_name", runtime.ParamLocationQuery, *params.ComponentName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destination", runtime.ParamLocationQuery, params.Destination); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DiscoverMtu != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discover_mtu", runtime.ParamLocationQuery, *params.DiscoverMtu); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FragmentPacket != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fragment_packet", runtime.ParamLocationQuery, *params.FragmentPacket); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Method != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "method", runtime.ParamLocationQuery, *params.Method); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Port != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "port", runtime.ParamLocationQuery, *params.Port); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResolveHostname != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolve_hostname", runtime.ParamLocationQuery, *params.ResolveHostname); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Source != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source", runtime.ParamLocationQuery, *params.Source); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217NfsExportPoliciesRequest generates requests for DeleteApi217NfsExportPolicies
func NewDeleteApi217NfsExportPoliciesRequest(server string, params *DeleteApi217NfsExportPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NfsExportPoliciesRequest generates requests for GetApi217NfsExportPolicies
func NewGetApi217NfsExportPoliciesRequest(server string, params *GetApi217NfsExportPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217NfsExportPoliciesRequest calls the generic PatchApi217NfsExportPolicies builder with application/json body
func NewPatchApi217NfsExportPoliciesRequest(server string, params *PatchApi217NfsExportPoliciesParams, body PatchApi217NfsExportPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217NfsExportPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217NfsExportPoliciesRequestWithBody generates requests for PatchApi217NfsExportPolicies with any type of body
func NewPatchApi217NfsExportPoliciesRequestWithBody(server string, params *PatchApi217NfsExportPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217NfsExportPoliciesRequest calls the generic PostApi217NfsExportPolicies builder with application/json body
func NewPostApi217NfsExportPoliciesRequest(server string, params *PostApi217NfsExportPoliciesParams, body PostApi217NfsExportPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217NfsExportPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217NfsExportPoliciesRequestWithBody generates requests for PostApi217NfsExportPolicies with any type of body
func NewPostApi217NfsExportPoliciesRequestWithBody(server string, params *PostApi217NfsExportPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217NfsExportPoliciesRulesRequest generates requests for DeleteApi217NfsExportPoliciesRules
func NewDeleteApi217NfsExportPoliciesRulesRequest(server string, params *DeleteApi217NfsExportPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217NfsExportPoliciesRulesRequest generates requests for GetApi217NfsExportPoliciesRules
func NewGetApi217NfsExportPoliciesRulesRequest(server string, params *GetApi217NfsExportPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217NfsExportPoliciesRulesRequest calls the generic PatchApi217NfsExportPoliciesRules builder with application/json body
func NewPatchApi217NfsExportPoliciesRulesRequest(server string, params *PatchApi217NfsExportPoliciesRulesParams, body PatchApi217NfsExportPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217NfsExportPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217NfsExportPoliciesRulesRequestWithBody generates requests for PatchApi217NfsExportPoliciesRules with any type of body
func NewPatchApi217NfsExportPoliciesRulesRequestWithBody(server string, params *PatchApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeforeRuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_id", runtime.ParamLocationQuery, *params.BeforeRuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeRuleName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_name", runtime.ParamLocationQuery, *params.BeforeRuleName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217NfsExportPoliciesRulesRequest calls the generic PostApi217NfsExportPoliciesRules builder with application/json body
func NewPostApi217NfsExportPoliciesRulesRequest(server string, params *PostApi217NfsExportPoliciesRulesParams, body PostApi217NfsExportPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217NfsExportPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217NfsExportPoliciesRulesRequestWithBody generates requests for PostApi217NfsExportPoliciesRules with any type of body
func NewPostApi217NfsExportPoliciesRulesRequestWithBody(server string, params *PostApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/nfs-export-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeforeRuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_id", runtime.ParamLocationQuery, *params.BeforeRuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeRuleName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_name", runtime.ParamLocationQuery, *params.BeforeRuleName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreAccessKeysRequest generates requests for DeleteApi217ObjectStoreAccessKeys
func NewDeleteApi217ObjectStoreAccessKeysRequest(server string, params *DeleteApi217ObjectStoreAccessKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreAccessKeysRequest generates requests for GetApi217ObjectStoreAccessKeys
func NewGetApi217ObjectStoreAccessKeysRequest(server string, params *GetApi217ObjectStoreAccessKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreAccessKeysRequest calls the generic PatchApi217ObjectStoreAccessKeys builder with application/json body
func NewPatchApi217ObjectStoreAccessKeysRequest(server string, params *PatchApi217ObjectStoreAccessKeysParams, body PatchApi217ObjectStoreAccessKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreAccessKeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreAccessKeysRequestWithBody generates requests for PatchApi217ObjectStoreAccessKeys with any type of body
func NewPatchApi217ObjectStoreAccessKeysRequestWithBody(server string, params *PatchApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreAccessKeysRequest calls the generic PostApi217ObjectStoreAccessKeys builder with application/json body
func NewPostApi217ObjectStoreAccessKeysRequest(server string, params *PostApi217ObjectStoreAccessKeysParams, body PostApi217ObjectStoreAccessKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ObjectStoreAccessKeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ObjectStoreAccessKeysRequestWithBody generates requests for PostApi217ObjectStoreAccessKeys with any type of body
func NewPostApi217ObjectStoreAccessKeysRequestWithBody(server string, params *PostApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreAccessPoliciesRequest generates requests for DeleteApi217ObjectStoreAccessPolicies
func NewDeleteApi217ObjectStoreAccessPoliciesRequest(server string, params *DeleteApi217ObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreAccessPoliciesRequest generates requests for GetApi217ObjectStoreAccessPolicies
func NewGetApi217ObjectStoreAccessPoliciesRequest(server string, params *GetApi217ObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeRules != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_rules", runtime.ParamLocationQuery, *params.ExcludeRules); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreAccessPoliciesRequest calls the generic PatchApi217ObjectStoreAccessPolicies builder with application/json body
func NewPatchApi217ObjectStoreAccessPoliciesRequest(server string, params *PatchApi217ObjectStoreAccessPoliciesParams, body PatchApi217ObjectStoreAccessPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreAccessPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreAccessPoliciesRequestWithBody generates requests for PatchApi217ObjectStoreAccessPolicies with any type of body
func NewPatchApi217ObjectStoreAccessPoliciesRequestWithBody(server string, params *PatchApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnforceActionRestrictions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enforce_action_restrictions", runtime.ParamLocationQuery, *params.EnforceActionRestrictions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreAccessPoliciesRequest calls the generic PostApi217ObjectStoreAccessPolicies builder with application/json body
func NewPostApi217ObjectStoreAccessPoliciesRequest(server string, params *PostApi217ObjectStoreAccessPoliciesParams, body PostApi217ObjectStoreAccessPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ObjectStoreAccessPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ObjectStoreAccessPoliciesRequestWithBody generates requests for PostApi217ObjectStoreAccessPolicies with any type of body
func NewPostApi217ObjectStoreAccessPoliciesRequestWithBody(server string, params *PostApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnforceActionRestrictions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enforce_action_restrictions", runtime.ParamLocationQuery, *params.EnforceActionRestrictions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest generates requests for DeleteApi217ObjectStoreAccessPoliciesObjectStoreRoles
func NewDeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest(server string, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/object-store-roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest generates requests for GetApi217ObjectStoreAccessPoliciesObjectStoreRoles
func NewGetApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest(server string, params *GetApi217ObjectStoreAccessPoliciesObjectStoreRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/object-store-roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest generates requests for PostApi217ObjectStoreAccessPoliciesObjectStoreRoles
func NewPostApi217ObjectStoreAccessPoliciesObjectStoreRolesRequest(server string, params *PostApi217ObjectStoreAccessPoliciesObjectStoreRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/object-store-roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest generates requests for DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsers
func NewDeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest(server string, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/object-store-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest generates requests for GetApi217ObjectStoreAccessPoliciesObjectStoreUsers
func NewGetApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest(server string, params *GetApi217ObjectStoreAccessPoliciesObjectStoreUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/object-store-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest generates requests for PostApi217ObjectStoreAccessPoliciesObjectStoreUsers
func NewPostApi217ObjectStoreAccessPoliciesObjectStoreUsersRequest(server string, params *PostApi217ObjectStoreAccessPoliciesObjectStoreUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/object-store-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreAccessPoliciesRulesRequest generates requests for DeleteApi217ObjectStoreAccessPoliciesRules
func NewDeleteApi217ObjectStoreAccessPoliciesRulesRequest(server string, params *DeleteApi217ObjectStoreAccessPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreAccessPoliciesRulesRequest generates requests for GetApi217ObjectStoreAccessPoliciesRules
func NewGetApi217ObjectStoreAccessPoliciesRulesRequest(server string, params *GetApi217ObjectStoreAccessPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreAccessPoliciesRulesRequest calls the generic PatchApi217ObjectStoreAccessPoliciesRules builder with application/json body
func NewPatchApi217ObjectStoreAccessPoliciesRulesRequest(server string, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, body PatchApi217ObjectStoreAccessPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreAccessPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreAccessPoliciesRulesRequestWithBody generates requests for PatchApi217ObjectStoreAccessPoliciesRules with any type of body
func NewPatchApi217ObjectStoreAccessPoliciesRulesRequestWithBody(server string, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnforceActionRestrictions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enforce_action_restrictions", runtime.ParamLocationQuery, *params.EnforceActionRestrictions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreAccessPoliciesRulesRequest calls the generic PostApi217ObjectStoreAccessPoliciesRules builder with application/json body
func NewPostApi217ObjectStoreAccessPoliciesRulesRequest(server string, params *PostApi217ObjectStoreAccessPoliciesRulesParams, body PostApi217ObjectStoreAccessPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ObjectStoreAccessPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ObjectStoreAccessPoliciesRulesRequestWithBody generates requests for PostApi217ObjectStoreAccessPoliciesRules with any type of body
func NewPostApi217ObjectStoreAccessPoliciesRulesRequestWithBody(server string, params *PostApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EnforceActionRestrictions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enforce_action_restrictions", runtime.ParamLocationQuery, *params.EnforceActionRestrictions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreAccessPolicyActionsRequest generates requests for GetApi217ObjectStoreAccessPolicyActions
func NewGetApi217ObjectStoreAccessPolicyActionsRequest(server string, params *GetApi217ObjectStoreAccessPolicyActionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-access-policy-actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreAccountsRequest generates requests for DeleteApi217ObjectStoreAccounts
func NewDeleteApi217ObjectStoreAccountsRequest(server string, params *DeleteApi217ObjectStoreAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreAccountsRequest generates requests for GetApi217ObjectStoreAccounts
func NewGetApi217ObjectStoreAccountsRequest(server string, params *GetApi217ObjectStoreAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreAccountsRequest calls the generic PatchApi217ObjectStoreAccounts builder with application/json body
func NewPatchApi217ObjectStoreAccountsRequest(server string, params *PatchApi217ObjectStoreAccountsParams, body PatchApi217ObjectStoreAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreAccountsRequestWithBody generates requests for PatchApi217ObjectStoreAccounts with any type of body
func NewPatchApi217ObjectStoreAccountsRequestWithBody(server string, params *PatchApi217ObjectStoreAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignore_usage", runtime.ParamLocationQuery, *params.IgnoreUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreAccountsRequest calls the generic PostApi217ObjectStoreAccounts builder with application/json body
func NewPostApi217ObjectStoreAccountsRequest(server string, params *PostApi217ObjectStoreAccountsParams, body PostApi217ObjectStoreAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ObjectStoreAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ObjectStoreAccountsRequestWithBody generates requests for PostApi217ObjectStoreAccounts with any type of body
func NewPostApi217ObjectStoreAccountsRequestWithBody(server string, params *PostApi217ObjectStoreAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreRemoteCredentialsRequest generates requests for DeleteApi217ObjectStoreRemoteCredentials
func NewDeleteApi217ObjectStoreRemoteCredentialsRequest(server string, params *DeleteApi217ObjectStoreRemoteCredentialsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-remote-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreRemoteCredentialsRequest generates requests for GetApi217ObjectStoreRemoteCredentials
func NewGetApi217ObjectStoreRemoteCredentialsRequest(server string, params *GetApi217ObjectStoreRemoteCredentialsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-remote-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreRemoteCredentialsRequest calls the generic PatchApi217ObjectStoreRemoteCredentials builder with application/json body
func NewPatchApi217ObjectStoreRemoteCredentialsRequest(server string, params *PatchApi217ObjectStoreRemoteCredentialsParams, body PatchApi217ObjectStoreRemoteCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreRemoteCredentialsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreRemoteCredentialsRequestWithBody generates requests for PatchApi217ObjectStoreRemoteCredentials with any type of body
func NewPatchApi217ObjectStoreRemoteCredentialsRequestWithBody(server string, params *PatchApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-remote-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreRemoteCredentialsRequest calls the generic PostApi217ObjectStoreRemoteCredentials builder with application/json body
func NewPostApi217ObjectStoreRemoteCredentialsRequest(server string, params *PostApi217ObjectStoreRemoteCredentialsParams, body PostApi217ObjectStoreRemoteCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ObjectStoreRemoteCredentialsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ObjectStoreRemoteCredentialsRequestWithBody generates requests for PostApi217ObjectStoreRemoteCredentials with any type of body
func NewPostApi217ObjectStoreRemoteCredentialsRequestWithBody(server string, params *PostApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-remote-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreRolesRequest generates requests for DeleteApi217ObjectStoreRoles
func NewDeleteApi217ObjectStoreRolesRequest(server string, params *DeleteApi217ObjectStoreRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreRolesRequest generates requests for GetApi217ObjectStoreRoles
func NewGetApi217ObjectStoreRolesRequest(server string, params *GetApi217ObjectStoreRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreRolesRequest calls the generic PatchApi217ObjectStoreRoles builder with application/json body
func NewPatchApi217ObjectStoreRolesRequest(server string, params *PatchApi217ObjectStoreRolesParams, body PatchApi217ObjectStoreRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreRolesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreRolesRequestWithBody generates requests for PatchApi217ObjectStoreRoles with any type of body
func NewPatchApi217ObjectStoreRolesRequestWithBody(server string, params *PatchApi217ObjectStoreRolesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreRolesRequest calls the generic PostApi217ObjectStoreRoles builder with application/json body
func NewPostApi217ObjectStoreRolesRequest(server string, params *PostApi217ObjectStoreRolesParams, body PostApi217ObjectStoreRolesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ObjectStoreRolesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ObjectStoreRolesRequestWithBody generates requests for PostApi217ObjectStoreRoles with any type of body
func NewPostApi217ObjectStoreRolesRequestWithBody(server string, params *PostApi217ObjectStoreRolesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest generates requests for DeleteApi217ObjectStoreRolesObjectStoreAccessPolicies
func NewDeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest(server string, params *DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest generates requests for GetApi217ObjectStoreRolesObjectStoreAccessPolicies
func NewGetApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest(server string, params *GetApi217ObjectStoreRolesObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest generates requests for PostApi217ObjectStoreRolesObjectStoreAccessPolicies
func NewPostApi217ObjectStoreRolesObjectStoreAccessPoliciesRequest(server string, params *PostApi217ObjectStoreRolesObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRequest generates requests for GetApi217ObjectStoreRolesObjectStoreTrustPolicies
func NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRequest(server string, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-trust-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadRequest generates requests for GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownload
func NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadRequest(server string, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-trust-policies/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest generates requests for DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRules
func NewDeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(server string, params *DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-trust-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Indices != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "indices", runtime.ParamLocationQuery, *params.Indices); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest generates requests for GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRules
func NewGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(server string, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-trust-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Indices != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "indices", runtime.ParamLocationQuery, *params.Indices); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest calls the generic PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRules builder with application/json body
func NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(server string, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody generates requests for PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRules with any type of body
func NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody(server string, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-trust-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Indices != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "indices", runtime.ParamLocationQuery, *params.Indices); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest calls the generic PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRules builder with application/json body
func NewPostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequest(server string, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody generates requests for PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRules with any type of body
func NewPostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesRequestWithBody(server string, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-trust-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadRequest calls the generic PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUpload builder with application/json body
func NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadRequest(server string, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadRequestWithBody generates requests for PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUpload with any type of body
func NewPatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadRequestWithBody(server string, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-roles/object-store-trust-policies/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_ids", runtime.ParamLocationQuery, *params.RoleIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "role_names", runtime.ParamLocationQuery, *params.RoleNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreUsersRequest generates requests for DeleteApi217ObjectStoreUsers
func NewDeleteApi217ObjectStoreUsersRequest(server string, params *DeleteApi217ObjectStoreUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreUsersRequest generates requests for GetApi217ObjectStoreUsers
func NewGetApi217ObjectStoreUsersRequest(server string, params *GetApi217ObjectStoreUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreUsersRequest generates requests for PostApi217ObjectStoreUsers
func NewPostApi217ObjectStoreUsersRequest(server string, params *PostApi217ObjectStoreUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullAccess != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_access", runtime.ParamLocationQuery, *params.FullAccess); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest generates requests for DeleteApi217ObjectStoreUsersObjectStoreAccessPolicies
func NewDeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest(server string, params *DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-users/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest generates requests for GetApi217ObjectStoreUsersObjectStoreAccessPolicies
func NewGetApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest(server string, params *GetApi217ObjectStoreUsersObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-users/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest generates requests for PostApi217ObjectStoreUsersObjectStoreAccessPolicies
func NewPostApi217ObjectStoreUsersObjectStoreAccessPoliciesRequest(server string, params *PostApi217ObjectStoreUsersObjectStoreAccessPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-users/object-store-access-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ObjectStoreVirtualHostsRequest generates requests for DeleteApi217ObjectStoreVirtualHosts
func NewDeleteApi217ObjectStoreVirtualHostsRequest(server string, params *DeleteApi217ObjectStoreVirtualHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-virtual-hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ObjectStoreVirtualHostsRequest generates requests for GetApi217ObjectStoreVirtualHosts
func NewGetApi217ObjectStoreVirtualHostsRequest(server string, params *GetApi217ObjectStoreVirtualHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-virtual-hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ObjectStoreVirtualHostsRequest generates requests for PostApi217ObjectStoreVirtualHosts
func NewPostApi217ObjectStoreVirtualHostsRequest(server string, params *PostApi217ObjectStoreVirtualHostsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/object-store-virtual-hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PasswordPoliciesRequest generates requests for GetApi217PasswordPolicies
func NewGetApi217PasswordPoliciesRequest(server string, params *GetApi217PasswordPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/password-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217PasswordPoliciesRequest calls the generic PatchApi217PasswordPolicies builder with application/json body
func NewPatchApi217PasswordPoliciesRequest(server string, params *PatchApi217PasswordPoliciesParams, body PatchApi217PasswordPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217PasswordPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217PasswordPoliciesRequestWithBody generates requests for PatchApi217PasswordPolicies with any type of body
func NewPatchApi217PasswordPoliciesRequestWithBody(server string, params *PatchApi217PasswordPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/password-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217PoliciesRequest generates requests for DeleteApi217Policies
func NewDeleteApi217PoliciesRequest(server string, params *DeleteApi217PoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PoliciesRequest generates requests for GetApi217Policies
func NewGetApi217PoliciesRequest(server string, params *GetApi217PoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217PoliciesRequest calls the generic PatchApi217Policies builder with application/json body
func NewPatchApi217PoliciesRequest(server string, params *PatchApi217PoliciesParams, body PatchApi217PoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217PoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217PoliciesRequestWithBody generates requests for PatchApi217Policies with any type of body
func NewPatchApi217PoliciesRequestWithBody(server string, params *PatchApi217PoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestroySnapshots != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destroy_snapshots", runtime.ParamLocationQuery, *params.DestroySnapshots); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217PoliciesRequest calls the generic PostApi217Policies builder with application/json body
func NewPostApi217PoliciesRequest(server string, params *PostApi217PoliciesParams, body PostApi217PoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217PoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217PoliciesRequestWithBody generates requests for PostApi217Policies with any type of body
func NewPostApi217PoliciesRequestWithBody(server string, params *PostApi217PoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PoliciesAllRequest generates requests for GetApi217PoliciesAll
func NewGetApi217PoliciesAllRequest(server string, params *GetApi217PoliciesAllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies-all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PoliciesAllMembersRequest generates requests for GetApi217PoliciesAllMembers
func NewGetApi217PoliciesAllMembersRequest(server string, params *GetApi217PoliciesAllMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies-all/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_types", runtime.ParamLocationQuery, *params.MemberTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_ids", runtime.ParamLocationQuery, *params.RemoteFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_names", runtime.ParamLocationQuery, *params.RemoteFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217PoliciesFileSystemReplicaLinksRequest generates requests for DeleteApi217PoliciesFileSystemReplicaLinks
func NewDeleteApi217PoliciesFileSystemReplicaLinksRequest(server string, params *DeleteApi217PoliciesFileSystemReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-system-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PoliciesFileSystemReplicaLinksRequest generates requests for GetApi217PoliciesFileSystemReplicaLinks
func NewGetApi217PoliciesFileSystemReplicaLinksRequest(server string, params *GetApi217PoliciesFileSystemReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-system-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_ids", runtime.ParamLocationQuery, *params.RemoteFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_names", runtime.ParamLocationQuery, *params.RemoteFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217PoliciesFileSystemReplicaLinksRequest generates requests for PostApi217PoliciesFileSystemReplicaLinks
func NewPostApi217PoliciesFileSystemReplicaLinksRequest(server string, params *PostApi217PoliciesFileSystemReplicaLinksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-system-replica-links")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217PoliciesFileSystemSnapshotsRequest generates requests for DeleteApi217PoliciesFileSystemSnapshots
func NewDeleteApi217PoliciesFileSystemSnapshotsRequest(server string, params *DeleteApi217PoliciesFileSystemSnapshotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-system-snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PoliciesFileSystemSnapshotsRequest generates requests for GetApi217PoliciesFileSystemSnapshots
func NewGetApi217PoliciesFileSystemSnapshotsRequest(server string, params *GetApi217PoliciesFileSystemSnapshotsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-system-snapshots")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217PoliciesFileSystemsRequest generates requests for DeleteApi217PoliciesFileSystems
func NewDeleteApi217PoliciesFileSystemsRequest(server string, params *DeleteApi217PoliciesFileSystemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PoliciesFileSystemsRequest generates requests for GetApi217PoliciesFileSystems
func NewGetApi217PoliciesFileSystemsRequest(server string, params *GetApi217PoliciesFileSystemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217PoliciesFileSystemsRequest generates requests for PostApi217PoliciesFileSystems
func NewPostApi217PoliciesFileSystemsRequest(server string, params *PostApi217PoliciesFileSystemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PoliciesMembersRequest generates requests for GetApi217PoliciesMembers
func NewGetApi217PoliciesMembersRequest(server string, params *GetApi217PoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_ids", runtime.ParamLocationQuery, *params.LocalFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LocalFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "local_file_system_names", runtime.ParamLocationQuery, *params.LocalFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_types", runtime.ParamLocationQuery, *params.MemberTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_ids", runtime.ParamLocationQuery, *params.RemoteFileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteFileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_file_system_names", runtime.ParamLocationQuery, *params.RemoteFileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_ids", runtime.ParamLocationQuery, *params.RemoteIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoteNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "remote_names", runtime.ParamLocationQuery, *params.RemoteNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217PublicKeysRequest generates requests for DeleteApi217PublicKeys
func NewDeleteApi217PublicKeysRequest(server string, params *DeleteApi217PublicKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/public-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PublicKeysRequest generates requests for GetApi217PublicKeys
func NewGetApi217PublicKeysRequest(server string, params *GetApi217PublicKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/public-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217PublicKeysRequest calls the generic PostApi217PublicKeys builder with application/json body
func NewPostApi217PublicKeysRequest(server string, params *PostApi217PublicKeysParams, body PostApi217PublicKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217PublicKeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217PublicKeysRequestWithBody generates requests for PostApi217PublicKeys with any type of body
func NewPostApi217PublicKeysRequestWithBody(server string, params *PostApi217PublicKeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/public-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217PublicKeysUsesRequest generates requests for GetApi217PublicKeysUses
func NewGetApi217PublicKeysUsesRequest(server string, params *GetApi217PublicKeysUsesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/public-keys/uses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217QosPoliciesRequest generates requests for DeleteApi217QosPolicies
func NewDeleteApi217QosPoliciesRequest(server string, params *DeleteApi217QosPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/qos-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217QosPoliciesRequest generates requests for GetApi217QosPolicies
func NewGetApi217QosPoliciesRequest(server string, params *GetApi217QosPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/qos-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217QosPoliciesRequest calls the generic PatchApi217QosPolicies builder with application/json body
func NewPatchApi217QosPoliciesRequest(server string, params *PatchApi217QosPoliciesParams, body PatchApi217QosPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217QosPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217QosPoliciesRequestWithBody generates requests for PatchApi217QosPolicies with any type of body
func NewPatchApi217QosPoliciesRequestWithBody(server string, params *PatchApi217QosPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/qos-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217QosPoliciesRequest calls the generic PostApi217QosPolicies builder with application/json body
func NewPostApi217QosPoliciesRequest(server string, params *PostApi217QosPoliciesParams, body PostApi217QosPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217QosPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217QosPoliciesRequestWithBody generates requests for PostApi217QosPolicies with any type of body
func NewPostApi217QosPoliciesRequestWithBody(server string, params *PostApi217QosPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/qos-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217QosPoliciesFileSystemsRequest generates requests for GetApi217QosPoliciesFileSystems
func NewGetApi217QosPoliciesFileSystemsRequest(server string, params *GetApi217QosPoliciesFileSystemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/qos-policies/file-systems")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217QosPoliciesMembersRequest generates requests for GetApi217QosPoliciesMembers
func NewGetApi217QosPoliciesMembersRequest(server string, params *GetApi217QosPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/qos-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217QuotasGroupsRequest generates requests for DeleteApi217QuotasGroups
func NewDeleteApi217QuotasGroupsRequest(server string, params *DeleteApi217QuotasGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "gids", runtime.ParamLocationQuery, *params.Gids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_names", runtime.ParamLocationQuery, *params.GroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217QuotasGroupsRequest generates requests for GetApi217QuotasGroups
func NewGetApi217QuotasGroupsRequest(server string, params *GetApi217QuotasGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "gids", runtime.ParamLocationQuery, *params.Gids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_names", runtime.ParamLocationQuery, *params.GroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217QuotasGroupsRequest calls the generic PatchApi217QuotasGroups builder with application/json body
func NewPatchApi217QuotasGroupsRequest(server string, params *PatchApi217QuotasGroupsParams, body PatchApi217QuotasGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217QuotasGroupsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217QuotasGroupsRequestWithBody generates requests for PatchApi217QuotasGroups with any type of body
func NewPatchApi217QuotasGroupsRequestWithBody(server string, params *PatchApi217QuotasGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "gids", runtime.ParamLocationQuery, *params.Gids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_names", runtime.ParamLocationQuery, *params.GroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217QuotasGroupsRequest calls the generic PostApi217QuotasGroups builder with application/json body
func NewPostApi217QuotasGroupsRequest(server string, params *PostApi217QuotasGroupsParams, body PostApi217QuotasGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217QuotasGroupsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217QuotasGroupsRequestWithBody generates requests for PostApi217QuotasGroups with any type of body
func NewPostApi217QuotasGroupsRequestWithBody(server string, params *PostApi217QuotasGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "gids", runtime.ParamLocationQuery, *params.Gids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_names", runtime.ParamLocationQuery, *params.GroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217QuotasSettingsRequest generates requests for GetApi217QuotasSettings
func NewGetApi217QuotasSettingsRequest(server string, params *GetApi217QuotasSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217QuotasSettingsRequest calls the generic PatchApi217QuotasSettings builder with application/json body
func NewPatchApi217QuotasSettingsRequest(server string, params *PatchApi217QuotasSettingsParams, body PatchApi217QuotasSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217QuotasSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217QuotasSettingsRequestWithBody generates requests for PatchApi217QuotasSettings with any type of body
func NewPatchApi217QuotasSettingsRequestWithBody(server string, params *PatchApi217QuotasSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217QuotasUsersRequest generates requests for DeleteApi217QuotasUsers
func NewDeleteApi217QuotasUsersRequest(server string, params *DeleteApi217QuotasUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "uids", runtime.ParamLocationQuery, *params.Uids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217QuotasUsersRequest generates requests for GetApi217QuotasUsers
func NewGetApi217QuotasUsersRequest(server string, params *GetApi217QuotasUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "uids", runtime.ParamLocationQuery, *params.Uids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217QuotasUsersRequest calls the generic PatchApi217QuotasUsers builder with application/json body
func NewPatchApi217QuotasUsersRequest(server string, params *PatchApi217QuotasUsersParams, body PatchApi217QuotasUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217QuotasUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217QuotasUsersRequestWithBody generates requests for PatchApi217QuotasUsers with any type of body
func NewPatchApi217QuotasUsersRequestWithBody(server string, params *PatchApi217QuotasUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "uids", runtime.ParamLocationQuery, *params.Uids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217QuotasUsersRequest calls the generic PostApi217QuotasUsers builder with application/json body
func NewPostApi217QuotasUsersRequest(server string, params *PostApi217QuotasUsersParams, body PostApi217QuotasUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217QuotasUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217QuotasUsersRequestWithBody generates requests for PostApi217QuotasUsers with any type of body
func NewPostApi217QuotasUsersRequestWithBody(server string, params *PostApi217QuotasUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/quotas/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "uids", runtime.ParamLocationQuery, *params.Uids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217RapidDataLockingRequest generates requests for GetApi217RapidDataLocking
func NewGetApi217RapidDataLockingRequest(server string, params *GetApi217RapidDataLockingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/rapid-data-locking")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217RapidDataLockingRequest calls the generic PatchApi217RapidDataLocking builder with application/json body
func NewPatchApi217RapidDataLockingRequest(server string, params *PatchApi217RapidDataLockingParams, body PatchApi217RapidDataLockingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217RapidDataLockingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217RapidDataLockingRequestWithBody generates requests for PatchApi217RapidDataLocking with any type of body
func NewPatchApi217RapidDataLockingRequestWithBody(server string, params *PatchApi217RapidDataLockingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/rapid-data-locking")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217RapidDataLockingRotateRequest generates requests for PostApi217RapidDataLockingRotate
func NewPostApi217RapidDataLockingRotateRequest(server string, params *PostApi217RapidDataLockingRotateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/rapid-data-locking/rotate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217RapidDataLockingTestRequest generates requests for GetApi217RapidDataLockingTest
func NewGetApi217RapidDataLockingTestRequest(server string, params *GetApi217RapidDataLockingTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/rapid-data-locking/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217RemoteArraysRequest generates requests for GetApi217RemoteArrays
func NewGetApi217RemoteArraysRequest(server string, params *GetApi217RemoteArraysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/remote-arrays")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CurrentFleetOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "current_fleet_only", runtime.ParamLocationQuery, *params.CurrentFleetOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217RolesRequest generates requests for GetApi217Roles
func NewGetApi217RolesRequest(server string, params *GetApi217RolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217ServersRequest generates requests for DeleteApi217Servers
func NewDeleteApi217ServersRequest(server string, params *DeleteApi217ServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cascade_delete", runtime.ParamLocationQuery, params.CascadeDelete); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217ServersRequest generates requests for GetApi217Servers
func NewGetApi217ServersRequest(server string, params *GetApi217ServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217ServersRequest calls the generic PatchApi217Servers builder with application/json body
func NewPatchApi217ServersRequest(server string, params *PatchApi217ServersParams, body PatchApi217ServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217ServersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217ServersRequestWithBody generates requests for PatchApi217Servers with any type of body
func NewPatchApi217ServersRequestWithBody(server string, params *PatchApi217ServersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217ServersRequest calls the generic PostApi217Servers builder with application/json body
func NewPostApi217ServersRequest(server string, params *PostApi217ServersParams, body PostApi217ServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217ServersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217ServersRequestWithBody generates requests for PostApi217Servers with any type of body
func NewPostApi217ServersRequestWithBody(server string, params *PostApi217ServersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "create_ds", runtime.ParamLocationQuery, params.CreateDs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SessionsRequest generates requests for GetApi217Sessions
func NewGetApi217SessionsRequest(server string, params *GetApi217SessionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SmbClientPoliciesRequest generates requests for DeleteApi217SmbClientPolicies
func NewDeleteApi217SmbClientPoliciesRequest(server string, params *DeleteApi217SmbClientPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SmbClientPoliciesRequest generates requests for GetApi217SmbClientPolicies
func NewGetApi217SmbClientPoliciesRequest(server string, params *GetApi217SmbClientPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SmbClientPoliciesRequest calls the generic PatchApi217SmbClientPolicies builder with application/json body
func NewPatchApi217SmbClientPoliciesRequest(server string, params *PatchApi217SmbClientPoliciesParams, body PatchApi217SmbClientPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SmbClientPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SmbClientPoliciesRequestWithBody generates requests for PatchApi217SmbClientPolicies with any type of body
func NewPatchApi217SmbClientPoliciesRequestWithBody(server string, params *PatchApi217SmbClientPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SmbClientPoliciesRequest calls the generic PostApi217SmbClientPolicies builder with application/json body
func NewPostApi217SmbClientPoliciesRequest(server string, params *PostApi217SmbClientPoliciesParams, body PostApi217SmbClientPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SmbClientPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SmbClientPoliciesRequestWithBody generates requests for PostApi217SmbClientPolicies with any type of body
func NewPostApi217SmbClientPoliciesRequestWithBody(server string, params *PostApi217SmbClientPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SmbClientPoliciesRulesRequest generates requests for DeleteApi217SmbClientPoliciesRules
func NewDeleteApi217SmbClientPoliciesRulesRequest(server string, params *DeleteApi217SmbClientPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SmbClientPoliciesRulesRequest generates requests for GetApi217SmbClientPoliciesRules
func NewGetApi217SmbClientPoliciesRulesRequest(server string, params *GetApi217SmbClientPoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SmbClientPoliciesRulesRequest calls the generic PatchApi217SmbClientPoliciesRules builder with application/json body
func NewPatchApi217SmbClientPoliciesRulesRequest(server string, params *PatchApi217SmbClientPoliciesRulesParams, body PatchApi217SmbClientPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SmbClientPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SmbClientPoliciesRulesRequestWithBody generates requests for PatchApi217SmbClientPoliciesRules with any type of body
func NewPatchApi217SmbClientPoliciesRulesRequestWithBody(server string, params *PatchApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeforeRuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_id", runtime.ParamLocationQuery, *params.BeforeRuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeRuleName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_name", runtime.ParamLocationQuery, *params.BeforeRuleName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SmbClientPoliciesRulesRequest calls the generic PostApi217SmbClientPoliciesRules builder with application/json body
func NewPostApi217SmbClientPoliciesRulesRequest(server string, params *PostApi217SmbClientPoliciesRulesParams, body PostApi217SmbClientPoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SmbClientPoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SmbClientPoliciesRulesRequestWithBody generates requests for PostApi217SmbClientPoliciesRules with any type of body
func NewPostApi217SmbClientPoliciesRulesRequestWithBody(server string, params *PostApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-client-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BeforeRuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_id", runtime.ParamLocationQuery, *params.BeforeRuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BeforeRuleName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before_rule_name", runtime.ParamLocationQuery, *params.BeforeRuleName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Versions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "versions", runtime.ParamLocationQuery, *params.Versions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SmbSharePoliciesRequest generates requests for DeleteApi217SmbSharePolicies
func NewDeleteApi217SmbSharePoliciesRequest(server string, params *DeleteApi217SmbSharePoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SmbSharePoliciesRequest generates requests for GetApi217SmbSharePolicies
func NewGetApi217SmbSharePoliciesRequest(server string, params *GetApi217SmbSharePoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SmbSharePoliciesRequest calls the generic PatchApi217SmbSharePolicies builder with application/json body
func NewPatchApi217SmbSharePoliciesRequest(server string, params *PatchApi217SmbSharePoliciesParams, body PatchApi217SmbSharePoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SmbSharePoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SmbSharePoliciesRequestWithBody generates requests for PatchApi217SmbSharePolicies with any type of body
func NewPatchApi217SmbSharePoliciesRequestWithBody(server string, params *PatchApi217SmbSharePoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SmbSharePoliciesRequest calls the generic PostApi217SmbSharePolicies builder with application/json body
func NewPostApi217SmbSharePoliciesRequest(server string, params *PostApi217SmbSharePoliciesParams, body PostApi217SmbSharePoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SmbSharePoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SmbSharePoliciesRequestWithBody generates requests for PostApi217SmbSharePolicies with any type of body
func NewPostApi217SmbSharePoliciesRequestWithBody(server string, params *PostApi217SmbSharePoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SmbSharePoliciesRulesRequest generates requests for DeleteApi217SmbSharePoliciesRules
func NewDeleteApi217SmbSharePoliciesRulesRequest(server string, params *DeleteApi217SmbSharePoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SmbSharePoliciesRulesRequest generates requests for GetApi217SmbSharePoliciesRules
func NewGetApi217SmbSharePoliciesRulesRequest(server string, params *GetApi217SmbSharePoliciesRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SmbSharePoliciesRulesRequest calls the generic PatchApi217SmbSharePoliciesRules builder with application/json body
func NewPatchApi217SmbSharePoliciesRulesRequest(server string, params *PatchApi217SmbSharePoliciesRulesParams, body PatchApi217SmbSharePoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SmbSharePoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SmbSharePoliciesRulesRequestWithBody generates requests for PatchApi217SmbSharePoliciesRules with any type of body
func NewPatchApi217SmbSharePoliciesRulesRequestWithBody(server string, params *PatchApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SmbSharePoliciesRulesRequest calls the generic PostApi217SmbSharePoliciesRules builder with application/json body
func NewPostApi217SmbSharePoliciesRulesRequest(server string, params *PostApi217SmbSharePoliciesRulesParams, body PostApi217SmbSharePoliciesRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SmbSharePoliciesRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SmbSharePoliciesRulesRequestWithBody generates requests for PostApi217SmbSharePoliciesRules with any type of body
func NewPostApi217SmbSharePoliciesRulesRequestWithBody(server string, params *PostApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smb-share-policies/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SmtpServersRequest generates requests for GetApi217SmtpServers
func NewGetApi217SmtpServersRequest(server string, params *GetApi217SmtpServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smtp-servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SmtpServersRequest calls the generic PatchApi217SmtpServers builder with application/json body
func NewPatchApi217SmtpServersRequest(server string, params *PatchApi217SmtpServersParams, body PatchApi217SmtpServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SmtpServersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SmtpServersRequestWithBody generates requests for PatchApi217SmtpServers with any type of body
func NewPatchApi217SmtpServersRequestWithBody(server string, params *PatchApi217SmtpServersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/smtp-servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SnmpAgentsRequest generates requests for GetApi217SnmpAgents
func NewGetApi217SnmpAgentsRequest(server string, params *GetApi217SnmpAgentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SnmpAgentsRequest calls the generic PatchApi217SnmpAgents builder with application/json body
func NewPatchApi217SnmpAgentsRequest(server string, params *PatchApi217SnmpAgentsParams, body PatchApi217SnmpAgentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SnmpAgentsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SnmpAgentsRequestWithBody generates requests for PatchApi217SnmpAgents with any type of body
func NewPatchApi217SnmpAgentsRequestWithBody(server string, params *PatchApi217SnmpAgentsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-agents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SnmpAgentsMibRequest generates requests for GetApi217SnmpAgentsMib
func NewGetApi217SnmpAgentsMibRequest(server string, params *GetApi217SnmpAgentsMibParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-agents/mib")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SnmpManagersRequest generates requests for DeleteApi217SnmpManagers
func NewDeleteApi217SnmpManagersRequest(server string, params *DeleteApi217SnmpManagersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-managers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SnmpManagersRequest generates requests for GetApi217SnmpManagers
func NewGetApi217SnmpManagersRequest(server string, params *GetApi217SnmpManagersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-managers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SnmpManagersRequest calls the generic PatchApi217SnmpManagers builder with application/json body
func NewPatchApi217SnmpManagersRequest(server string, params *PatchApi217SnmpManagersParams, body PatchApi217SnmpManagersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SnmpManagersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SnmpManagersRequestWithBody generates requests for PatchApi217SnmpManagers with any type of body
func NewPatchApi217SnmpManagersRequestWithBody(server string, params *PatchApi217SnmpManagersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-managers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SnmpManagersRequest calls the generic PostApi217SnmpManagers builder with application/json body
func NewPostApi217SnmpManagersRequest(server string, params *PostApi217SnmpManagersParams, body PostApi217SnmpManagersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SnmpManagersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SnmpManagersRequestWithBody generates requests for PostApi217SnmpManagers with any type of body
func NewPostApi217SnmpManagersRequestWithBody(server string, params *PostApi217SnmpManagersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-managers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SnmpManagersTestRequest generates requests for GetApi217SnmpManagersTest
func NewGetApi217SnmpManagersTestRequest(server string, params *GetApi217SnmpManagersTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/snmp-managers/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SoftwareCheckRequest generates requests for GetApi217SoftwareCheck
func NewGetApi217SoftwareCheckRequest(server string, params *GetApi217SoftwareCheckParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/software-check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftwareNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "software_names", runtime.ParamLocationQuery, *params.SoftwareNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftwareVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "software_versions", runtime.ParamLocationQuery, *params.SoftwareVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalItemCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_item_count", runtime.ParamLocationQuery, *params.TotalItemCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostApi217SoftwareCheckRequest generates requests for PostApi217SoftwareCheck
func NewPostApi217SoftwareCheckRequest(server string, params *PostApi217SoftwareCheckParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/software-check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SoftwareNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "software_names", runtime.ParamLocationQuery, *params.SoftwareNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SoftwareVersions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "software_versions", runtime.ParamLocationQuery, *params.SoftwareVersions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SshCertificateAuthorityPoliciesRequest generates requests for DeleteApi217SshCertificateAuthorityPolicies
func NewDeleteApi217SshCertificateAuthorityPoliciesRequest(server string, params *DeleteApi217SshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SshCertificateAuthorityPoliciesRequest generates requests for GetApi217SshCertificateAuthorityPolicies
func NewGetApi217SshCertificateAuthorityPoliciesRequest(server string, params *GetApi217SshCertificateAuthorityPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SshCertificateAuthorityPoliciesRequest calls the generic PatchApi217SshCertificateAuthorityPolicies builder with application/json body
func NewPatchApi217SshCertificateAuthorityPoliciesRequest(server string, params *PatchApi217SshCertificateAuthorityPoliciesParams, body PatchApi217SshCertificateAuthorityPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SshCertificateAuthorityPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SshCertificateAuthorityPoliciesRequestWithBody generates requests for PatchApi217SshCertificateAuthorityPolicies with any type of body
func NewPatchApi217SshCertificateAuthorityPoliciesRequestWithBody(server string, params *PatchApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SshCertificateAuthorityPoliciesRequest calls the generic PostApi217SshCertificateAuthorityPolicies builder with application/json body
func NewPostApi217SshCertificateAuthorityPoliciesRequest(server string, params *PostApi217SshCertificateAuthorityPoliciesParams, body PostApi217SshCertificateAuthorityPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SshCertificateAuthorityPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SshCertificateAuthorityPoliciesRequestWithBody generates requests for PostApi217SshCertificateAuthorityPolicies with any type of body
func NewPostApi217SshCertificateAuthorityPoliciesRequestWithBody(server string, params *PostApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SshCertificateAuthorityPoliciesAdminsRequest generates requests for DeleteApi217SshCertificateAuthorityPoliciesAdmins
func NewDeleteApi217SshCertificateAuthorityPoliciesAdminsRequest(server string, params *DeleteApi217SshCertificateAuthorityPoliciesAdminsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies/admins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SshCertificateAuthorityPoliciesAdminsRequest generates requests for GetApi217SshCertificateAuthorityPoliciesAdmins
func NewGetApi217SshCertificateAuthorityPoliciesAdminsRequest(server string, params *GetApi217SshCertificateAuthorityPoliciesAdminsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies/admins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SshCertificateAuthorityPoliciesAdminsRequest generates requests for PostApi217SshCertificateAuthorityPoliciesAdmins
func NewPostApi217SshCertificateAuthorityPoliciesAdminsRequest(server string, params *PostApi217SshCertificateAuthorityPoliciesAdminsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies/admins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SshCertificateAuthorityPoliciesArraysRequest generates requests for DeleteApi217SshCertificateAuthorityPoliciesArrays
func NewDeleteApi217SshCertificateAuthorityPoliciesArraysRequest(server string, params *DeleteApi217SshCertificateAuthorityPoliciesArraysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies/arrays")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SshCertificateAuthorityPoliciesArraysRequest generates requests for GetApi217SshCertificateAuthorityPoliciesArrays
func NewGetApi217SshCertificateAuthorityPoliciesArraysRequest(server string, params *GetApi217SshCertificateAuthorityPoliciesArraysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies/arrays")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SshCertificateAuthorityPoliciesArraysRequest generates requests for PostApi217SshCertificateAuthorityPoliciesArrays
func NewPostApi217SshCertificateAuthorityPoliciesArraysRequest(server string, params *PostApi217SshCertificateAuthorityPoliciesArraysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies/arrays")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SshCertificateAuthorityPoliciesMembersRequest generates requests for GetApi217SshCertificateAuthorityPoliciesMembers
func NewGetApi217SshCertificateAuthorityPoliciesMembersRequest(server string, params *GetApi217SshCertificateAuthorityPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/ssh-certificate-authority-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SsoOidcIdpsRequest generates requests for DeleteApi217SsoOidcIdps
func NewDeleteApi217SsoOidcIdpsRequest(server string, params *DeleteApi217SsoOidcIdpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/oidc/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SsoOidcIdpsRequest generates requests for GetApi217SsoOidcIdps
func NewGetApi217SsoOidcIdpsRequest(server string, params *GetApi217SsoOidcIdpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/oidc/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SsoOidcIdpsRequest calls the generic PatchApi217SsoOidcIdps builder with application/json body
func NewPatchApi217SsoOidcIdpsRequest(server string, params *PatchApi217SsoOidcIdpsParams, body PatchApi217SsoOidcIdpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SsoOidcIdpsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SsoOidcIdpsRequestWithBody generates requests for PatchApi217SsoOidcIdps with any type of body
func NewPatchApi217SsoOidcIdpsRequestWithBody(server string, params *PatchApi217SsoOidcIdpsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/oidc/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SsoOidcIdpsRequest calls the generic PostApi217SsoOidcIdps builder with application/json body
func NewPostApi217SsoOidcIdpsRequest(server string, params *PostApi217SsoOidcIdpsParams, body PostApi217SsoOidcIdpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SsoOidcIdpsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SsoOidcIdpsRequestWithBody generates requests for PostApi217SsoOidcIdps with any type of body
func NewPostApi217SsoOidcIdpsRequestWithBody(server string, params *PostApi217SsoOidcIdpsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/oidc/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SsoSaml2IdpsRequest generates requests for DeleteApi217SsoSaml2Idps
func NewDeleteApi217SsoSaml2IdpsRequest(server string, params *DeleteApi217SsoSaml2IdpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/saml2/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SsoSaml2IdpsRequest generates requests for GetApi217SsoSaml2Idps
func NewGetApi217SsoSaml2IdpsRequest(server string, params *GetApi217SsoSaml2IdpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/saml2/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SsoSaml2IdpsRequest calls the generic PatchApi217SsoSaml2Idps builder with application/json body
func NewPatchApi217SsoSaml2IdpsRequest(server string, params *PatchApi217SsoSaml2IdpsParams, body PatchApi217SsoSaml2IdpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SsoSaml2IdpsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SsoSaml2IdpsRequestWithBody generates requests for PatchApi217SsoSaml2Idps with any type of body
func NewPatchApi217SsoSaml2IdpsRequestWithBody(server string, params *PatchApi217SsoSaml2IdpsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/saml2/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SsoSaml2IdpsRequest calls the generic PostApi217SsoSaml2Idps builder with application/json body
func NewPostApi217SsoSaml2IdpsRequest(server string, params *PostApi217SsoSaml2IdpsParams, body PostApi217SsoSaml2IdpsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SsoSaml2IdpsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SsoSaml2IdpsRequestWithBody generates requests for PostApi217SsoSaml2Idps with any type of body
func NewPostApi217SsoSaml2IdpsRequestWithBody(server string, params *PostApi217SsoSaml2IdpsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/saml2/idps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SsoSaml2IdpsTestRequest generates requests for GetApi217SsoSaml2IdpsTest
func NewGetApi217SsoSaml2IdpsTestRequest(server string, params *GetApi217SsoSaml2IdpsTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/saml2/idps/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SsoSaml2IdpsTestRequest calls the generic PatchApi217SsoSaml2IdpsTest builder with application/json body
func NewPatchApi217SsoSaml2IdpsTestRequest(server string, params *PatchApi217SsoSaml2IdpsTestParams, body PatchApi217SsoSaml2IdpsTestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SsoSaml2IdpsTestRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SsoSaml2IdpsTestRequestWithBody generates requests for PatchApi217SsoSaml2IdpsTest with any type of body
func NewPatchApi217SsoSaml2IdpsTestRequestWithBody(server string, params *PatchApi217SsoSaml2IdpsTestParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/sso/saml2/idps/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SubnetsRequest generates requests for DeleteApi217Subnets
func NewDeleteApi217SubnetsRequest(server string, params *DeleteApi217SubnetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/subnets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SubnetsRequest generates requests for GetApi217Subnets
func NewGetApi217SubnetsRequest(server string, params *GetApi217SubnetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/subnets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SubnetsRequest calls the generic PatchApi217Subnets builder with application/json body
func NewPatchApi217SubnetsRequest(server string, params *PatchApi217SubnetsParams, body PatchApi217SubnetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SubnetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SubnetsRequestWithBody generates requests for PatchApi217Subnets with any type of body
func NewPatchApi217SubnetsRequestWithBody(server string, params *PatchApi217SubnetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/subnets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SubnetsRequest calls the generic PostApi217Subnets builder with application/json body
func NewPostApi217SubnetsRequest(server string, params *PostApi217SubnetsParams, body PostApi217SubnetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SubnetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SubnetsRequestWithBody generates requests for PostApi217Subnets with any type of body
func NewPostApi217SubnetsRequestWithBody(server string, params *PostApi217SubnetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/subnets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SupportRequest generates requests for GetApi217Support
func NewGetApi217SupportRequest(server string, params *GetApi217SupportParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SupportRequest calls the generic PatchApi217Support builder with application/json body
func NewPatchApi217SupportRequest(server string, params *PatchApi217SupportParams, body PatchApi217SupportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SupportRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SupportRequestWithBody generates requests for PatchApi217Support with any type of body
func NewPatchApi217SupportRequestWithBody(server string, params *PatchApi217SupportParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SupportDiagnosticsRequest generates requests for GetApi217SupportDiagnostics
func NewGetApi217SupportDiagnosticsRequest(server string, params *GetApi217SupportDiagnosticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support-diagnostics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SupportDiagnosticsRequest generates requests for PostApi217SupportDiagnostics
func NewPostApi217SupportDiagnosticsRequest(server string, params *PostApi217SupportDiagnosticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support-diagnostics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AnalysisPeriodEndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "analysis_period_end_time", runtime.ParamLocationQuery, *params.AnalysisPeriodEndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AnalysisPeriodStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "analysis_period_start_time", runtime.ParamLocationQuery, *params.AnalysisPeriodStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SupportDiagnosticsDetailsRequest generates requests for GetApi217SupportDiagnosticsDetails
func NewGetApi217SupportDiagnosticsDetailsRequest(server string, params *GetApi217SupportDiagnosticsDetailsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support-diagnostics/details")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SupportTestRequest generates requests for GetApi217SupportTest
func NewGetApi217SupportTestRequest(server string, params *GetApi217SupportTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TestType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "test_type", runtime.ParamLocationQuery, *params.TestType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SupportVerificationKeysRequest generates requests for GetApi217SupportVerificationKeys
func NewGetApi217SupportVerificationKeysRequest(server string, params *GetApi217SupportVerificationKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support/verification-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SupportVerificationKeysRequest calls the generic PatchApi217SupportVerificationKeys builder with application/json body
func NewPatchApi217SupportVerificationKeysRequest(server string, params *PatchApi217SupportVerificationKeysParams, body PatchApi217SupportVerificationKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SupportVerificationKeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SupportVerificationKeysRequestWithBody generates requests for PatchApi217SupportVerificationKeys with any type of body
func NewPatchApi217SupportVerificationKeysRequestWithBody(server string, params *PatchApi217SupportVerificationKeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/support/verification-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217SyslogServersRequest generates requests for DeleteApi217SyslogServers
func NewDeleteApi217SyslogServersRequest(server string, params *DeleteApi217SyslogServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/syslog-servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SyslogServersRequest generates requests for GetApi217SyslogServers
func NewGetApi217SyslogServersRequest(server string, params *GetApi217SyslogServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/syslog-servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SyslogServersRequest calls the generic PatchApi217SyslogServers builder with application/json body
func NewPatchApi217SyslogServersRequest(server string, params *PatchApi217SyslogServersParams, body PatchApi217SyslogServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SyslogServersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SyslogServersRequestWithBody generates requests for PatchApi217SyslogServers with any type of body
func NewPatchApi217SyslogServersRequestWithBody(server string, params *PatchApi217SyslogServersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/syslog-servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217SyslogServersRequest calls the generic PostApi217SyslogServers builder with application/json body
func NewPostApi217SyslogServersRequest(server string, params *PostApi217SyslogServersParams, body PostApi217SyslogServersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217SyslogServersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217SyslogServersRequestWithBody generates requests for PostApi217SyslogServers with any type of body
func NewPostApi217SyslogServersRequestWithBody(server string, params *PostApi217SyslogServersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/syslog-servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SyslogServersSettingsRequest generates requests for GetApi217SyslogServersSettings
func NewGetApi217SyslogServersSettingsRequest(server string, params *GetApi217SyslogServersSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/syslog-servers/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217SyslogServersSettingsRequest calls the generic PatchApi217SyslogServersSettings builder with application/json body
func NewPatchApi217SyslogServersSettingsRequest(server string, params *PatchApi217SyslogServersSettingsParams, body PatchApi217SyslogServersSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217SyslogServersSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217SyslogServersSettingsRequestWithBody generates requests for PatchApi217SyslogServersSettings with any type of body
func NewPatchApi217SyslogServersSettingsRequestWithBody(server string, params *PatchApi217SyslogServersSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/syslog-servers/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217SyslogServersTestRequest generates requests for GetApi217SyslogServersTest
func NewGetApi217SyslogServersTestRequest(server string, params *GetApi217SyslogServersTestParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/syslog-servers/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217TargetsRequest generates requests for DeleteApi217Targets
func NewDeleteApi217TargetsRequest(server string, params *DeleteApi217TargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217TargetsRequest generates requests for GetApi217Targets
func NewGetApi217TargetsRequest(server string, params *GetApi217TargetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217TargetsRequest calls the generic PatchApi217Targets builder with application/json body
func NewPatchApi217TargetsRequest(server string, params *PatchApi217TargetsParams, body PatchApi217TargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217TargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217TargetsRequestWithBody generates requests for PatchApi217Targets with any type of body
func NewPatchApi217TargetsRequestWithBody(server string, params *PatchApi217TargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217TargetsRequest calls the generic PostApi217Targets builder with application/json body
func NewPostApi217TargetsRequest(server string, params *PostApi217TargetsParams, body PostApi217TargetsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217TargetsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217TargetsRequestWithBody generates requests for PostApi217Targets with any type of body
func NewPostApi217TargetsRequestWithBody(server string, params *PostApi217TargetsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217TargetsPerformanceReplicationRequest generates requests for GetApi217TargetsPerformanceReplication
func NewGetApi217TargetsPerformanceReplicationRequest(server string, params *GetApi217TargetsPerformanceReplicationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/targets/performance/replication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolution != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TotalOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "total_only", runtime.ParamLocationQuery, *params.TotalOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217TlsPoliciesRequest generates requests for DeleteApi217TlsPolicies
func NewDeleteApi217TlsPoliciesRequest(server string, params *DeleteApi217TlsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217TlsPoliciesRequest generates requests for GetApi217TlsPolicies
func NewGetApi217TlsPoliciesRequest(server string, params *GetApi217TlsPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Effective != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PurityDefined != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purity_defined", runtime.ParamLocationQuery, *params.PurityDefined); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217TlsPoliciesRequest calls the generic PatchApi217TlsPolicies builder with application/json body
func NewPatchApi217TlsPoliciesRequest(server string, params *PatchApi217TlsPoliciesParams, body PatchApi217TlsPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217TlsPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217TlsPoliciesRequestWithBody generates requests for PatchApi217TlsPolicies with any type of body
func NewPatchApi217TlsPoliciesRequestWithBody(server string, params *PatchApi217TlsPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217TlsPoliciesRequest calls the generic PostApi217TlsPolicies builder with application/json body
func NewPostApi217TlsPoliciesRequest(server string, params *PostApi217TlsPoliciesParams, body PostApi217TlsPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217TlsPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217TlsPoliciesRequestWithBody generates requests for PostApi217TlsPolicies with any type of body
func NewPostApi217TlsPoliciesRequestWithBody(server string, params *PostApi217TlsPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217TlsPoliciesMembersRequest generates requests for GetApi217TlsPoliciesMembers
func NewGetApi217TlsPoliciesMembersRequest(server string, params *GetApi217TlsPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217TlsPoliciesNetworkInterfacesRequest generates requests for DeleteApi217TlsPoliciesNetworkInterfaces
func NewDeleteApi217TlsPoliciesNetworkInterfacesRequest(server string, params *DeleteApi217TlsPoliciesNetworkInterfacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies/network-interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217TlsPoliciesNetworkInterfacesRequest generates requests for GetApi217TlsPoliciesNetworkInterfaces
func NewGetApi217TlsPoliciesNetworkInterfacesRequest(server string, params *GetApi217TlsPoliciesNetworkInterfacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies/network-interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217TlsPoliciesNetworkInterfacesRequest generates requests for PostApi217TlsPoliciesNetworkInterfaces
func NewPostApi217TlsPoliciesNetworkInterfacesRequest(server string, params *PostApi217TlsPoliciesNetworkInterfacesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/tls-policies/network-interfaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217UsageGroupsRequest generates requests for GetApi217UsageGroups
func NewGetApi217UsageGroupsRequest(server string, params *GetApi217UsageGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/usage/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "gids", runtime.ParamLocationQuery, *params.Gids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GroupNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "group_names", runtime.ParamLocationQuery, *params.GroupNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217UsageUsersRequest generates requests for GetApi217UsageUsers
func NewGetApi217UsageUsersRequest(server string, params *GetApi217UsageUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/usage/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_ids", runtime.ParamLocationQuery, *params.FileSystemIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FileSystemNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "file_system_names", runtime.ParamLocationQuery, *params.FileSystemNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "uids", runtime.ParamLocationQuery, *params.Uids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user_names", runtime.ParamLocationQuery, *params.UserNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApi217WormDataPoliciesRequest generates requests for DeleteApi217WormDataPolicies
func NewDeleteApi217WormDataPoliciesRequest(server string, params *DeleteApi217WormDataPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/worm-data-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217WormDataPoliciesRequest generates requests for GetApi217WormDataPolicies
func NewGetApi217WormDataPoliciesRequest(server string, params *GetApi217WormDataPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/worm-data-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPatchApi217WormDataPoliciesRequest calls the generic PatchApi217WormDataPolicies builder with application/json body
func NewPatchApi217WormDataPoliciesRequest(server string, params *PatchApi217WormDataPoliciesParams, body PatchApi217WormDataPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApi217WormDataPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPatchApi217WormDataPoliciesRequestWithBody generates requests for PatchApi217WormDataPolicies with any type of body
func NewPatchApi217WormDataPoliciesRequestWithBody(server string, params *PatchApi217WormDataPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/worm-data-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Names != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, *params.Names); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApi217WormDataPoliciesRequest calls the generic PostApi217WormDataPolicies builder with application/json body
func NewPostApi217WormDataPoliciesRequest(server string, params *PostApi217WormDataPoliciesParams, body PostApi217WormDataPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostApi217WormDataPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostApi217WormDataPoliciesRequestWithBody generates requests for PostApi217WormDataPolicies with any type of body
func NewPostApi217WormDataPoliciesRequestWithBody(server string, params *PostApi217WormDataPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/worm-data-policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "names", runtime.ParamLocationQuery, params.Names); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApi217WormDataPoliciesMembersRequest generates requests for GetApi217WormDataPoliciesMembers
func NewGetApi217WormDataPoliciesMembersRequest(server string, params *GetApi217WormDataPoliciesMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/2.17/worm-data-policies/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AllowErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "allow_errors", runtime.ParamLocationQuery, *params.AllowErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContextNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "context_names", runtime.ParamLocationQuery, *params.ContextNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContinuationToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuation_token", runtime.ParamLocationQuery, *params.ContinuationToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_ids", runtime.ParamLocationQuery, *params.MemberIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "member_names", runtime.ParamLocationQuery, *params.MemberNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_ids", runtime.ParamLocationQuery, *params.PolicyIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PolicyNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "policy_names", runtime.ParamLocationQuery, *params.PolicyNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiApiVersionRequest generates requests for GetApiApiVersion
func NewGetApiApiVersionRequest(server string, params *GetApiApiVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/api_version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApiLoginRequest generates requests for PostApiLogin
func NewPostApiLoginRequest(server string, params *PostApiLoginParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetApiLoginBannerRequest generates requests for GetApiLoginBanner
func NewGetApiLoginBannerRequest(server string, params *GetApiLoginBannerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/login-banner")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostApiLogoutRequest generates requests for PostApiLogout
func NewPostApiLogoutRequest(server string, params *PostApiLogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

// NewPostOauth210TokenRequestWithFormdataBody calls the generic PostOauth210Token builder with application/x-www-form-urlencoded body
func NewPostOauth210TokenRequestWithFormdataBody(server string, params *PostOauth210TokenParams, body PostOauth210TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostOauth210TokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostOauth210TokenRequestWithBody generates requests for PostOauth210Token with any type of body
func NewPostOauth210TokenRequestWithBody(server string, params *PostOauth210TokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/1.0/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteApi217ActiveDirectoryWithResponse request
	DeleteApi217ActiveDirectoryWithResponse(ctx context.Context, params *DeleteApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*DeleteApi217ActiveDirectoryResponse, error)

	// GetApi217ActiveDirectoryWithResponse request
	GetApi217ActiveDirectoryWithResponse(ctx context.Context, params *GetApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*GetApi217ActiveDirectoryResponse, error)

	// PatchApi217ActiveDirectoryWithBodyWithResponse request with any body
	PatchApi217ActiveDirectoryWithBodyWithResponse(ctx context.Context, params *PatchApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ActiveDirectoryResponse, error)

	PatchApi217ActiveDirectoryWithResponse(ctx context.Context, params *PatchApi217ActiveDirectoryParams, body PatchApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ActiveDirectoryResponse, error)

	// PostApi217ActiveDirectoryWithBodyWithResponse request with any body
	PostApi217ActiveDirectoryWithBodyWithResponse(ctx context.Context, params *PostApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ActiveDirectoryResponse, error)

	PostApi217ActiveDirectoryWithResponse(ctx context.Context, params *PostApi217ActiveDirectoryParams, body PostApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ActiveDirectoryResponse, error)

	// GetApi217ActiveDirectoryTestWithResponse request
	GetApi217ActiveDirectoryTestWithResponse(ctx context.Context, params *GetApi217ActiveDirectoryTestParams, reqEditors ...RequestEditorFn) (*GetApi217ActiveDirectoryTestResponse, error)

	// DeleteApi217AdminsWithResponse request
	DeleteApi217AdminsWithResponse(ctx context.Context, params *DeleteApi217AdminsParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsResponse, error)

	// GetApi217AdminsWithResponse request
	GetApi217AdminsWithResponse(ctx context.Context, params *GetApi217AdminsParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsResponse, error)

	// PatchApi217AdminsWithBodyWithResponse request with any body
	PatchApi217AdminsWithBodyWithResponse(ctx context.Context, params *PatchApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AdminsResponse, error)

	PatchApi217AdminsWithResponse(ctx context.Context, params *PatchApi217AdminsParams, body PatchApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AdminsResponse, error)

	// PostApi217AdminsWithBodyWithResponse request with any body
	PostApi217AdminsWithBodyWithResponse(ctx context.Context, params *PostApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217AdminsResponse, error)

	PostApi217AdminsWithResponse(ctx context.Context, params *PostApi217AdminsParams, body PostApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217AdminsResponse, error)

	// DeleteApi217AdminsApiTokensWithResponse request
	DeleteApi217AdminsApiTokensWithResponse(ctx context.Context, params *DeleteApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsApiTokensResponse, error)

	// GetApi217AdminsApiTokensWithResponse request
	GetApi217AdminsApiTokensWithResponse(ctx context.Context, params *GetApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsApiTokensResponse, error)

	// PostApi217AdminsApiTokensWithResponse request
	PostApi217AdminsApiTokensWithResponse(ctx context.Context, params *PostApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*PostApi217AdminsApiTokensResponse, error)

	// DeleteApi217AdminsCacheWithResponse request
	DeleteApi217AdminsCacheWithResponse(ctx context.Context, params *DeleteApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsCacheResponse, error)

	// GetApi217AdminsCacheWithResponse request
	GetApi217AdminsCacheWithResponse(ctx context.Context, params *GetApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsCacheResponse, error)

	// GetApi217AdminsSettingsWithResponse request
	GetApi217AdminsSettingsWithResponse(ctx context.Context, params *GetApi217AdminsSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsSettingsResponse, error)

	// PatchApi217AdminsSettingsWithBodyWithResponse request with any body
	PatchApi217AdminsSettingsWithBodyWithResponse(ctx context.Context, params *PatchApi217AdminsSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AdminsSettingsResponse, error)

	PatchApi217AdminsSettingsWithResponse(ctx context.Context, params *PatchApi217AdminsSettingsParams, body PatchApi217AdminsSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AdminsSettingsResponse, error)

	// DeleteApi217AdminsSshCertificateAuthorityPoliciesWithResponse request
	DeleteApi217AdminsSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *DeleteApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse, error)

	// GetApi217AdminsSshCertificateAuthorityPoliciesWithResponse request
	GetApi217AdminsSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *GetApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsSshCertificateAuthorityPoliciesResponse, error)

	// PostApi217AdminsSshCertificateAuthorityPoliciesWithResponse request
	PostApi217AdminsSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PostApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217AdminsSshCertificateAuthorityPoliciesResponse, error)

	// DeleteApi217AlertWatchersWithResponse request
	DeleteApi217AlertWatchersWithResponse(ctx context.Context, params *DeleteApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*DeleteApi217AlertWatchersResponse, error)

	// GetApi217AlertWatchersWithResponse request
	GetApi217AlertWatchersWithResponse(ctx context.Context, params *GetApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*GetApi217AlertWatchersResponse, error)

	// PatchApi217AlertWatchersWithBodyWithResponse request with any body
	PatchApi217AlertWatchersWithBodyWithResponse(ctx context.Context, params *PatchApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AlertWatchersResponse, error)

	PatchApi217AlertWatchersWithResponse(ctx context.Context, params *PatchApi217AlertWatchersParams, body PatchApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AlertWatchersResponse, error)

	// PostApi217AlertWatchersWithBodyWithResponse request with any body
	PostApi217AlertWatchersWithBodyWithResponse(ctx context.Context, params *PostApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217AlertWatchersResponse, error)

	PostApi217AlertWatchersWithResponse(ctx context.Context, params *PostApi217AlertWatchersParams, body PostApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217AlertWatchersResponse, error)

	// GetApi217AlertWatchersTestWithResponse request
	GetApi217AlertWatchersTestWithResponse(ctx context.Context, params *GetApi217AlertWatchersTestParams, reqEditors ...RequestEditorFn) (*GetApi217AlertWatchersTestResponse, error)

	// GetApi217AlertsWithResponse request
	GetApi217AlertsWithResponse(ctx context.Context, params *GetApi217AlertsParams, reqEditors ...RequestEditorFn) (*GetApi217AlertsResponse, error)

	// PatchApi217AlertsWithBodyWithResponse request with any body
	PatchApi217AlertsWithBodyWithResponse(ctx context.Context, params *PatchApi217AlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AlertsResponse, error)

	PatchApi217AlertsWithResponse(ctx context.Context, params *PatchApi217AlertsParams, body PatchApi217AlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AlertsResponse, error)

	// DeleteApi217ApiClientsWithResponse request
	DeleteApi217ApiClientsWithResponse(ctx context.Context, params *DeleteApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ApiClientsResponse, error)

	// GetApi217ApiClientsWithResponse request
	GetApi217ApiClientsWithResponse(ctx context.Context, params *GetApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*GetApi217ApiClientsResponse, error)

	// PatchApi217ApiClientsWithBodyWithResponse request with any body
	PatchApi217ApiClientsWithBodyWithResponse(ctx context.Context, params *PatchApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ApiClientsResponse, error)

	PatchApi217ApiClientsWithResponse(ctx context.Context, params *PatchApi217ApiClientsParams, body PatchApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ApiClientsResponse, error)

	// PostApi217ApiClientsWithBodyWithResponse request with any body
	PostApi217ApiClientsWithBodyWithResponse(ctx context.Context, params *PostApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ApiClientsResponse, error)

	PostApi217ApiClientsWithResponse(ctx context.Context, params *PostApi217ApiClientsParams, body PostApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ApiClientsResponse, error)

	// DeleteApi217ArrayConnectionsWithResponse request
	DeleteApi217ArrayConnectionsWithResponse(ctx context.Context, params *DeleteApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ArrayConnectionsResponse, error)

	// GetApi217ArrayConnectionsWithResponse request
	GetApi217ArrayConnectionsWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsResponse, error)

	// PatchApi217ArrayConnectionsWithBodyWithResponse request with any body
	PatchApi217ArrayConnectionsWithBodyWithResponse(ctx context.Context, params *PatchApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ArrayConnectionsResponse, error)

	PatchApi217ArrayConnectionsWithResponse(ctx context.Context, params *PatchApi217ArrayConnectionsParams, body PatchApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ArrayConnectionsResponse, error)

	// PostApi217ArrayConnectionsWithBodyWithResponse request with any body
	PostApi217ArrayConnectionsWithBodyWithResponse(ctx context.Context, params *PostApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ArrayConnectionsResponse, error)

	PostApi217ArrayConnectionsWithResponse(ctx context.Context, params *PostApi217ArrayConnectionsParams, body PostApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ArrayConnectionsResponse, error)

	// GetApi217ArrayConnectionsConnectionKeyWithResponse request
	GetApi217ArrayConnectionsConnectionKeyWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsConnectionKeyResponse, error)

	// PostApi217ArrayConnectionsConnectionKeyWithResponse request
	PostApi217ArrayConnectionsConnectionKeyWithResponse(ctx context.Context, params *PostApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*PostApi217ArrayConnectionsConnectionKeyResponse, error)

	// GetApi217ArrayConnectionsPathWithResponse request
	GetApi217ArrayConnectionsPathWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsPathParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsPathResponse, error)

	// GetApi217ArrayConnectionsPerformanceReplicationWithResponse request
	GetApi217ArrayConnectionsPerformanceReplicationWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsPerformanceReplicationResponse, error)

	// GetApi217ArraysWithResponse request
	GetApi217ArraysWithResponse(ctx context.Context, params *GetApi217ArraysParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysResponse, error)

	// PatchApi217ArraysWithBodyWithResponse request with any body
	PatchApi217ArraysWithBodyWithResponse(ctx context.Context, params *PatchApi217ArraysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ArraysResponse, error)

	PatchApi217ArraysWithResponse(ctx context.Context, params *PatchApi217ArraysParams, body PatchApi217ArraysJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ArraysResponse, error)

	// GetApi217ArraysClientsPerformanceWithResponse request
	GetApi217ArraysClientsPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysClientsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysClientsPerformanceResponse, error)

	// GetApi217ArraysEulaWithResponse request
	GetApi217ArraysEulaWithResponse(ctx context.Context, params *GetApi217ArraysEulaParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysEulaResponse, error)

	// PatchApi217ArraysEulaWithBodyWithResponse request with any body
	PatchApi217ArraysEulaWithBodyWithResponse(ctx context.Context, params *PatchApi217ArraysEulaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ArraysEulaResponse, error)

	PatchApi217ArraysEulaWithResponse(ctx context.Context, params *PatchApi217ArraysEulaParams, body PatchApi217ArraysEulaJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ArraysEulaResponse, error)

	// DeleteApi217ArraysFactoryResetTokenWithResponse request
	DeleteApi217ArraysFactoryResetTokenWithResponse(ctx context.Context, params *DeleteApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*DeleteApi217ArraysFactoryResetTokenResponse, error)

	// GetApi217ArraysFactoryResetTokenWithResponse request
	GetApi217ArraysFactoryResetTokenWithResponse(ctx context.Context, params *GetApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysFactoryResetTokenResponse, error)

	// PostApi217ArraysFactoryResetTokenWithResponse request
	PostApi217ArraysFactoryResetTokenWithResponse(ctx context.Context, params *PostApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*PostApi217ArraysFactoryResetTokenResponse, error)

	// GetApi217ArraysHttpSpecificPerformanceWithResponse request
	GetApi217ArraysHttpSpecificPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysHttpSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysHttpSpecificPerformanceResponse, error)

	// GetApi217ArraysNfsSpecificPerformanceWithResponse request
	GetApi217ArraysNfsSpecificPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysNfsSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysNfsSpecificPerformanceResponse, error)

	// GetApi217ArraysPerformanceWithResponse request
	GetApi217ArraysPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysPerformanceResponse, error)

	// GetApi217ArraysPerformanceReplicationWithResponse request
	GetApi217ArraysPerformanceReplicationWithResponse(ctx context.Context, params *GetApi217ArraysPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysPerformanceReplicationResponse, error)

	// GetApi217ArraysS3SpecificPerformanceWithResponse request
	GetApi217ArraysS3SpecificPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysS3SpecificPerformanceResponse, error)

	// GetApi217ArraysSpaceWithResponse request
	GetApi217ArraysSpaceWithResponse(ctx context.Context, params *GetApi217ArraysSpaceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSpaceResponse, error)

	// GetApi217ArraysSpaceStorageClassesWithResponse request
	GetApi217ArraysSpaceStorageClassesWithResponse(ctx context.Context, params *GetApi217ArraysSpaceStorageClassesParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSpaceStorageClassesResponse, error)

	// DeleteApi217ArraysSshCertificateAuthorityPoliciesWithResponse request
	DeleteApi217ArraysSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *DeleteApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse, error)

	// GetApi217ArraysSshCertificateAuthorityPoliciesWithResponse request
	GetApi217ArraysSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *GetApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSshCertificateAuthorityPoliciesResponse, error)

	// PostApi217ArraysSshCertificateAuthorityPoliciesWithResponse request
	PostApi217ArraysSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PostApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217ArraysSshCertificateAuthorityPoliciesResponse, error)

	// GetApi217ArraysSupportedTimeZonesWithResponse request
	GetApi217ArraysSupportedTimeZonesWithResponse(ctx context.Context, params *GetApi217ArraysSupportedTimeZonesParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSupportedTimeZonesResponse, error)

	// DeleteApi217AuditFileSystemsPoliciesWithResponse request
	DeleteApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217AuditFileSystemsPoliciesResponse, error)

	// GetApi217AuditFileSystemsPoliciesWithResponse request
	GetApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217AuditFileSystemsPoliciesResponse, error)

	// PatchApi217AuditFileSystemsPoliciesWithBodyWithResponse request with any body
	PatchApi217AuditFileSystemsPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AuditFileSystemsPoliciesResponse, error)

	PatchApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, body PatchApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AuditFileSystemsPoliciesResponse, error)

	// PostApi217AuditFileSystemsPoliciesWithBodyWithResponse request with any body
	PostApi217AuditFileSystemsPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217AuditFileSystemsPoliciesResponse, error)

	PostApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, body PostApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217AuditFileSystemsPoliciesResponse, error)

	// DeleteApi217AuditFileSystemsPoliciesMembersWithResponse request
	DeleteApi217AuditFileSystemsPoliciesMembersWithResponse(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*DeleteApi217AuditFileSystemsPoliciesMembersResponse, error)

	// GetApi217AuditFileSystemsPoliciesMembersWithResponse request
	GetApi217AuditFileSystemsPoliciesMembersWithResponse(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217AuditFileSystemsPoliciesMembersResponse, error)

	// PostApi217AuditFileSystemsPoliciesMembersWithResponse request
	PostApi217AuditFileSystemsPoliciesMembersWithResponse(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*PostApi217AuditFileSystemsPoliciesMembersResponse, error)

	// GetApi217AuditsWithResponse request
	GetApi217AuditsWithResponse(ctx context.Context, params *GetApi217AuditsParams, reqEditors ...RequestEditorFn) (*GetApi217AuditsResponse, error)

	// GetApi217BladesWithResponse request
	GetApi217BladesWithResponse(ctx context.Context, params *GetApi217BladesParams, reqEditors ...RequestEditorFn) (*GetApi217BladesResponse, error)

	// DeleteApi217BucketReplicaLinksWithResponse request
	DeleteApi217BucketReplicaLinksWithResponse(ctx context.Context, params *DeleteApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketReplicaLinksResponse, error)

	// GetApi217BucketReplicaLinksWithResponse request
	GetApi217BucketReplicaLinksWithResponse(ctx context.Context, params *GetApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*GetApi217BucketReplicaLinksResponse, error)

	// PatchApi217BucketReplicaLinksWithBodyWithResponse request with any body
	PatchApi217BucketReplicaLinksWithBodyWithResponse(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217BucketReplicaLinksResponse, error)

	PatchApi217BucketReplicaLinksWithResponse(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, body PatchApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217BucketReplicaLinksResponse, error)

	// PostApi217BucketReplicaLinksWithBodyWithResponse request with any body
	PostApi217BucketReplicaLinksWithBodyWithResponse(ctx context.Context, params *PostApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketReplicaLinksResponse, error)

	PostApi217BucketReplicaLinksWithResponse(ctx context.Context, params *PostApi217BucketReplicaLinksParams, body PostApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketReplicaLinksResponse, error)

	// DeleteApi217BucketsWithResponse request
	DeleteApi217BucketsWithResponse(ctx context.Context, params *DeleteApi217BucketsParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsResponse, error)

	// GetApi217BucketsWithResponse request
	GetApi217BucketsWithResponse(ctx context.Context, params *GetApi217BucketsParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsResponse, error)

	// PatchApi217BucketsWithBodyWithResponse request with any body
	PatchApi217BucketsWithBodyWithResponse(ctx context.Context, params *PatchApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217BucketsResponse, error)

	PatchApi217BucketsWithResponse(ctx context.Context, params *PatchApi217BucketsParams, body PatchApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217BucketsResponse, error)

	// PostApi217BucketsWithBodyWithResponse request with any body
	PostApi217BucketsWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsResponse, error)

	PostApi217BucketsWithResponse(ctx context.Context, params *PostApi217BucketsParams, body PostApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsResponse, error)

	// DeleteApi217BucketsBucketAccessPoliciesWithResponse request
	DeleteApi217BucketsBucketAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsBucketAccessPoliciesResponse, error)

	// GetApi217BucketsBucketAccessPoliciesWithResponse request
	GetApi217BucketsBucketAccessPoliciesWithResponse(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsBucketAccessPoliciesResponse, error)

	// PostApi217BucketsBucketAccessPoliciesWithBodyWithResponse request with any body
	PostApi217BucketsBucketAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesResponse, error)

	PostApi217BucketsBucketAccessPoliciesWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, body PostApi217BucketsBucketAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesResponse, error)

	// DeleteApi217BucketsBucketAccessPoliciesRulesWithResponse request
	DeleteApi217BucketsBucketAccessPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsBucketAccessPoliciesRulesResponse, error)

	// GetApi217BucketsBucketAccessPoliciesRulesWithResponse request
	GetApi217BucketsBucketAccessPoliciesRulesWithResponse(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsBucketAccessPoliciesRulesResponse, error)

	// PostApi217BucketsBucketAccessPoliciesRulesWithBodyWithResponse request with any body
	PostApi217BucketsBucketAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesRulesResponse, error)

	PostApi217BucketsBucketAccessPoliciesRulesWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, body PostApi217BucketsBucketAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesRulesResponse, error)

	// DeleteApi217BucketsCrossOriginResourceSharingPoliciesWithResponse request
	DeleteApi217BucketsCrossOriginResourceSharingPoliciesWithResponse(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse, error)

	// GetApi217BucketsCrossOriginResourceSharingPoliciesWithResponse request
	GetApi217BucketsCrossOriginResourceSharingPoliciesWithResponse(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsCrossOriginResourceSharingPoliciesResponse, error)

	// PostApi217BucketsCrossOriginResourceSharingPoliciesWithBodyWithResponse request with any body
	PostApi217BucketsCrossOriginResourceSharingPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesResponse, error)

	PostApi217BucketsCrossOriginResourceSharingPoliciesWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesResponse, error)

	// DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse request
	DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error)

	// GetApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse request
	GetApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error)

	// PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBodyWithResponse request with any body
	PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error)

	PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error)

	// GetApi217BucketsPerformanceWithResponse request
	GetApi217BucketsPerformanceWithResponse(ctx context.Context, params *GetApi217BucketsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsPerformanceResponse, error)

	// GetApi217BucketsS3SpecificPerformanceWithResponse request
	GetApi217BucketsS3SpecificPerformanceWithResponse(ctx context.Context, params *GetApi217BucketsS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsS3SpecificPerformanceResponse, error)

	// DeleteApi217CertificateGroupsWithResponse request
	DeleteApi217CertificateGroupsWithResponse(ctx context.Context, params *DeleteApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificateGroupsResponse, error)

	// GetApi217CertificateGroupsWithResponse request
	GetApi217CertificateGroupsWithResponse(ctx context.Context, params *GetApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217CertificateGroupsResponse, error)

	// PostApi217CertificateGroupsWithResponse request
	PostApi217CertificateGroupsWithResponse(ctx context.Context, params *PostApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*PostApi217CertificateGroupsResponse, error)

	// DeleteApi217CertificateGroupsCertificatesWithResponse request
	DeleteApi217CertificateGroupsCertificatesWithResponse(ctx context.Context, params *DeleteApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificateGroupsCertificatesResponse, error)

	// GetApi217CertificateGroupsCertificatesWithResponse request
	GetApi217CertificateGroupsCertificatesWithResponse(ctx context.Context, params *GetApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificateGroupsCertificatesResponse, error)

	// PostApi217CertificateGroupsCertificatesWithResponse request
	PostApi217CertificateGroupsCertificatesWithResponse(ctx context.Context, params *PostApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*PostApi217CertificateGroupsCertificatesResponse, error)

	// GetApi217CertificateGroupsUsesWithResponse request
	GetApi217CertificateGroupsUsesWithResponse(ctx context.Context, params *GetApi217CertificateGroupsUsesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificateGroupsUsesResponse, error)

	// DeleteApi217CertificatesWithResponse request
	DeleteApi217CertificatesWithResponse(ctx context.Context, params *DeleteApi217CertificatesParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificatesResponse, error)

	// GetApi217CertificatesWithResponse request
	GetApi217CertificatesWithResponse(ctx context.Context, params *GetApi217CertificatesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificatesResponse, error)

	// PatchApi217CertificatesWithBodyWithResponse request with any body
	PatchApi217CertificatesWithBodyWithResponse(ctx context.Context, params *PatchApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217CertificatesResponse, error)

	PatchApi217CertificatesWithResponse(ctx context.Context, params *PatchApi217CertificatesParams, body PatchApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217CertificatesResponse, error)

	// PostApi217CertificatesWithBodyWithResponse request with any body
	PostApi217CertificatesWithBodyWithResponse(ctx context.Context, params *PostApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217CertificatesResponse, error)

	PostApi217CertificatesWithResponse(ctx context.Context, params *PostApi217CertificatesParams, body PostApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217CertificatesResponse, error)

	// DeleteApi217CertificatesCertificateGroupsWithResponse request
	DeleteApi217CertificatesCertificateGroupsWithResponse(ctx context.Context, params *DeleteApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificatesCertificateGroupsResponse, error)

	// GetApi217CertificatesCertificateGroupsWithResponse request
	GetApi217CertificatesCertificateGroupsWithResponse(ctx context.Context, params *GetApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217CertificatesCertificateGroupsResponse, error)

	// PostApi217CertificatesCertificateGroupsWithResponse request
	PostApi217CertificatesCertificateGroupsWithResponse(ctx context.Context, params *PostApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*PostApi217CertificatesCertificateGroupsResponse, error)

	// GetApi217CertificatesUsesWithResponse request
	GetApi217CertificatesUsesWithResponse(ctx context.Context, params *GetApi217CertificatesUsesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificatesUsesResponse, error)

	// GetApi217DirectoryServicesWithResponse request
	GetApi217DirectoryServicesWithResponse(ctx context.Context, params *GetApi217DirectoryServicesParams, reqEditors ...RequestEditorFn) (*GetApi217DirectoryServicesResponse, error)

	// PatchApi217DirectoryServicesWithBodyWithResponse request with any body
	PatchApi217DirectoryServicesWithBodyWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesResponse, error)

	PatchApi217DirectoryServicesWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesParams, body PatchApi217DirectoryServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesResponse, error)

	// DeleteApi217DirectoryServicesRolesWithResponse request
	DeleteApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *DeleteApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*DeleteApi217DirectoryServicesRolesResponse, error)

	// GetApi217DirectoryServicesRolesWithResponse request
	GetApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *GetApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*GetApi217DirectoryServicesRolesResponse, error)

	// PatchApi217DirectoryServicesRolesWithBodyWithResponse request with any body
	PatchApi217DirectoryServicesRolesWithBodyWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesRolesResponse, error)

	PatchApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, body PatchApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesRolesResponse, error)

	// PostApi217DirectoryServicesRolesWithBodyWithResponse request with any body
	PostApi217DirectoryServicesRolesWithBodyWithResponse(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217DirectoryServicesRolesResponse, error)

	PostApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, body PostApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217DirectoryServicesRolesResponse, error)

	// GetApi217DirectoryServicesTestWithResponse request
	GetApi217DirectoryServicesTestWithResponse(ctx context.Context, params *GetApi217DirectoryServicesTestParams, reqEditors ...RequestEditorFn) (*GetApi217DirectoryServicesTestResponse, error)

	// PatchApi217DirectoryServicesTestWithBodyWithResponse request with any body
	PatchApi217DirectoryServicesTestWithBodyWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesTestResponse, error)

	PatchApi217DirectoryServicesTestWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, body PatchApi217DirectoryServicesTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesTestResponse, error)

	// DeleteApi217DnsWithResponse request
	DeleteApi217DnsWithResponse(ctx context.Context, params *DeleteApi217DnsParams, reqEditors ...RequestEditorFn) (*DeleteApi217DnsResponse, error)

	// GetApi217DnsWithResponse request
	GetApi217DnsWithResponse(ctx context.Context, params *GetApi217DnsParams, reqEditors ...RequestEditorFn) (*GetApi217DnsResponse, error)

	// PatchApi217DnsWithBodyWithResponse request with any body
	PatchApi217DnsWithBodyWithResponse(ctx context.Context, params *PatchApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DnsResponse, error)

	PatchApi217DnsWithResponse(ctx context.Context, params *PatchApi217DnsParams, body PatchApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DnsResponse, error)

	// PostApi217DnsWithBodyWithResponse request with any body
	PostApi217DnsWithBodyWithResponse(ctx context.Context, params *PostApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217DnsResponse, error)

	PostApi217DnsWithResponse(ctx context.Context, params *PostApi217DnsParams, body PostApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217DnsResponse, error)

	// GetApi217DrivesWithResponse request
	GetApi217DrivesWithResponse(ctx context.Context, params *GetApi217DrivesParams, reqEditors ...RequestEditorFn) (*GetApi217DrivesResponse, error)

	// DeleteApi217FileSystemExportsWithResponse request
	DeleteApi217FileSystemExportsWithResponse(ctx context.Context, params *DeleteApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemExportsResponse, error)

	// GetApi217FileSystemExportsWithResponse request
	GetApi217FileSystemExportsWithResponse(ctx context.Context, params *GetApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemExportsResponse, error)

	// PatchApi217FileSystemExportsWithBodyWithResponse request with any body
	PatchApi217FileSystemExportsWithBodyWithResponse(ctx context.Context, params *PatchApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemExportsResponse, error)

	PatchApi217FileSystemExportsWithResponse(ctx context.Context, params *PatchApi217FileSystemExportsParams, body PatchApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemExportsResponse, error)

	// PostApi217FileSystemExportsWithBodyWithResponse request with any body
	PostApi217FileSystemExportsWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemExportsResponse, error)

	PostApi217FileSystemExportsWithResponse(ctx context.Context, params *PostApi217FileSystemExportsParams, body PostApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemExportsResponse, error)

	// DeleteApi217FileSystemReplicaLinksWithResponse request
	DeleteApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemReplicaLinksResponse, error)

	// GetApi217FileSystemReplicaLinksWithResponse request
	GetApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *GetApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemReplicaLinksResponse, error)

	// PatchApi217FileSystemReplicaLinksWithResponse request
	PatchApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *PatchApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemReplicaLinksResponse, error)

	// PostApi217FileSystemReplicaLinksWithBodyWithResponse request with any body
	PostApi217FileSystemReplicaLinksWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemReplicaLinksResponse, error)

	PostApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, body PostApi217FileSystemReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemReplicaLinksResponse, error)

	// DeleteApi217FileSystemReplicaLinksPoliciesWithResponse request
	DeleteApi217FileSystemReplicaLinksPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemReplicaLinksPoliciesResponse, error)

	// GetApi217FileSystemReplicaLinksPoliciesWithResponse request
	GetApi217FileSystemReplicaLinksPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemReplicaLinksPoliciesResponse, error)

	// PostApi217FileSystemReplicaLinksPoliciesWithResponse request
	PostApi217FileSystemReplicaLinksPoliciesWithResponse(ctx context.Context, params *PostApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemReplicaLinksPoliciesResponse, error)

	// GetApi217FileSystemReplicaLinksTransferWithResponse request
	GetApi217FileSystemReplicaLinksTransferWithResponse(ctx context.Context, params *GetApi217FileSystemReplicaLinksTransferParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemReplicaLinksTransferResponse, error)

	// DeleteApi217FileSystemSnapshotsWithResponse request
	DeleteApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *DeleteApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemSnapshotsResponse, error)

	// GetApi217FileSystemSnapshotsWithResponse request
	GetApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *GetApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemSnapshotsResponse, error)

	// PatchApi217FileSystemSnapshotsWithBodyWithResponse request with any body
	PatchApi217FileSystemSnapshotsWithBodyWithResponse(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemSnapshotsResponse, error)

	PatchApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, body PatchApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemSnapshotsResponse, error)

	// PostApi217FileSystemSnapshotsWithBodyWithResponse request with any body
	PostApi217FileSystemSnapshotsWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemSnapshotsResponse, error)

	PostApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, body PostApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemSnapshotsResponse, error)

	// DeleteApi217FileSystemSnapshotsPoliciesWithResponse request
	DeleteApi217FileSystemSnapshotsPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemSnapshotsPoliciesResponse, error)

	// GetApi217FileSystemSnapshotsPoliciesWithResponse request
	GetApi217FileSystemSnapshotsPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemSnapshotsPoliciesResponse, error)

	// DeleteApi217FileSystemSnapshotsTransferWithResponse request
	DeleteApi217FileSystemSnapshotsTransferWithResponse(ctx context.Context, params *DeleteApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemSnapshotsTransferResponse, error)

	// GetApi217FileSystemSnapshotsTransferWithResponse request
	GetApi217FileSystemSnapshotsTransferWithResponse(ctx context.Context, params *GetApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemSnapshotsTransferResponse, error)

	// DeleteApi217FileSystemsWithResponse request
	DeleteApi217FileSystemsWithResponse(ctx context.Context, params *DeleteApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsResponse, error)

	// GetApi217FileSystemsWithResponse request
	GetApi217FileSystemsWithResponse(ctx context.Context, params *GetApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsResponse, error)

	// PatchApi217FileSystemsWithBodyWithResponse request with any body
	PatchApi217FileSystemsWithBodyWithResponse(ctx context.Context, params *PatchApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemsResponse, error)

	PatchApi217FileSystemsWithResponse(ctx context.Context, params *PatchApi217FileSystemsParams, body PatchApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemsResponse, error)

	// PostApi217FileSystemsWithBodyWithResponse request with any body
	PostApi217FileSystemsWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsResponse, error)

	PostApi217FileSystemsWithResponse(ctx context.Context, params *PostApi217FileSystemsParams, body PostApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsResponse, error)

	// DeleteApi217FileSystemsAuditPoliciesWithResponse request
	DeleteApi217FileSystemsAuditPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsAuditPoliciesResponse, error)

	// GetApi217FileSystemsAuditPoliciesWithResponse request
	GetApi217FileSystemsAuditPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsAuditPoliciesResponse, error)

	// PostApi217FileSystemsAuditPoliciesWithResponse request
	PostApi217FileSystemsAuditPoliciesWithResponse(ctx context.Context, params *PostApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsAuditPoliciesResponse, error)

	// GetApi217FileSystemsGroupsPerformanceWithResponse request
	GetApi217FileSystemsGroupsPerformanceWithResponse(ctx context.Context, params *GetApi217FileSystemsGroupsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsGroupsPerformanceResponse, error)

	// DeleteApi217FileSystemsLocksWithResponse request
	DeleteApi217FileSystemsLocksWithResponse(ctx context.Context, params *DeleteApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsLocksResponse, error)

	// GetApi217FileSystemsLocksWithResponse request
	GetApi217FileSystemsLocksWithResponse(ctx context.Context, params *GetApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsLocksResponse, error)

	// GetApi217FileSystemsLocksClientsWithResponse request
	GetApi217FileSystemsLocksClientsWithResponse(ctx context.Context, params *GetApi217FileSystemsLocksClientsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsLocksClientsResponse, error)

	// PostApi217FileSystemsLocksNlmReclamationsWithResponse request
	PostApi217FileSystemsLocksNlmReclamationsWithResponse(ctx context.Context, params *PostApi217FileSystemsLocksNlmReclamationsParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsLocksNlmReclamationsResponse, error)

	// DeleteApi217FileSystemsOpenFilesWithResponse request
	DeleteApi217FileSystemsOpenFilesWithResponse(ctx context.Context, params *DeleteApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsOpenFilesResponse, error)

	// GetApi217FileSystemsOpenFilesWithResponse request
	GetApi217FileSystemsOpenFilesWithResponse(ctx context.Context, params *GetApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsOpenFilesResponse, error)

	// GetApi217FileSystemsPerformanceWithResponse request
	GetApi217FileSystemsPerformanceWithResponse(ctx context.Context, params *GetApi217FileSystemsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsPerformanceResponse, error)

	// DeleteApi217FileSystemsPoliciesWithResponse request
	DeleteApi217FileSystemsPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsPoliciesResponse, error)

	// GetApi217FileSystemsPoliciesWithResponse request
	GetApi217FileSystemsPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsPoliciesResponse, error)

	// PostApi217FileSystemsPoliciesWithResponse request
	PostApi217FileSystemsPoliciesWithResponse(ctx context.Context, params *PostApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsPoliciesResponse, error)

	// GetApi217FileSystemsPoliciesAllWithResponse request
	GetApi217FileSystemsPoliciesAllWithResponse(ctx context.Context, params *GetApi217FileSystemsPoliciesAllParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsPoliciesAllResponse, error)

	// DeleteApi217FileSystemsSessionsWithResponse request
	DeleteApi217FileSystemsSessionsWithResponse(ctx context.Context, params *DeleteApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsSessionsResponse, error)

	// GetApi217FileSystemsSessionsWithResponse request
	GetApi217FileSystemsSessionsWithResponse(ctx context.Context, params *GetApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsSessionsResponse, error)

	// GetApi217FileSystemsUsersPerformanceWithResponse request
	GetApi217FileSystemsUsersPerformanceWithResponse(ctx context.Context, params *GetApi217FileSystemsUsersPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsUsersPerformanceResponse, error)

	// GetApi217FileSystemsWormDataPoliciesWithResponse request
	GetApi217FileSystemsWormDataPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemsWormDataPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsWormDataPoliciesResponse, error)

	// DeleteApi217FleetsWithResponse request
	DeleteApi217FleetsWithResponse(ctx context.Context, params *DeleteApi217FleetsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FleetsResponse, error)

	// GetApi217FleetsWithResponse request
	GetApi217FleetsWithResponse(ctx context.Context, params *GetApi217FleetsParams, reqEditors ...RequestEditorFn) (*GetApi217FleetsResponse, error)

	// PatchApi217FleetsWithBodyWithResponse request with any body
	PatchApi217FleetsWithBodyWithResponse(ctx context.Context, params *PatchApi217FleetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FleetsResponse, error)

	PatchApi217FleetsWithResponse(ctx context.Context, params *PatchApi217FleetsParams, body PatchApi217FleetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FleetsResponse, error)

	// PostApi217FleetsWithResponse request
	PostApi217FleetsWithResponse(ctx context.Context, params *PostApi217FleetsParams, reqEditors ...RequestEditorFn) (*PostApi217FleetsResponse, error)

	// GetApi217FleetsFleetKeyWithResponse request
	GetApi217FleetsFleetKeyWithResponse(ctx context.Context, params *GetApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*GetApi217FleetsFleetKeyResponse, error)

	// PostApi217FleetsFleetKeyWithResponse request
	PostApi217FleetsFleetKeyWithResponse(ctx context.Context, params *PostApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*PostApi217FleetsFleetKeyResponse, error)

	// DeleteApi217FleetsMembersWithResponse request
	DeleteApi217FleetsMembersWithResponse(ctx context.Context, params *DeleteApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*DeleteApi217FleetsMembersResponse, error)

	// GetApi217FleetsMembersWithResponse request
	GetApi217FleetsMembersWithResponse(ctx context.Context, params *GetApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*GetApi217FleetsMembersResponse, error)

	// PostApi217FleetsMembersWithBodyWithResponse request with any body
	PostApi217FleetsMembersWithBodyWithResponse(ctx context.Context, params *PostApi217FleetsMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FleetsMembersResponse, error)

	PostApi217FleetsMembersWithResponse(ctx context.Context, params *PostApi217FleetsMembersParams, body PostApi217FleetsMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FleetsMembersResponse, error)

	// GetApi217HardwareWithResponse request
	GetApi217HardwareWithResponse(ctx context.Context, params *GetApi217HardwareParams, reqEditors ...RequestEditorFn) (*GetApi217HardwareResponse, error)

	// PatchApi217HardwareWithBodyWithResponse request with any body
	PatchApi217HardwareWithBodyWithResponse(ctx context.Context, params *PatchApi217HardwareParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217HardwareResponse, error)

	PatchApi217HardwareWithResponse(ctx context.Context, params *PatchApi217HardwareParams, body PatchApi217HardwareJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217HardwareResponse, error)

	// GetApi217HardwareConnectorsWithResponse request
	GetApi217HardwareConnectorsWithResponse(ctx context.Context, params *GetApi217HardwareConnectorsParams, reqEditors ...RequestEditorFn) (*GetApi217HardwareConnectorsResponse, error)

	// PatchApi217HardwareConnectorsWithBodyWithResponse request with any body
	PatchApi217HardwareConnectorsWithBodyWithResponse(ctx context.Context, params *PatchApi217HardwareConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217HardwareConnectorsResponse, error)

	PatchApi217HardwareConnectorsWithResponse(ctx context.Context, params *PatchApi217HardwareConnectorsParams, body PatchApi217HardwareConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217HardwareConnectorsResponse, error)

	// GetApi217HardwareConnectorsPerformanceWithResponse request
	GetApi217HardwareConnectorsPerformanceWithResponse(ctx context.Context, params *GetApi217HardwareConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217HardwareConnectorsPerformanceResponse, error)

	// DeleteApi217KeytabsWithResponse request
	DeleteApi217KeytabsWithResponse(ctx context.Context, params *DeleteApi217KeytabsParams, reqEditors ...RequestEditorFn) (*DeleteApi217KeytabsResponse, error)

	// GetApi217KeytabsWithResponse request
	GetApi217KeytabsWithResponse(ctx context.Context, params *GetApi217KeytabsParams, reqEditors ...RequestEditorFn) (*GetApi217KeytabsResponse, error)

	// PostApi217KeytabsWithBodyWithResponse request with any body
	PostApi217KeytabsWithBodyWithResponse(ctx context.Context, params *PostApi217KeytabsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217KeytabsResponse, error)

	PostApi217KeytabsWithResponse(ctx context.Context, params *PostApi217KeytabsParams, body PostApi217KeytabsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217KeytabsResponse, error)

	// GetApi217KeytabsDownloadWithResponse request
	GetApi217KeytabsDownloadWithResponse(ctx context.Context, params *GetApi217KeytabsDownloadParams, reqEditors ...RequestEditorFn) (*GetApi217KeytabsDownloadResponse, error)

	// PostApi217KeytabsUploadWithBodyWithResponse request with any body
	PostApi217KeytabsUploadWithBodyWithResponse(ctx context.Context, params *PostApi217KeytabsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217KeytabsUploadResponse, error)

	// DeleteApi217KmipWithResponse request
	DeleteApi217KmipWithResponse(ctx context.Context, params *DeleteApi217KmipParams, reqEditors ...RequestEditorFn) (*DeleteApi217KmipResponse, error)

	// GetApi217KmipWithResponse request
	GetApi217KmipWithResponse(ctx context.Context, params *GetApi217KmipParams, reqEditors ...RequestEditorFn) (*GetApi217KmipResponse, error)

	// PatchApi217KmipWithBodyWithResponse request with any body
	PatchApi217KmipWithBodyWithResponse(ctx context.Context, params *PatchApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217KmipResponse, error)

	PatchApi217KmipWithResponse(ctx context.Context, params *PatchApi217KmipParams, body PatchApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217KmipResponse, error)

	// PostApi217KmipWithBodyWithResponse request with any body
	PostApi217KmipWithBodyWithResponse(ctx context.Context, params *PostApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217KmipResponse, error)

	PostApi217KmipWithResponse(ctx context.Context, params *PostApi217KmipParams, body PostApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217KmipResponse, error)

	// GetApi217KmipTestWithResponse request
	GetApi217KmipTestWithResponse(ctx context.Context, params *GetApi217KmipTestParams, reqEditors ...RequestEditorFn) (*GetApi217KmipTestResponse, error)

	// DeleteApi217LegalHoldsWithResponse request
	DeleteApi217LegalHoldsWithResponse(ctx context.Context, params *DeleteApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*DeleteApi217LegalHoldsResponse, error)

	// GetApi217LegalHoldsWithResponse request
	GetApi217LegalHoldsWithResponse(ctx context.Context, params *GetApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*GetApi217LegalHoldsResponse, error)

	// PatchApi217LegalHoldsWithBodyWithResponse request with any body
	PatchApi217LegalHoldsWithBodyWithResponse(ctx context.Context, params *PatchApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LegalHoldsResponse, error)

	PatchApi217LegalHoldsWithResponse(ctx context.Context, params *PatchApi217LegalHoldsParams, body PatchApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LegalHoldsResponse, error)

	// PostApi217LegalHoldsWithBodyWithResponse request with any body
	PostApi217LegalHoldsWithBodyWithResponse(ctx context.Context, params *PostApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217LegalHoldsResponse, error)

	PostApi217LegalHoldsWithResponse(ctx context.Context, params *PostApi217LegalHoldsParams, body PostApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217LegalHoldsResponse, error)

	// GetApi217LegalHoldsHeldEntitiesWithResponse request
	GetApi217LegalHoldsHeldEntitiesWithResponse(ctx context.Context, params *GetApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*GetApi217LegalHoldsHeldEntitiesResponse, error)

	// PatchApi217LegalHoldsHeldEntitiesWithResponse request
	PatchApi217LegalHoldsHeldEntitiesWithResponse(ctx context.Context, params *PatchApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*PatchApi217LegalHoldsHeldEntitiesResponse, error)

	// PostApi217LegalHoldsHeldEntitiesWithResponse request
	PostApi217LegalHoldsHeldEntitiesWithResponse(ctx context.Context, params *PostApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*PostApi217LegalHoldsHeldEntitiesResponse, error)

	// DeleteApi217LifecycleRulesWithResponse request
	DeleteApi217LifecycleRulesWithResponse(ctx context.Context, params *DeleteApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217LifecycleRulesResponse, error)

	// GetApi217LifecycleRulesWithResponse request
	GetApi217LifecycleRulesWithResponse(ctx context.Context, params *GetApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*GetApi217LifecycleRulesResponse, error)

	// PatchApi217LifecycleRulesWithBodyWithResponse request with any body
	PatchApi217LifecycleRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LifecycleRulesResponse, error)

	PatchApi217LifecycleRulesWithResponse(ctx context.Context, params *PatchApi217LifecycleRulesParams, body PatchApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LifecycleRulesResponse, error)

	// PostApi217LifecycleRulesWithBodyWithResponse request with any body
	PostApi217LifecycleRulesWithBodyWithResponse(ctx context.Context, params *PostApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217LifecycleRulesResponse, error)

	PostApi217LifecycleRulesWithResponse(ctx context.Context, params *PostApi217LifecycleRulesParams, body PostApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217LifecycleRulesResponse, error)

	// DeleteApi217LinkAggregationGroupsWithResponse request
	DeleteApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *DeleteApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217LinkAggregationGroupsResponse, error)

	// GetApi217LinkAggregationGroupsWithResponse request
	GetApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *GetApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217LinkAggregationGroupsResponse, error)

	// PatchApi217LinkAggregationGroupsWithBodyWithResponse request with any body
	PatchApi217LinkAggregationGroupsWithBodyWithResponse(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LinkAggregationGroupsResponse, error)

	PatchApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, body PatchApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LinkAggregationGroupsResponse, error)

	// PostApi217LinkAggregationGroupsWithBodyWithResponse request with any body
	PostApi217LinkAggregationGroupsWithBodyWithResponse(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217LinkAggregationGroupsResponse, error)

	PostApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, body PostApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217LinkAggregationGroupsResponse, error)

	// GetApi217LogsWithResponse request
	GetApi217LogsWithResponse(ctx context.Context, params *GetApi217LogsParams, reqEditors ...RequestEditorFn) (*GetApi217LogsResponse, error)

	// GetApi217LogsAsyncWithResponse request
	GetApi217LogsAsyncWithResponse(ctx context.Context, params *GetApi217LogsAsyncParams, reqEditors ...RequestEditorFn) (*GetApi217LogsAsyncResponse, error)

	// PatchApi217LogsAsyncWithBodyWithResponse request with any body
	PatchApi217LogsAsyncWithBodyWithResponse(ctx context.Context, params *PatchApi217LogsAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LogsAsyncResponse, error)

	PatchApi217LogsAsyncWithResponse(ctx context.Context, params *PatchApi217LogsAsyncParams, body PatchApi217LogsAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LogsAsyncResponse, error)

	// GetApi217LogsAsyncDownloadWithResponse request
	GetApi217LogsAsyncDownloadWithResponse(ctx context.Context, params *GetApi217LogsAsyncDownloadParams, reqEditors ...RequestEditorFn) (*GetApi217LogsAsyncDownloadResponse, error)

	// DeleteApi217MaintenanceWindowsWithResponse request
	DeleteApi217MaintenanceWindowsWithResponse(ctx context.Context, params *DeleteApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*DeleteApi217MaintenanceWindowsResponse, error)

	// GetApi217MaintenanceWindowsWithResponse request
	GetApi217MaintenanceWindowsWithResponse(ctx context.Context, params *GetApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*GetApi217MaintenanceWindowsResponse, error)

	// PostApi217MaintenanceWindowsWithBodyWithResponse request with any body
	PostApi217MaintenanceWindowsWithBodyWithResponse(ctx context.Context, params *PostApi217MaintenanceWindowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217MaintenanceWindowsResponse, error)

	PostApi217MaintenanceWindowsWithResponse(ctx context.Context, params *PostApi217MaintenanceWindowsParams, body PostApi217MaintenanceWindowsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217MaintenanceWindowsResponse, error)

	// GetApi217NetworkAccessPoliciesWithResponse request
	GetApi217NetworkAccessPoliciesWithResponse(ctx context.Context, params *GetApi217NetworkAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkAccessPoliciesResponse, error)

	// PatchApi217NetworkAccessPoliciesWithBodyWithResponse request with any body
	PatchApi217NetworkAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesResponse, error)

	PatchApi217NetworkAccessPoliciesWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, body PatchApi217NetworkAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesResponse, error)

	// GetApi217NetworkAccessPoliciesMembersWithResponse request
	GetApi217NetworkAccessPoliciesMembersWithResponse(ctx context.Context, params *GetApi217NetworkAccessPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkAccessPoliciesMembersResponse, error)

	// DeleteApi217NetworkAccessPoliciesRulesWithResponse request
	DeleteApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NetworkAccessPoliciesRulesResponse, error)

	// GetApi217NetworkAccessPoliciesRulesWithResponse request
	GetApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *GetApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkAccessPoliciesRulesResponse, error)

	// PatchApi217NetworkAccessPoliciesRulesWithBodyWithResponse request with any body
	PatchApi217NetworkAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesRulesResponse, error)

	PatchApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, body PatchApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesRulesResponse, error)

	// PostApi217NetworkAccessPoliciesRulesWithBodyWithResponse request with any body
	PostApi217NetworkAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NetworkAccessPoliciesRulesResponse, error)

	PostApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, body PostApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NetworkAccessPoliciesRulesResponse, error)

	// DeleteApi217NetworkInterfacesWithResponse request
	DeleteApi217NetworkInterfacesWithResponse(ctx context.Context, params *DeleteApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NetworkInterfacesResponse, error)

	// GetApi217NetworkInterfacesWithResponse request
	GetApi217NetworkInterfacesWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesResponse, error)

	// PatchApi217NetworkInterfacesWithBodyWithResponse request with any body
	PatchApi217NetworkInterfacesWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesResponse, error)

	PatchApi217NetworkInterfacesWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesParams, body PatchApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesResponse, error)

	// PostApi217NetworkInterfacesWithBodyWithResponse request with any body
	PostApi217NetworkInterfacesWithBodyWithResponse(ctx context.Context, params *PostApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NetworkInterfacesResponse, error)

	PostApi217NetworkInterfacesWithResponse(ctx context.Context, params *PostApi217NetworkInterfacesParams, body PostApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NetworkInterfacesResponse, error)

	// GetApi217NetworkInterfacesConnectorsWithResponse request
	GetApi217NetworkInterfacesConnectorsWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesConnectorsResponse, error)

	// PatchApi217NetworkInterfacesConnectorsWithBodyWithResponse request with any body
	PatchApi217NetworkInterfacesConnectorsWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesConnectorsResponse, error)

	PatchApi217NetworkInterfacesConnectorsWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, body PatchApi217NetworkInterfacesConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesConnectorsResponse, error)

	// GetApi217NetworkInterfacesConnectorsPerformanceWithResponse request
	GetApi217NetworkInterfacesConnectorsPerformanceWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesConnectorsPerformanceResponse, error)

	// GetApi217NetworkInterfacesConnectorsSettingsWithResponse request
	GetApi217NetworkInterfacesConnectorsSettingsWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesConnectorsSettingsResponse, error)

	// GetApi217NetworkInterfacesPingWithResponse request
	GetApi217NetworkInterfacesPingWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesPingParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesPingResponse, error)

	// DeleteApi217NetworkInterfacesTlsPoliciesWithResponse request
	DeleteApi217NetworkInterfacesTlsPoliciesWithResponse(ctx context.Context, params *DeleteApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NetworkInterfacesTlsPoliciesResponse, error)

	// GetApi217NetworkInterfacesTlsPoliciesWithResponse request
	GetApi217NetworkInterfacesTlsPoliciesWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesTlsPoliciesResponse, error)

	// PostApi217NetworkInterfacesTlsPoliciesWithResponse request
	PostApi217NetworkInterfacesTlsPoliciesWithResponse(ctx context.Context, params *PostApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217NetworkInterfacesTlsPoliciesResponse, error)

	// GetApi217NetworkInterfacesTraceWithResponse request
	GetApi217NetworkInterfacesTraceWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesTraceParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesTraceResponse, error)

	// DeleteApi217NfsExportPoliciesWithResponse request
	DeleteApi217NfsExportPoliciesWithResponse(ctx context.Context, params *DeleteApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NfsExportPoliciesResponse, error)

	// GetApi217NfsExportPoliciesWithResponse request
	GetApi217NfsExportPoliciesWithResponse(ctx context.Context, params *GetApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217NfsExportPoliciesResponse, error)

	// PatchApi217NfsExportPoliciesWithBodyWithResponse request with any body
	PatchApi217NfsExportPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesResponse, error)

	PatchApi217NfsExportPoliciesWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, body PatchApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesResponse, error)

	// PostApi217NfsExportPoliciesWithBodyWithResponse request with any body
	PostApi217NfsExportPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesResponse, error)

	PostApi217NfsExportPoliciesWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesParams, body PostApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesResponse, error)

	// DeleteApi217NfsExportPoliciesRulesWithResponse request
	DeleteApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NfsExportPoliciesRulesResponse, error)

	// GetApi217NfsExportPoliciesRulesWithResponse request
	GetApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *GetApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217NfsExportPoliciesRulesResponse, error)

	// PatchApi217NfsExportPoliciesRulesWithBodyWithResponse request with any body
	PatchApi217NfsExportPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesRulesResponse, error)

	PatchApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, body PatchApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesRulesResponse, error)

	// PostApi217NfsExportPoliciesRulesWithBodyWithResponse request with any body
	PostApi217NfsExportPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesRulesResponse, error)

	PostApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, body PostApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesRulesResponse, error)

	// DeleteApi217ObjectStoreAccessKeysWithResponse request
	DeleteApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessKeysResponse, error)

	// GetApi217ObjectStoreAccessKeysWithResponse request
	GetApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessKeysResponse, error)

	// PatchApi217ObjectStoreAccessKeysWithBodyWithResponse request with any body
	PatchApi217ObjectStoreAccessKeysWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessKeysResponse, error)

	PatchApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, body PatchApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessKeysResponse, error)

	// PostApi217ObjectStoreAccessKeysWithBodyWithResponse request with any body
	PostApi217ObjectStoreAccessKeysWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessKeysResponse, error)

	PostApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, body PostApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessKeysResponse, error)

	// DeleteApi217ObjectStoreAccessPoliciesWithResponse request
	DeleteApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesResponse, error)

	// GetApi217ObjectStoreAccessPoliciesWithResponse request
	GetApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesResponse, error)

	// PatchApi217ObjectStoreAccessPoliciesWithBodyWithResponse request with any body
	PatchApi217ObjectStoreAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesResponse, error)

	PatchApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, body PatchApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesResponse, error)

	// PostApi217ObjectStoreAccessPoliciesWithBodyWithResponse request with any body
	PostApi217ObjectStoreAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesResponse, error)

	PostApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, body PostApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesResponse, error)

	// DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse request
	DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error)

	// GetApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse request
	GetApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error)

	// PostApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse request
	PostApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error)

	// DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse request
	DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error)

	// GetApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse request
	GetApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error)

	// PostApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse request
	PostApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error)

	// DeleteApi217ObjectStoreAccessPoliciesRulesWithResponse request
	DeleteApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesRulesResponse, error)

	// GetApi217ObjectStoreAccessPoliciesRulesWithResponse request
	GetApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesRulesResponse, error)

	// PatchApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse request with any body
	PatchApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesRulesResponse, error)

	PatchApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, body PatchApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesRulesResponse, error)

	// PostApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse request with any body
	PostApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesRulesResponse, error)

	PostApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, body PostApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesRulesResponse, error)

	// GetApi217ObjectStoreAccessPolicyActionsWithResponse request
	GetApi217ObjectStoreAccessPolicyActionsWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPolicyActionsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPolicyActionsResponse, error)

	// DeleteApi217ObjectStoreAccountsWithResponse request
	DeleteApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccountsResponse, error)

	// GetApi217ObjectStoreAccountsWithResponse request
	GetApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccountsResponse, error)

	// PatchApi217ObjectStoreAccountsWithBodyWithResponse request with any body
	PatchApi217ObjectStoreAccountsWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccountsResponse, error)

	PatchApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, body PatchApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccountsResponse, error)

	// PostApi217ObjectStoreAccountsWithBodyWithResponse request with any body
	PostApi217ObjectStoreAccountsWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccountsResponse, error)

	PostApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, body PostApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccountsResponse, error)

	// DeleteApi217ObjectStoreRemoteCredentialsWithResponse request
	DeleteApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRemoteCredentialsResponse, error)

	// GetApi217ObjectStoreRemoteCredentialsWithResponse request
	GetApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *GetApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRemoteCredentialsResponse, error)

	// PatchApi217ObjectStoreRemoteCredentialsWithBodyWithResponse request with any body
	PatchApi217ObjectStoreRemoteCredentialsWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRemoteCredentialsResponse, error)

	PatchApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, body PatchApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRemoteCredentialsResponse, error)

	// PostApi217ObjectStoreRemoteCredentialsWithBodyWithResponse request with any body
	PostApi217ObjectStoreRemoteCredentialsWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRemoteCredentialsResponse, error)

	PostApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, body PostApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRemoteCredentialsResponse, error)

	// DeleteApi217ObjectStoreRolesWithResponse request
	DeleteApi217ObjectStoreRolesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRolesResponse, error)

	// GetApi217ObjectStoreRolesWithResponse request
	GetApi217ObjectStoreRolesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesResponse, error)

	// PatchApi217ObjectStoreRolesWithBodyWithResponse request with any body
	PatchApi217ObjectStoreRolesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesResponse, error)

	PatchApi217ObjectStoreRolesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, body PatchApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesResponse, error)

	// PostApi217ObjectStoreRolesWithBodyWithResponse request with any body
	PostApi217ObjectStoreRolesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesResponse, error)

	PostApi217ObjectStoreRolesWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesParams, body PostApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesResponse, error)

	// DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse request
	DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error)

	// GetApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse request
	GetApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error)

	// PostApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse request
	PostApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error)

	// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesWithResponse request
	GetApi217ObjectStoreRolesObjectStoreTrustPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse, error)

	// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadWithResponse request
	GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse, error)

	// DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse request
	DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error)

	// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse request
	GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error)

	// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse request with any body
	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error)

	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error)

	// PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse request with any body
	PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error)

	PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error)

	// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBodyWithResponse request with any body
	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse, error)

	PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse, error)

	// DeleteApi217ObjectStoreUsersWithResponse request
	DeleteApi217ObjectStoreUsersWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreUsersResponse, error)

	// GetApi217ObjectStoreUsersWithResponse request
	GetApi217ObjectStoreUsersWithResponse(ctx context.Context, params *GetApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreUsersResponse, error)

	// PostApi217ObjectStoreUsersWithResponse request
	PostApi217ObjectStoreUsersWithResponse(ctx context.Context, params *PostApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreUsersResponse, error)

	// DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse request
	DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error)

	// GetApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse request
	GetApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error)

	// PostApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse request
	PostApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PostApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error)

	// DeleteApi217ObjectStoreVirtualHostsWithResponse request
	DeleteApi217ObjectStoreVirtualHostsWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreVirtualHostsResponse, error)

	// GetApi217ObjectStoreVirtualHostsWithResponse request
	GetApi217ObjectStoreVirtualHostsWithResponse(ctx context.Context, params *GetApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreVirtualHostsResponse, error)

	// PostApi217ObjectStoreVirtualHostsWithResponse request
	PostApi217ObjectStoreVirtualHostsWithResponse(ctx context.Context, params *PostApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreVirtualHostsResponse, error)

	// GetApi217PasswordPoliciesWithResponse request
	GetApi217PasswordPoliciesWithResponse(ctx context.Context, params *GetApi217PasswordPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217PasswordPoliciesResponse, error)

	// PatchApi217PasswordPoliciesWithBodyWithResponse request with any body
	PatchApi217PasswordPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217PasswordPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217PasswordPoliciesResponse, error)

	PatchApi217PasswordPoliciesWithResponse(ctx context.Context, params *PatchApi217PasswordPoliciesParams, body PatchApi217PasswordPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217PasswordPoliciesResponse, error)

	// DeleteApi217PoliciesWithResponse request
	DeleteApi217PoliciesWithResponse(ctx context.Context, params *DeleteApi217PoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesResponse, error)

	// GetApi217PoliciesWithResponse request
	GetApi217PoliciesWithResponse(ctx context.Context, params *GetApi217PoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesResponse, error)

	// PatchApi217PoliciesWithBodyWithResponse request with any body
	PatchApi217PoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217PoliciesResponse, error)

	PatchApi217PoliciesWithResponse(ctx context.Context, params *PatchApi217PoliciesParams, body PatchApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217PoliciesResponse, error)

	// PostApi217PoliciesWithBodyWithResponse request with any body
	PostApi217PoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217PoliciesResponse, error)

	PostApi217PoliciesWithResponse(ctx context.Context, params *PostApi217PoliciesParams, body PostApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217PoliciesResponse, error)

	// GetApi217PoliciesAllWithResponse request
	GetApi217PoliciesAllWithResponse(ctx context.Context, params *GetApi217PoliciesAllParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesAllResponse, error)

	// GetApi217PoliciesAllMembersWithResponse request
	GetApi217PoliciesAllMembersWithResponse(ctx context.Context, params *GetApi217PoliciesAllMembersParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesAllMembersResponse, error)

	// DeleteApi217PoliciesFileSystemReplicaLinksWithResponse request
	DeleteApi217PoliciesFileSystemReplicaLinksWithResponse(ctx context.Context, params *DeleteApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesFileSystemReplicaLinksResponse, error)

	// GetApi217PoliciesFileSystemReplicaLinksWithResponse request
	GetApi217PoliciesFileSystemReplicaLinksWithResponse(ctx context.Context, params *GetApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesFileSystemReplicaLinksResponse, error)

	// PostApi217PoliciesFileSystemReplicaLinksWithResponse request
	PostApi217PoliciesFileSystemReplicaLinksWithResponse(ctx context.Context, params *PostApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*PostApi217PoliciesFileSystemReplicaLinksResponse, error)

	// DeleteApi217PoliciesFileSystemSnapshotsWithResponse request
	DeleteApi217PoliciesFileSystemSnapshotsWithResponse(ctx context.Context, params *DeleteApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesFileSystemSnapshotsResponse, error)

	// GetApi217PoliciesFileSystemSnapshotsWithResponse request
	GetApi217PoliciesFileSystemSnapshotsWithResponse(ctx context.Context, params *GetApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesFileSystemSnapshotsResponse, error)

	// DeleteApi217PoliciesFileSystemsWithResponse request
	DeleteApi217PoliciesFileSystemsWithResponse(ctx context.Context, params *DeleteApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesFileSystemsResponse, error)

	// GetApi217PoliciesFileSystemsWithResponse request
	GetApi217PoliciesFileSystemsWithResponse(ctx context.Context, params *GetApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesFileSystemsResponse, error)

	// PostApi217PoliciesFileSystemsWithResponse request
	PostApi217PoliciesFileSystemsWithResponse(ctx context.Context, params *PostApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*PostApi217PoliciesFileSystemsResponse, error)

	// GetApi217PoliciesMembersWithResponse request
	GetApi217PoliciesMembersWithResponse(ctx context.Context, params *GetApi217PoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesMembersResponse, error)

	// DeleteApi217PublicKeysWithResponse request
	DeleteApi217PublicKeysWithResponse(ctx context.Context, params *DeleteApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*DeleteApi217PublicKeysResponse, error)

	// GetApi217PublicKeysWithResponse request
	GetApi217PublicKeysWithResponse(ctx context.Context, params *GetApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*GetApi217PublicKeysResponse, error)

	// PostApi217PublicKeysWithBodyWithResponse request with any body
	PostApi217PublicKeysWithBodyWithResponse(ctx context.Context, params *PostApi217PublicKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217PublicKeysResponse, error)

	PostApi217PublicKeysWithResponse(ctx context.Context, params *PostApi217PublicKeysParams, body PostApi217PublicKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217PublicKeysResponse, error)

	// GetApi217PublicKeysUsesWithResponse request
	GetApi217PublicKeysUsesWithResponse(ctx context.Context, params *GetApi217PublicKeysUsesParams, reqEditors ...RequestEditorFn) (*GetApi217PublicKeysUsesResponse, error)

	// DeleteApi217QosPoliciesWithResponse request
	DeleteApi217QosPoliciesWithResponse(ctx context.Context, params *DeleteApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217QosPoliciesResponse, error)

	// GetApi217QosPoliciesWithResponse request
	GetApi217QosPoliciesWithResponse(ctx context.Context, params *GetApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217QosPoliciesResponse, error)

	// PatchApi217QosPoliciesWithBodyWithResponse request with any body
	PatchApi217QosPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QosPoliciesResponse, error)

	PatchApi217QosPoliciesWithResponse(ctx context.Context, params *PatchApi217QosPoliciesParams, body PatchApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QosPoliciesResponse, error)

	// PostApi217QosPoliciesWithBodyWithResponse request with any body
	PostApi217QosPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217QosPoliciesResponse, error)

	PostApi217QosPoliciesWithResponse(ctx context.Context, params *PostApi217QosPoliciesParams, body PostApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217QosPoliciesResponse, error)

	// GetApi217QosPoliciesFileSystemsWithResponse request
	GetApi217QosPoliciesFileSystemsWithResponse(ctx context.Context, params *GetApi217QosPoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*GetApi217QosPoliciesFileSystemsResponse, error)

	// GetApi217QosPoliciesMembersWithResponse request
	GetApi217QosPoliciesMembersWithResponse(ctx context.Context, params *GetApi217QosPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217QosPoliciesMembersResponse, error)

	// DeleteApi217QuotasGroupsWithResponse request
	DeleteApi217QuotasGroupsWithResponse(ctx context.Context, params *DeleteApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217QuotasGroupsResponse, error)

	// GetApi217QuotasGroupsWithResponse request
	GetApi217QuotasGroupsWithResponse(ctx context.Context, params *GetApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217QuotasGroupsResponse, error)

	// PatchApi217QuotasGroupsWithBodyWithResponse request with any body
	PatchApi217QuotasGroupsWithBodyWithResponse(ctx context.Context, params *PatchApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QuotasGroupsResponse, error)

	PatchApi217QuotasGroupsWithResponse(ctx context.Context, params *PatchApi217QuotasGroupsParams, body PatchApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QuotasGroupsResponse, error)

	// PostApi217QuotasGroupsWithBodyWithResponse request with any body
	PostApi217QuotasGroupsWithBodyWithResponse(ctx context.Context, params *PostApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217QuotasGroupsResponse, error)

	PostApi217QuotasGroupsWithResponse(ctx context.Context, params *PostApi217QuotasGroupsParams, body PostApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217QuotasGroupsResponse, error)

	// GetApi217QuotasSettingsWithResponse request
	GetApi217QuotasSettingsWithResponse(ctx context.Context, params *GetApi217QuotasSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217QuotasSettingsResponse, error)

	// PatchApi217QuotasSettingsWithBodyWithResponse request with any body
	PatchApi217QuotasSettingsWithBodyWithResponse(ctx context.Context, params *PatchApi217QuotasSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QuotasSettingsResponse, error)

	PatchApi217QuotasSettingsWithResponse(ctx context.Context, params *PatchApi217QuotasSettingsParams, body PatchApi217QuotasSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QuotasSettingsResponse, error)

	// DeleteApi217QuotasUsersWithResponse request
	DeleteApi217QuotasUsersWithResponse(ctx context.Context, params *DeleteApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*DeleteApi217QuotasUsersResponse, error)

	// GetApi217QuotasUsersWithResponse request
	GetApi217QuotasUsersWithResponse(ctx context.Context, params *GetApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*GetApi217QuotasUsersResponse, error)

	// PatchApi217QuotasUsersWithBodyWithResponse request with any body
	PatchApi217QuotasUsersWithBodyWithResponse(ctx context.Context, params *PatchApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QuotasUsersResponse, error)

	PatchApi217QuotasUsersWithResponse(ctx context.Context, params *PatchApi217QuotasUsersParams, body PatchApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QuotasUsersResponse, error)

	// PostApi217QuotasUsersWithBodyWithResponse request with any body
	PostApi217QuotasUsersWithBodyWithResponse(ctx context.Context, params *PostApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217QuotasUsersResponse, error)

	PostApi217QuotasUsersWithResponse(ctx context.Context, params *PostApi217QuotasUsersParams, body PostApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217QuotasUsersResponse, error)

	// GetApi217RapidDataLockingWithResponse request
	GetApi217RapidDataLockingWithResponse(ctx context.Context, params *GetApi217RapidDataLockingParams, reqEditors ...RequestEditorFn) (*GetApi217RapidDataLockingResponse, error)

	// PatchApi217RapidDataLockingWithBodyWithResponse request with any body
	PatchApi217RapidDataLockingWithBodyWithResponse(ctx context.Context, params *PatchApi217RapidDataLockingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217RapidDataLockingResponse, error)

	PatchApi217RapidDataLockingWithResponse(ctx context.Context, params *PatchApi217RapidDataLockingParams, body PatchApi217RapidDataLockingJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217RapidDataLockingResponse, error)

	// PostApi217RapidDataLockingRotateWithResponse request
	PostApi217RapidDataLockingRotateWithResponse(ctx context.Context, params *PostApi217RapidDataLockingRotateParams, reqEditors ...RequestEditorFn) (*PostApi217RapidDataLockingRotateResponse, error)

	// GetApi217RapidDataLockingTestWithResponse request
	GetApi217RapidDataLockingTestWithResponse(ctx context.Context, params *GetApi217RapidDataLockingTestParams, reqEditors ...RequestEditorFn) (*GetApi217RapidDataLockingTestResponse, error)

	// GetApi217RemoteArraysWithResponse request
	GetApi217RemoteArraysWithResponse(ctx context.Context, params *GetApi217RemoteArraysParams, reqEditors ...RequestEditorFn) (*GetApi217RemoteArraysResponse, error)

	// GetApi217RolesWithResponse request
	GetApi217RolesWithResponse(ctx context.Context, params *GetApi217RolesParams, reqEditors ...RequestEditorFn) (*GetApi217RolesResponse, error)

	// DeleteApi217ServersWithResponse request
	DeleteApi217ServersWithResponse(ctx context.Context, params *DeleteApi217ServersParams, reqEditors ...RequestEditorFn) (*DeleteApi217ServersResponse, error)

	// GetApi217ServersWithResponse request
	GetApi217ServersWithResponse(ctx context.Context, params *GetApi217ServersParams, reqEditors ...RequestEditorFn) (*GetApi217ServersResponse, error)

	// PatchApi217ServersWithBodyWithResponse request with any body
	PatchApi217ServersWithBodyWithResponse(ctx context.Context, params *PatchApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ServersResponse, error)

	PatchApi217ServersWithResponse(ctx context.Context, params *PatchApi217ServersParams, body PatchApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ServersResponse, error)

	// PostApi217ServersWithBodyWithResponse request with any body
	PostApi217ServersWithBodyWithResponse(ctx context.Context, params *PostApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ServersResponse, error)

	PostApi217ServersWithResponse(ctx context.Context, params *PostApi217ServersParams, body PostApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ServersResponse, error)

	// GetApi217SessionsWithResponse request
	GetApi217SessionsWithResponse(ctx context.Context, params *GetApi217SessionsParams, reqEditors ...RequestEditorFn) (*GetApi217SessionsResponse, error)

	// DeleteApi217SmbClientPoliciesWithResponse request
	DeleteApi217SmbClientPoliciesWithResponse(ctx context.Context, params *DeleteApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbClientPoliciesResponse, error)

	// GetApi217SmbClientPoliciesWithResponse request
	GetApi217SmbClientPoliciesWithResponse(ctx context.Context, params *GetApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbClientPoliciesResponse, error)

	// PatchApi217SmbClientPoliciesWithBodyWithResponse request with any body
	PatchApi217SmbClientPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesResponse, error)

	PatchApi217SmbClientPoliciesWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, body PatchApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesResponse, error)

	// PostApi217SmbClientPoliciesWithBodyWithResponse request with any body
	PostApi217SmbClientPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesResponse, error)

	PostApi217SmbClientPoliciesWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesParams, body PostApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesResponse, error)

	// DeleteApi217SmbClientPoliciesRulesWithResponse request
	DeleteApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbClientPoliciesRulesResponse, error)

	// GetApi217SmbClientPoliciesRulesWithResponse request
	GetApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *GetApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbClientPoliciesRulesResponse, error)

	// PatchApi217SmbClientPoliciesRulesWithBodyWithResponse request with any body
	PatchApi217SmbClientPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesRulesResponse, error)

	PatchApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, body PatchApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesRulesResponse, error)

	// PostApi217SmbClientPoliciesRulesWithBodyWithResponse request with any body
	PostApi217SmbClientPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesRulesResponse, error)

	PostApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, body PostApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesRulesResponse, error)

	// DeleteApi217SmbSharePoliciesWithResponse request
	DeleteApi217SmbSharePoliciesWithResponse(ctx context.Context, params *DeleteApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbSharePoliciesResponse, error)

	// GetApi217SmbSharePoliciesWithResponse request
	GetApi217SmbSharePoliciesWithResponse(ctx context.Context, params *GetApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbSharePoliciesResponse, error)

	// PatchApi217SmbSharePoliciesWithBodyWithResponse request with any body
	PatchApi217SmbSharePoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesResponse, error)

	PatchApi217SmbSharePoliciesWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, body PatchApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesResponse, error)

	// PostApi217SmbSharePoliciesWithBodyWithResponse request with any body
	PostApi217SmbSharePoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesResponse, error)

	PostApi217SmbSharePoliciesWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesParams, body PostApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesResponse, error)

	// DeleteApi217SmbSharePoliciesRulesWithResponse request
	DeleteApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbSharePoliciesRulesResponse, error)

	// GetApi217SmbSharePoliciesRulesWithResponse request
	GetApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *GetApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbSharePoliciesRulesResponse, error)

	// PatchApi217SmbSharePoliciesRulesWithBodyWithResponse request with any body
	PatchApi217SmbSharePoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesRulesResponse, error)

	PatchApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, body PatchApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesRulesResponse, error)

	// PostApi217SmbSharePoliciesRulesWithBodyWithResponse request with any body
	PostApi217SmbSharePoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesRulesResponse, error)

	PostApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, body PostApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesRulesResponse, error)

	// GetApi217SmtpServersWithResponse request
	GetApi217SmtpServersWithResponse(ctx context.Context, params *GetApi217SmtpServersParams, reqEditors ...RequestEditorFn) (*GetApi217SmtpServersResponse, error)

	// PatchApi217SmtpServersWithBodyWithResponse request with any body
	PatchApi217SmtpServersWithBodyWithResponse(ctx context.Context, params *PatchApi217SmtpServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmtpServersResponse, error)

	PatchApi217SmtpServersWithResponse(ctx context.Context, params *PatchApi217SmtpServersParams, body PatchApi217SmtpServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmtpServersResponse, error)

	// GetApi217SnmpAgentsWithResponse request
	GetApi217SnmpAgentsWithResponse(ctx context.Context, params *GetApi217SnmpAgentsParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpAgentsResponse, error)

	// PatchApi217SnmpAgentsWithBodyWithResponse request with any body
	PatchApi217SnmpAgentsWithBodyWithResponse(ctx context.Context, params *PatchApi217SnmpAgentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SnmpAgentsResponse, error)

	PatchApi217SnmpAgentsWithResponse(ctx context.Context, params *PatchApi217SnmpAgentsParams, body PatchApi217SnmpAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SnmpAgentsResponse, error)

	// GetApi217SnmpAgentsMibWithResponse request
	GetApi217SnmpAgentsMibWithResponse(ctx context.Context, params *GetApi217SnmpAgentsMibParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpAgentsMibResponse, error)

	// DeleteApi217SnmpManagersWithResponse request
	DeleteApi217SnmpManagersWithResponse(ctx context.Context, params *DeleteApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*DeleteApi217SnmpManagersResponse, error)

	// GetApi217SnmpManagersWithResponse request
	GetApi217SnmpManagersWithResponse(ctx context.Context, params *GetApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpManagersResponse, error)

	// PatchApi217SnmpManagersWithBodyWithResponse request with any body
	PatchApi217SnmpManagersWithBodyWithResponse(ctx context.Context, params *PatchApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SnmpManagersResponse, error)

	PatchApi217SnmpManagersWithResponse(ctx context.Context, params *PatchApi217SnmpManagersParams, body PatchApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SnmpManagersResponse, error)

	// PostApi217SnmpManagersWithBodyWithResponse request with any body
	PostApi217SnmpManagersWithBodyWithResponse(ctx context.Context, params *PostApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SnmpManagersResponse, error)

	PostApi217SnmpManagersWithResponse(ctx context.Context, params *PostApi217SnmpManagersParams, body PostApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SnmpManagersResponse, error)

	// GetApi217SnmpManagersTestWithResponse request
	GetApi217SnmpManagersTestWithResponse(ctx context.Context, params *GetApi217SnmpManagersTestParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpManagersTestResponse, error)

	// GetApi217SoftwareCheckWithResponse request
	GetApi217SoftwareCheckWithResponse(ctx context.Context, params *GetApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*GetApi217SoftwareCheckResponse, error)

	// PostApi217SoftwareCheckWithResponse request
	PostApi217SoftwareCheckWithResponse(ctx context.Context, params *PostApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*PostApi217SoftwareCheckResponse, error)

	// DeleteApi217SshCertificateAuthorityPoliciesWithResponse request
	DeleteApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SshCertificateAuthorityPoliciesResponse, error)

	// GetApi217SshCertificateAuthorityPoliciesWithResponse request
	GetApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesResponse, error)

	// PatchApi217SshCertificateAuthorityPoliciesWithBodyWithResponse request with any body
	PatchApi217SshCertificateAuthorityPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SshCertificateAuthorityPoliciesResponse, error)

	PatchApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, body PatchApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SshCertificateAuthorityPoliciesResponse, error)

	// PostApi217SshCertificateAuthorityPoliciesWithBodyWithResponse request with any body
	PostApi217SshCertificateAuthorityPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesResponse, error)

	PostApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, body PostApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesResponse, error)

	// DeleteApi217SshCertificateAuthorityPoliciesAdminsWithResponse request
	DeleteApi217SshCertificateAuthorityPoliciesAdminsWithResponse(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse, error)

	// GetApi217SshCertificateAuthorityPoliciesAdminsWithResponse request
	GetApi217SshCertificateAuthorityPoliciesAdminsWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesAdminsResponse, error)

	// PostApi217SshCertificateAuthorityPoliciesAdminsWithResponse request
	PostApi217SshCertificateAuthorityPoliciesAdminsWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesAdminsResponse, error)

	// DeleteApi217SshCertificateAuthorityPoliciesArraysWithResponse request
	DeleteApi217SshCertificateAuthorityPoliciesArraysWithResponse(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*DeleteApi217SshCertificateAuthorityPoliciesArraysResponse, error)

	// GetApi217SshCertificateAuthorityPoliciesArraysWithResponse request
	GetApi217SshCertificateAuthorityPoliciesArraysWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesArraysResponse, error)

	// PostApi217SshCertificateAuthorityPoliciesArraysWithResponse request
	PostApi217SshCertificateAuthorityPoliciesArraysWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesArraysResponse, error)

	// GetApi217SshCertificateAuthorityPoliciesMembersWithResponse request
	GetApi217SshCertificateAuthorityPoliciesMembersWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesMembersResponse, error)

	// DeleteApi217SsoOidcIdpsWithResponse request
	DeleteApi217SsoOidcIdpsWithResponse(ctx context.Context, params *DeleteApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SsoOidcIdpsResponse, error)

	// GetApi217SsoOidcIdpsWithResponse request
	GetApi217SsoOidcIdpsWithResponse(ctx context.Context, params *GetApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*GetApi217SsoOidcIdpsResponse, error)

	// PatchApi217SsoOidcIdpsWithBodyWithResponse request with any body
	PatchApi217SsoOidcIdpsWithBodyWithResponse(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SsoOidcIdpsResponse, error)

	PatchApi217SsoOidcIdpsWithResponse(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, body PatchApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SsoOidcIdpsResponse, error)

	// PostApi217SsoOidcIdpsWithBodyWithResponse request with any body
	PostApi217SsoOidcIdpsWithBodyWithResponse(ctx context.Context, params *PostApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SsoOidcIdpsResponse, error)

	PostApi217SsoOidcIdpsWithResponse(ctx context.Context, params *PostApi217SsoOidcIdpsParams, body PostApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SsoOidcIdpsResponse, error)

	// DeleteApi217SsoSaml2IdpsWithResponse request
	DeleteApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *DeleteApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SsoSaml2IdpsResponse, error)

	// GetApi217SsoSaml2IdpsWithResponse request
	GetApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *GetApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*GetApi217SsoSaml2IdpsResponse, error)

	// PatchApi217SsoSaml2IdpsWithBodyWithResponse request with any body
	PatchApi217SsoSaml2IdpsWithBodyWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsResponse, error)

	PatchApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, body PatchApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsResponse, error)

	// PostApi217SsoSaml2IdpsWithBodyWithResponse request with any body
	PostApi217SsoSaml2IdpsWithBodyWithResponse(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SsoSaml2IdpsResponse, error)

	PostApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, body PostApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SsoSaml2IdpsResponse, error)

	// GetApi217SsoSaml2IdpsTestWithResponse request
	GetApi217SsoSaml2IdpsTestWithResponse(ctx context.Context, params *GetApi217SsoSaml2IdpsTestParams, reqEditors ...RequestEditorFn) (*GetApi217SsoSaml2IdpsTestResponse, error)

	// PatchApi217SsoSaml2IdpsTestWithBodyWithResponse request with any body
	PatchApi217SsoSaml2IdpsTestWithBodyWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsTestResponse, error)

	PatchApi217SsoSaml2IdpsTestWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, body PatchApi217SsoSaml2IdpsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsTestResponse, error)

	// DeleteApi217SubnetsWithResponse request
	DeleteApi217SubnetsWithResponse(ctx context.Context, params *DeleteApi217SubnetsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SubnetsResponse, error)

	// GetApi217SubnetsWithResponse request
	GetApi217SubnetsWithResponse(ctx context.Context, params *GetApi217SubnetsParams, reqEditors ...RequestEditorFn) (*GetApi217SubnetsResponse, error)

	// PatchApi217SubnetsWithBodyWithResponse request with any body
	PatchApi217SubnetsWithBodyWithResponse(ctx context.Context, params *PatchApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SubnetsResponse, error)

	PatchApi217SubnetsWithResponse(ctx context.Context, params *PatchApi217SubnetsParams, body PatchApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SubnetsResponse, error)

	// PostApi217SubnetsWithBodyWithResponse request with any body
	PostApi217SubnetsWithBodyWithResponse(ctx context.Context, params *PostApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SubnetsResponse, error)

	PostApi217SubnetsWithResponse(ctx context.Context, params *PostApi217SubnetsParams, body PostApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SubnetsResponse, error)

	// GetApi217SupportWithResponse request
	GetApi217SupportWithResponse(ctx context.Context, params *GetApi217SupportParams, reqEditors ...RequestEditorFn) (*GetApi217SupportResponse, error)

	// PatchApi217SupportWithBodyWithResponse request with any body
	PatchApi217SupportWithBodyWithResponse(ctx context.Context, params *PatchApi217SupportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SupportResponse, error)

	PatchApi217SupportWithResponse(ctx context.Context, params *PatchApi217SupportParams, body PatchApi217SupportJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SupportResponse, error)

	// GetApi217SupportDiagnosticsWithResponse request
	GetApi217SupportDiagnosticsWithResponse(ctx context.Context, params *GetApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*GetApi217SupportDiagnosticsResponse, error)

	// PostApi217SupportDiagnosticsWithResponse request
	PostApi217SupportDiagnosticsWithResponse(ctx context.Context, params *PostApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*PostApi217SupportDiagnosticsResponse, error)

	// GetApi217SupportDiagnosticsDetailsWithResponse request
	GetApi217SupportDiagnosticsDetailsWithResponse(ctx context.Context, params *GetApi217SupportDiagnosticsDetailsParams, reqEditors ...RequestEditorFn) (*GetApi217SupportDiagnosticsDetailsResponse, error)

	// GetApi217SupportTestWithResponse request
	GetApi217SupportTestWithResponse(ctx context.Context, params *GetApi217SupportTestParams, reqEditors ...RequestEditorFn) (*GetApi217SupportTestResponse, error)

	// GetApi217SupportVerificationKeysWithResponse request
	GetApi217SupportVerificationKeysWithResponse(ctx context.Context, params *GetApi217SupportVerificationKeysParams, reqEditors ...RequestEditorFn) (*GetApi217SupportVerificationKeysResponse, error)

	// PatchApi217SupportVerificationKeysWithBodyWithResponse request with any body
	PatchApi217SupportVerificationKeysWithBodyWithResponse(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SupportVerificationKeysResponse, error)

	PatchApi217SupportVerificationKeysWithResponse(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, body PatchApi217SupportVerificationKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SupportVerificationKeysResponse, error)

	// DeleteApi217SyslogServersWithResponse request
	DeleteApi217SyslogServersWithResponse(ctx context.Context, params *DeleteApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*DeleteApi217SyslogServersResponse, error)

	// GetApi217SyslogServersWithResponse request
	GetApi217SyslogServersWithResponse(ctx context.Context, params *GetApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*GetApi217SyslogServersResponse, error)

	// PatchApi217SyslogServersWithBodyWithResponse request with any body
	PatchApi217SyslogServersWithBodyWithResponse(ctx context.Context, params *PatchApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersResponse, error)

	PatchApi217SyslogServersWithResponse(ctx context.Context, params *PatchApi217SyslogServersParams, body PatchApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersResponse, error)

	// PostApi217SyslogServersWithBodyWithResponse request with any body
	PostApi217SyslogServersWithBodyWithResponse(ctx context.Context, params *PostApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SyslogServersResponse, error)

	PostApi217SyslogServersWithResponse(ctx context.Context, params *PostApi217SyslogServersParams, body PostApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SyslogServersResponse, error)

	// GetApi217SyslogServersSettingsWithResponse request
	GetApi217SyslogServersSettingsWithResponse(ctx context.Context, params *GetApi217SyslogServersSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217SyslogServersSettingsResponse, error)

	// PatchApi217SyslogServersSettingsWithBodyWithResponse request with any body
	PatchApi217SyslogServersSettingsWithBodyWithResponse(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersSettingsResponse, error)

	PatchApi217SyslogServersSettingsWithResponse(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, body PatchApi217SyslogServersSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersSettingsResponse, error)

	// GetApi217SyslogServersTestWithResponse request
	GetApi217SyslogServersTestWithResponse(ctx context.Context, params *GetApi217SyslogServersTestParams, reqEditors ...RequestEditorFn) (*GetApi217SyslogServersTestResponse, error)

	// DeleteApi217TargetsWithResponse request
	DeleteApi217TargetsWithResponse(ctx context.Context, params *DeleteApi217TargetsParams, reqEditors ...RequestEditorFn) (*DeleteApi217TargetsResponse, error)

	// GetApi217TargetsWithResponse request
	GetApi217TargetsWithResponse(ctx context.Context, params *GetApi217TargetsParams, reqEditors ...RequestEditorFn) (*GetApi217TargetsResponse, error)

	// PatchApi217TargetsWithBodyWithResponse request with any body
	PatchApi217TargetsWithBodyWithResponse(ctx context.Context, params *PatchApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217TargetsResponse, error)

	PatchApi217TargetsWithResponse(ctx context.Context, params *PatchApi217TargetsParams, body PatchApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217TargetsResponse, error)

	// PostApi217TargetsWithBodyWithResponse request with any body
	PostApi217TargetsWithBodyWithResponse(ctx context.Context, params *PostApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217TargetsResponse, error)

	PostApi217TargetsWithResponse(ctx context.Context, params *PostApi217TargetsParams, body PostApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217TargetsResponse, error)

	// GetApi217TargetsPerformanceReplicationWithResponse request
	GetApi217TargetsPerformanceReplicationWithResponse(ctx context.Context, params *GetApi217TargetsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*GetApi217TargetsPerformanceReplicationResponse, error)

	// DeleteApi217TlsPoliciesWithResponse request
	DeleteApi217TlsPoliciesWithResponse(ctx context.Context, params *DeleteApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217TlsPoliciesResponse, error)

	// GetApi217TlsPoliciesWithResponse request
	GetApi217TlsPoliciesWithResponse(ctx context.Context, params *GetApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217TlsPoliciesResponse, error)

	// PatchApi217TlsPoliciesWithBodyWithResponse request with any body
	PatchApi217TlsPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217TlsPoliciesResponse, error)

	PatchApi217TlsPoliciesWithResponse(ctx context.Context, params *PatchApi217TlsPoliciesParams, body PatchApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217TlsPoliciesResponse, error)

	// PostApi217TlsPoliciesWithBodyWithResponse request with any body
	PostApi217TlsPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217TlsPoliciesResponse, error)

	PostApi217TlsPoliciesWithResponse(ctx context.Context, params *PostApi217TlsPoliciesParams, body PostApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217TlsPoliciesResponse, error)

	// GetApi217TlsPoliciesMembersWithResponse request
	GetApi217TlsPoliciesMembersWithResponse(ctx context.Context, params *GetApi217TlsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217TlsPoliciesMembersResponse, error)

	// DeleteApi217TlsPoliciesNetworkInterfacesWithResponse request
	DeleteApi217TlsPoliciesNetworkInterfacesWithResponse(ctx context.Context, params *DeleteApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*DeleteApi217TlsPoliciesNetworkInterfacesResponse, error)

	// GetApi217TlsPoliciesNetworkInterfacesWithResponse request
	GetApi217TlsPoliciesNetworkInterfacesWithResponse(ctx context.Context, params *GetApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*GetApi217TlsPoliciesNetworkInterfacesResponse, error)

	// PostApi217TlsPoliciesNetworkInterfacesWithResponse request
	PostApi217TlsPoliciesNetworkInterfacesWithResponse(ctx context.Context, params *PostApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*PostApi217TlsPoliciesNetworkInterfacesResponse, error)

	// GetApi217UsageGroupsWithResponse request
	GetApi217UsageGroupsWithResponse(ctx context.Context, params *GetApi217UsageGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217UsageGroupsResponse, error)

	// GetApi217UsageUsersWithResponse request
	GetApi217UsageUsersWithResponse(ctx context.Context, params *GetApi217UsageUsersParams, reqEditors ...RequestEditorFn) (*GetApi217UsageUsersResponse, error)

	// DeleteApi217WormDataPoliciesWithResponse request
	DeleteApi217WormDataPoliciesWithResponse(ctx context.Context, params *DeleteApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217WormDataPoliciesResponse, error)

	// GetApi217WormDataPoliciesWithResponse request
	GetApi217WormDataPoliciesWithResponse(ctx context.Context, params *GetApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217WormDataPoliciesResponse, error)

	// PatchApi217WormDataPoliciesWithBodyWithResponse request with any body
	PatchApi217WormDataPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217WormDataPoliciesResponse, error)

	PatchApi217WormDataPoliciesWithResponse(ctx context.Context, params *PatchApi217WormDataPoliciesParams, body PatchApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217WormDataPoliciesResponse, error)

	// PostApi217WormDataPoliciesWithBodyWithResponse request with any body
	PostApi217WormDataPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217WormDataPoliciesResponse, error)

	PostApi217WormDataPoliciesWithResponse(ctx context.Context, params *PostApi217WormDataPoliciesParams, body PostApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217WormDataPoliciesResponse, error)

	// GetApi217WormDataPoliciesMembersWithResponse request
	GetApi217WormDataPoliciesMembersWithResponse(ctx context.Context, params *GetApi217WormDataPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217WormDataPoliciesMembersResponse, error)

	// GetApiApiVersionWithResponse request
	GetApiApiVersionWithResponse(ctx context.Context, params *GetApiApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiApiVersionResponse, error)

	// PostApiLoginWithResponse request
	PostApiLoginWithResponse(ctx context.Context, params *PostApiLoginParams, reqEditors ...RequestEditorFn) (*PostApiLoginResponse, error)

	// GetApiLoginBannerWithResponse request
	GetApiLoginBannerWithResponse(ctx context.Context, params *GetApiLoginBannerParams, reqEditors ...RequestEditorFn) (*GetApiLoginBannerResponse, error)

	// PostApiLogoutWithResponse request
	PostApiLogoutWithResponse(ctx context.Context, params *PostApiLogoutParams, reqEditors ...RequestEditorFn) (*PostApiLogoutResponse, error)

	// PostOauth210TokenWithBodyWithResponse request with any body
	PostOauth210TokenWithBodyWithResponse(ctx context.Context, params *PostOauth210TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth210TokenResponse, error)

	PostOauth210TokenWithFormdataBodyWithResponse(ctx context.Context, params *PostOauth210TokenParams, body PostOauth210TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth210TokenResponse, error)
}

type DeleteApi217ActiveDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ActiveDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ActiveDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ActiveDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActiveDirectoryGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ActiveDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ActiveDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ActiveDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActiveDirectoryResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ActiveDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ActiveDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ActiveDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActiveDirectoryResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ActiveDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ActiveDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ActiveDirectoryTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ActiveDirectoryTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ActiveDirectoryTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217AdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217AdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217AdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217AdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217AdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217AdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217AdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217AdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217AdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217AdminsApiTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217AdminsApiTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217AdminsApiTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AdminsApiTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminApiTokenGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AdminsApiTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AdminsApiTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217AdminsApiTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminApiTokenResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217AdminsApiTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217AdminsApiTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217AdminsCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217AdminsCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217AdminsCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AdminsCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminCacheGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AdminsCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AdminsCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AdminsSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSettingsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AdminsSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AdminsSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217AdminsSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdminSettingsResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217AdminsSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217AdminsSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AdminsSshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AdminsSshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AdminsSshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217AdminsSshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217AdminsSshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217AdminsSshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217AlertWatchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217AlertWatchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217AlertWatchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AlertWatchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlertWatcherGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AlertWatchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AlertWatchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217AlertWatchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlertWatcherResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217AlertWatchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217AlertWatchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217AlertWatchersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlertWatcherResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217AlertWatchersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217AlertWatchersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AlertWatchersTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AlertWatchersTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AlertWatchersTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlertGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217AlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlertResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217AlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217AlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ApiClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ApiClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ApiClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ApiClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClientsResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ApiClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ApiClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ApiClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClientsResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ApiClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ApiClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ApiClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClientsResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ApiClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ApiClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ArrayConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ArrayConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ArrayConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArrayConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayConnectionGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArrayConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArrayConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ArrayConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayConnectionResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ArrayConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ArrayConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ArrayConnectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayConnectionResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ArrayConnectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ArrayConnectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArrayConnectionsConnectionKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayConnectionKeyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArrayConnectionsConnectionKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArrayConnectionsConnectionKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ArrayConnectionsConnectionKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayConnectionKeyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ArrayConnectionsConnectionKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ArrayConnectionsConnectionKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArrayConnectionsPathResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayConnectionPathGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArrayConnectionsPathResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArrayConnectionsPathResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArrayConnectionsPerformanceReplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectionRelationshipPerformanceReplicationGetResp
}

// Status returns HTTPResponse.Status
func (r GetApi217ArrayConnectionsPerformanceReplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArrayConnectionsPerformanceReplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ArraysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ArraysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ArraysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysClientsPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClientPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysClientsPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysClientsPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysEulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EulaGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysEulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysEulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ArraysEulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EulaResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ArraysEulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ArraysEulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ArraysFactoryResetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ArraysFactoryResetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ArraysFactoryResetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysFactoryResetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayFactoryResetTokenGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysFactoryResetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysFactoryResetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ArraysFactoryResetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayFactoryResetTokenResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ArraysFactoryResetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ArraysFactoryResetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysHttpSpecificPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayHttpSpecificPerformanceGet
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysHttpSpecificPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysHttpSpecificPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysNfsSpecificPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayNfsSpecificPerformanceGet
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysNfsSpecificPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysNfsSpecificPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysPerformanceReplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayPerformanceReplicationGetResp
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysPerformanceReplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysPerformanceReplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysS3SpecificPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArrayS3SpecificPerformanceGetResp
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysS3SpecificPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysS3SpecificPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArraySpaceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysSpaceStorageClassesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArraySpaceStorageClassGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysSpaceStorageClassesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysSpaceStorageClassesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysSshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysSshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysSshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ArraysSshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ArraysSshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ArraysSshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ArraysSupportedTimeZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArraysSupportedTimeZonesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ArraysSupportedTimeZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ArraysSupportedTimeZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217AuditFileSystemsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217AuditFileSystemsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217AuditFileSystemsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AuditFileSystemsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditFileSystemsPoliciesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AuditFileSystemsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AuditFileSystemsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217AuditFileSystemsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditFileSystemsPoliciesResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217AuditFileSystemsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217AuditFileSystemsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217AuditFileSystemsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditFileSystemsPoliciesResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217AuditFileSystemsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217AuditFileSystemsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217AuditFileSystemsPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217AuditFileSystemsPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217AuditFileSystemsPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AuditFileSystemsPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditFileSystemsPoliciesMembersGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AuditFileSystemsPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AuditFileSystemsPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217AuditFileSystemsPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditFileSystemsPoliciesMembersResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217AuditFileSystemsPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217AuditFileSystemsPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217AuditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217AuditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217AuditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BladesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BladeGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BladesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BladesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217BucketReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217BucketReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217BucketReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketReplicaLinkGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217BucketReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketReplicaLinkResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217BucketReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217BucketReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217BucketReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketReplicaLinkResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217BucketReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217BucketReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217BucketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217BucketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217BucketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217BucketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217BucketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217BucketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217BucketsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217BucketsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217BucketsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217BucketsBucketAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217BucketsBucketAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217BucketsBucketAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketsBucketAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketAccessPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketsBucketAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketsBucketAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217BucketsBucketAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketAccessPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217BucketsBucketAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217BucketsBucketAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217BucketsBucketAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217BucketsBucketAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217BucketsBucketAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketsBucketAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketAccessPolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketsBucketAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketsBucketAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217BucketsBucketAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketAccessPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217BucketsBucketAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217BucketsBucketAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketsCrossOriginResourceSharingPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrossOriginResourceSharingPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketsCrossOriginResourceSharingPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketsCrossOriginResourceSharingPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217BucketsCrossOriginResourceSharingPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrossOriginResourceSharingPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217BucketsCrossOriginResourceSharingPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217BucketsCrossOriginResourceSharingPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrossOriginResourceSharingPolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrossOriginResourceSharingPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketsPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketsPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketsPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217BucketsS3SpecificPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BucketS3SpecificPerformanceGetResp
}

// Status returns HTTPResponse.Status
func (r GetApi217BucketsS3SpecificPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217BucketsS3SpecificPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217CertificateGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217CertificateGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217CertificateGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217CertificateGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateGroupGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217CertificateGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217CertificateGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217CertificateGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateGroupResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217CertificateGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217CertificateGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217CertificateGroupsCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217CertificateGroupsCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217CertificateGroupsCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217CertificateGroupsCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateGroupCertificateGetResp
}

// Status returns HTTPResponse.Status
func (r GetApi217CertificateGroupsCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217CertificateGroupsCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217CertificateGroupsCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateGroupCertificateResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217CertificateGroupsCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217CertificateGroupsCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217CertificateGroupsUsesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateGroupUseGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217CertificateGroupsUsesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217CertificateGroupsUsesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217CertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217CertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217CertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217CertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217CertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217CertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217CertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217CertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217CertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217CertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217CertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217CertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217CertificatesCertificateGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217CertificatesCertificateGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217CertificatesCertificateGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217CertificatesCertificateGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateCertificateGroupGetResp
}

// Status returns HTTPResponse.Status
func (r GetApi217CertificatesCertificateGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217CertificatesCertificateGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217CertificatesCertificateGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateCertificateGroupResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217CertificatesCertificateGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217CertificatesCertificateGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217CertificatesUsesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificateUseGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217CertificatesUsesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217CertificatesUsesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217DirectoryServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoryServiceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217DirectoryServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217DirectoryServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217DirectoryServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoryServiceResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217DirectoryServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217DirectoryServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217DirectoryServicesRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217DirectoryServicesRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217DirectoryServicesRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217DirectoryServicesRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoryServiceRolesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217DirectoryServicesRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217DirectoryServicesRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217DirectoryServicesRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoryServiceRolesResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217DirectoryServicesRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217DirectoryServicesRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217DirectoryServicesRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DirectoryServiceRolesResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217DirectoryServicesRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217DirectoryServicesRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217DirectoryServicesTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217DirectoryServicesTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217DirectoryServicesTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217DirectoryServicesTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217DirectoryServicesTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217DirectoryServicesTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217DnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217DnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217DnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217DnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217DnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217DnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217DnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnsResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217DnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217DnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217DnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnsResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217DnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217DnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217DrivesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DriveGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217DrivesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217DrivesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemExportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemExportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemExportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemExportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemExportGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemExportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemExportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217FileSystemExportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemExportResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217FileSystemExportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217FileSystemExportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemExportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemExportResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemExportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemExportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemReplicaLinkGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217FileSystemReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemReplicaLinkResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217FileSystemReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217FileSystemReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemReplicaLinkResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemReplicaLinksPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemReplicaLinksPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemReplicaLinksPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemReplicaLinksPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberWithRemoteGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemReplicaLinksPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemReplicaLinksPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemReplicaLinksPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberWithRemoteResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemReplicaLinksPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemReplicaLinksPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemReplicaLinksTransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemSnapshotGetTransferResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemReplicaLinksTransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemReplicaLinksTransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemSnapshotGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217FileSystemSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemSnapshotResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217FileSystemSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217FileSystemSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemSnapshotResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemSnapshotsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemSnapshotsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemSnapshotsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemSnapshotsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyFileSystemSnapshotGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemSnapshotsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemSnapshotsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemSnapshotsTransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemSnapshotsTransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemSnapshotsTransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemSnapshotsTransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemSnapshotGetTransferResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemSnapshotsTransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemSnapshotsTransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217FileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217FileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217FileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemsAuditPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemsAuditPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemsAuditPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsAuditPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditFileSystemsPoliciesMembersGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsAuditPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsAuditPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemsAuditPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditFileSystemsPoliciesMembersResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemsAuditPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemsAuditPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsGroupsPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemGroupsPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsGroupsPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsGroupsPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemsLocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemsLocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemsLocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsLocksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileLockGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsLocksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsLocksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsLocksClientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemClientsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsLocksClientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsLocksClientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemsLocksNlmReclamationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileLockNlmReclamationResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemsLocksNlmReclamationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemsLocksNlmReclamationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemsOpenFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemsOpenFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemsOpenFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsOpenFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemOpenFilesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsOpenFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsOpenFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FileSystemsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FileSystemsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FileSystemsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsPoliciesAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsPoliciesAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsPoliciesAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FileSystemsSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FileSystemsSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FileSystemsSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsSessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSessionGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsSessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsSessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsUsersPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileSystemUsersPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsUsersPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsUsersPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FileSystemsWormDataPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WormDataPoliciesMembersGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FileSystemsWormDataPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FileSystemsWormDataPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FleetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FleetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FleetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FleetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FleetGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FleetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FleetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217FleetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FleetResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217FleetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217FleetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FleetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FleetResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FleetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FleetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FleetsFleetKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FleetKeyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FleetsFleetKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FleetsFleetKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FleetsFleetKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FleetKeyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FleetsFleetKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FleetsFleetKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217FleetsMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217FleetsMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217FleetsMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217FleetsMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FleetMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217FleetsMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217FleetsMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217FleetsMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FleetMemberResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217FleetsMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217FleetsMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217HardwareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HardwareGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217HardwareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217HardwareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217HardwareResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HardwareResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217HardwareResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217HardwareResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217HardwareConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HardwareConnectorGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217HardwareConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217HardwareConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217HardwareConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HardwareConnectorResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217HardwareConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217HardwareConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217HardwareConnectorsPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HardwareConnectorPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217HardwareConnectorsPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217HardwareConnectorsPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217KeytabsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217KeytabsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217KeytabsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217KeytabsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeytabGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217KeytabsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217KeytabsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217KeytabsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeytabResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217KeytabsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217KeytabsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217KeytabsDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetApi217KeytabsDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217KeytabsDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217KeytabsUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostApi217KeytabsUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217KeytabsUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217KmipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217KmipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217KmipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217KmipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KmipServerResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217KmipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217KmipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217KmipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KmipServerResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217KmipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217KmipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217KmipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KmipServerResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217KmipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217KmipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217KmipTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217KmipTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217KmipTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217LegalHoldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217LegalHoldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217LegalHoldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217LegalHoldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegalHoldsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217LegalHoldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217LegalHoldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217LegalHoldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegalHoldsResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217LegalHoldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217LegalHoldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217LegalHoldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegalHoldsResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217LegalHoldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217LegalHoldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217LegalHoldsHeldEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegalHoldsHeldEntitiesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217LegalHoldsHeldEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217LegalHoldsHeldEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217LegalHoldsHeldEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegalHoldsHeldEntitiesResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217LegalHoldsHeldEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217LegalHoldsHeldEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217LegalHoldsHeldEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegalHoldsHeldEntitiesResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217LegalHoldsHeldEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217LegalHoldsHeldEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217LifecycleRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217LifecycleRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217LifecycleRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217LifecycleRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LifecycleRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217LifecycleRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217LifecycleRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217LifecycleRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LifecycleRuleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217LifecycleRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217LifecycleRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217LifecycleRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LifecycleRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217LifecycleRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217LifecycleRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217LinkAggregationGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217LinkAggregationGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217LinkAggregationGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217LinkAggregationGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkAggregationGroupGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217LinkAggregationGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217LinkAggregationGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217LinkAggregationGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkAggregationGroupResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217LinkAggregationGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217LinkAggregationGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217LinkAggregationGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LinkAggregationGroupResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217LinkAggregationGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217LinkAggregationGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217LogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetApi217LogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217LogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217LogsAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogsAsyncGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217LogsAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217LogsAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217LogsAsyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogsAsyncResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217LogsAsyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217LogsAsyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217LogsAsyncDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r GetApi217LogsAsyncDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217LogsAsyncDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217MaintenanceWindowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217MaintenanceWindowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217MaintenanceWindowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217MaintenanceWindowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaintenanceWindowsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217MaintenanceWindowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217MaintenanceWindowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217MaintenanceWindowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MaintenanceWindowsResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217MaintenanceWindowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217MaintenanceWindowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkAccessPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217NetworkAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkAccessPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217NetworkAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217NetworkAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkAccessPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkAccessPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkAccessPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217NetworkAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217NetworkAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217NetworkAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkAccessPolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217NetworkAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkAccessPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217NetworkAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217NetworkAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217NetworkAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkAccessPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217NetworkAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217NetworkAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217NetworkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217NetworkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217NetworkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfaceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217NetworkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfaceResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217NetworkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217NetworkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217NetworkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfaceResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217NetworkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217NetworkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkInterfacesConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfacesConnectorsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkInterfacesConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkInterfacesConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217NetworkInterfacesConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfacesConnectorsResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217NetworkInterfacesConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217NetworkInterfacesConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkInterfacesConnectorsPerformanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfacesConnectorsPerformanceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkInterfacesConnectorsPerformanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkInterfacesConnectorsPerformanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkInterfacesConnectorsSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfacesConnectorsSettingsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkInterfacesConnectorsSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkInterfacesConnectorsSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkInterfacesPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfacePingGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkInterfacesPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkInterfacesPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217NetworkInterfacesTlsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217NetworkInterfacesTlsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217NetworkInterfacesTlsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkInterfacesTlsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkInterfacesTlsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkInterfacesTlsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217NetworkInterfacesTlsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217NetworkInterfacesTlsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217NetworkInterfacesTlsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NetworkInterfacesTraceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkInterfaceTraceGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NetworkInterfacesTraceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NetworkInterfacesTraceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217NfsExportPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217NfsExportPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217NfsExportPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NfsExportPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NfsExportPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NfsExportPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NfsExportPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217NfsExportPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NfsExportPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217NfsExportPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217NfsExportPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217NfsExportPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NfsExportPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217NfsExportPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217NfsExportPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217NfsExportPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217NfsExportPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217NfsExportPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217NfsExportPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NfsExportPolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217NfsExportPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217NfsExportPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217NfsExportPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NfsExportPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217NfsExportPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217NfsExportPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217NfsExportPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NfsExportPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217NfsExportPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217NfsExportPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreAccessKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreAccessKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreAccessKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreAccessKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessKeyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreAccessKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreAccessKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreAccessKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessKeyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreAccessKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreAccessKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreAccessKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessKeyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreAccessKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreAccessKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessPolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreAccessPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreAccessPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreAccessPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreAccessPolicyActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccessPolicyActionGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreAccessPolicyActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreAccessPolicyActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccountGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccountResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreAccountResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreRemoteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreRemoteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreRemoteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreRemoteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreRemoteCredentialGetResp
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreRemoteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreRemoteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreRemoteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreRemoteCredentialsResp
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreRemoteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreRemoteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreRemoteCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreRemoteCredentialsResp
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreRemoteCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreRemoteCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreRoleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreRoleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreRoleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreTrustPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreTrustPolicyIam
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreTrustPolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreTrustPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreTrustPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreTrustPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreUserGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreUserResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ObjectStoreVirtualHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ObjectStoreVirtualHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ObjectStoreVirtualHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ObjectStoreVirtualHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreVirtualHostGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ObjectStoreVirtualHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ObjectStoreVirtualHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ObjectStoreVirtualHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ObjectStoreVirtualHostResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ObjectStoreVirtualHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ObjectStoreVirtualHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PasswordPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasswordPoliciesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PasswordPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PasswordPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217PasswordPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PasswordPoliciesResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217PasswordPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217PasswordPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217PoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217PoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217PoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217PoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217PoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217PoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217PoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217PoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217PoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PoliciesAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyBaseGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PoliciesAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PoliciesAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PoliciesAllMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberWithRemoteGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PoliciesAllMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PoliciesAllMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217PoliciesFileSystemReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217PoliciesFileSystemReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217PoliciesFileSystemReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PoliciesFileSystemReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberWithRemoteGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PoliciesFileSystemReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PoliciesFileSystemReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217PoliciesFileSystemReplicaLinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberWithRemoteResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217PoliciesFileSystemReplicaLinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217PoliciesFileSystemReplicaLinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217PoliciesFileSystemSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217PoliciesFileSystemSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217PoliciesFileSystemSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PoliciesFileSystemSnapshotsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyFileSystemSnapshotGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PoliciesFileSystemSnapshotsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PoliciesFileSystemSnapshotsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217PoliciesFileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217PoliciesFileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217PoliciesFileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PoliciesFileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PoliciesFileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PoliciesFileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217PoliciesFileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberContextResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217PoliciesFileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217PoliciesFileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberWithRemoteGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217PublicKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217PublicKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217PublicKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PublicKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicKeyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PublicKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PublicKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217PublicKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicKeyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217PublicKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217PublicKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217PublicKeysUsesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublicKeyUseGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217PublicKeysUsesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217PublicKeysUsesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217QosPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217QosPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217QosPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217QosPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QosPoliciesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217QosPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217QosPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217QosPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QosPoliciesResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217QosPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217QosPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217QosPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QosPoliciesResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217QosPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217QosPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217QosPoliciesFileSystemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217QosPoliciesFileSystemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217QosPoliciesFileSystemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217QosPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217QosPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217QosPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217QuotasGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217QuotasGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217QuotasGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217QuotasGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupQuotaGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217QuotasGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217QuotasGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217QuotasGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupQuotaResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217QuotasGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217QuotasGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217QuotasGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupQuotaResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217QuotasGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217QuotasGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217QuotasSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuotaSettingGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217QuotasSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217QuotasSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217QuotasSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuotaSettingResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217QuotasSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217QuotasSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217QuotasUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217QuotasUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217QuotasUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217QuotasUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserQuotaGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217QuotasUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217QuotasUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217QuotasUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserQuotaResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217QuotasUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217QuotasUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217QuotasUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserQuotaResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217QuotasUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217QuotasUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217RapidDataLockingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RapidDataLockingResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217RapidDataLockingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217RapidDataLockingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217RapidDataLockingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RapidDataLockingResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217RapidDataLockingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217RapidDataLockingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217RapidDataLockingRotateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostApi217RapidDataLockingRotateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217RapidDataLockingRotateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217RapidDataLockingTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217RapidDataLockingTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217RapidDataLockingTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217RemoteArraysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RemoteArraysResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217RemoteArraysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217RemoteArraysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217RolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217RolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217RolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217ServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217ServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217ServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217ServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217ServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217ServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217ServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217ServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217ServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217ServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217ServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217ServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SessionGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SmbClientPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SmbClientPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SmbClientPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SmbClientPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbClientPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SmbClientPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SmbClientPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SmbClientPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbClientPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SmbClientPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SmbClientPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SmbClientPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbClientPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SmbClientPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SmbClientPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SmbClientPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SmbClientPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SmbClientPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SmbClientPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbClientPolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SmbClientPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SmbClientPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SmbClientPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbClientPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SmbClientPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SmbClientPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SmbClientPoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbClientPolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SmbClientPoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SmbClientPoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SmbSharePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SmbSharePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SmbSharePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SmbSharePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbSharePolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SmbSharePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SmbSharePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SmbSharePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbSharePolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SmbSharePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SmbSharePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SmbSharePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbSharePolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SmbSharePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SmbSharePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SmbSharePoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SmbSharePoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SmbSharePoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SmbSharePoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbSharePolicyRuleGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SmbSharePoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SmbSharePoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SmbSharePoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbSharePolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SmbSharePoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SmbSharePoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SmbSharePoliciesRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmbSharePolicyRuleResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SmbSharePoliciesRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SmbSharePoliciesRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SmtpServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmtpServerGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SmtpServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SmtpServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SmtpServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SmtpServerResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SmtpServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SmtpServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SnmpAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnmpAgentGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SnmpAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SnmpAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SnmpAgentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnmpAgentResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SnmpAgentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SnmpAgentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SnmpAgentsMibResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnmpAgentMibResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SnmpAgentsMibResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SnmpAgentsMibResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SnmpManagersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SnmpManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SnmpManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SnmpManagersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnmpManagerGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SnmpManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SnmpManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SnmpManagersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnmpManagerResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SnmpManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SnmpManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SnmpManagersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnmpManagerResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SnmpManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SnmpManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SnmpManagersTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SnmpManagersTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SnmpManagersTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SoftwareCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SoftwareChecksGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SoftwareCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SoftwareCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SoftwareCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SoftwareChecksResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SoftwareCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SoftwareCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SshCertificateAuthorityPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SshCertificateAuthorityPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SshCertificateAuthorityPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SshCertificateAuthorityPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SshCertificateAuthorityPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SshCertificateAuthorityPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SshCertificateAuthorityPoliciesAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SshCertificateAuthorityPoliciesAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SshCertificateAuthorityPoliciesAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SshCertificateAuthorityPoliciesAdminsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SshCertificateAuthorityPoliciesAdminsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SshCertificateAuthorityPoliciesAdminsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SshCertificateAuthorityPoliciesArraysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SshCertificateAuthorityPoliciesArraysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SshCertificateAuthorityPoliciesArraysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SshCertificateAuthorityPoliciesArraysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SshCertificateAuthorityPoliciesArraysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SshCertificateAuthorityPoliciesArraysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SshCertificateAuthorityPoliciesArraysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SshCertificateAuthorityPoliciesArraysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SshCertificateAuthorityPoliciesArraysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SshCertificateAuthorityPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SshCertificateAuthorityPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SshCertificateAuthorityPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SsoOidcIdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SsoOidcIdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SsoOidcIdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SsoOidcIdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcSsoGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SsoOidcIdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SsoOidcIdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SsoOidcIdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcSsoResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SsoOidcIdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SsoOidcIdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SsoOidcIdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OidcSsoResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SsoOidcIdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SsoOidcIdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SsoSaml2IdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SsoSaml2IdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SsoSaml2IdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SsoSaml2IdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Saml2SsoGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SsoSaml2IdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SsoSaml2IdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SsoSaml2IdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Saml2SsoResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SsoSaml2IdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SsoSaml2IdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SsoSaml2IdpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Saml2SsoResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SsoSaml2IdpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SsoSaml2IdpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SsoSaml2IdpsTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SsoSaml2IdpsTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SsoSaml2IdpsTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SsoSaml2IdpsTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SsoSaml2IdpsTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SsoSaml2IdpsTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubnetGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubnetResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SubnetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubnetResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SubnetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SubnetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SupportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SupportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SupportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SupportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SupportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SupportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SupportDiagnosticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportDiagnosticsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SupportDiagnosticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SupportDiagnosticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SupportDiagnosticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportDiagnosticsGetResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SupportDiagnosticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SupportDiagnosticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SupportDiagnosticsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportDiagnosticsDetailsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SupportDiagnosticsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SupportDiagnosticsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SupportTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SupportTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SupportTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SupportVerificationKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationKeyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SupportVerificationKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SupportVerificationKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SupportVerificationKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerificationKeyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SupportVerificationKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SupportVerificationKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217SyslogServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217SyslogServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217SyslogServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SyslogServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyslogServerGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SyslogServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SyslogServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SyslogServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyslogServerResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SyslogServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SyslogServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217SyslogServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyslogServerResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217SyslogServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217SyslogServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SyslogServersSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyslogServerSettingsGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SyslogServersSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SyslogServersSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217SyslogServersSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyslogServerSettingsResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217SyslogServersSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217SyslogServersSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217SyslogServersTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResultGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217SyslogServersTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217SyslogServersTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217TargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217TargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217TargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217TargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217TargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217TargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217TargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217TargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217TargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217TargetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TargetResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217TargetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217TargetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217TargetsPerformanceReplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourcePerformanceReplicationGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217TargetsPerformanceReplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217TargetsPerformanceReplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217TlsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217TlsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217TlsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217TlsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsPolicyGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217TlsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217TlsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217TlsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217TlsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217TlsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217TlsPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TlsPolicyResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217TlsPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217TlsPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217TlsPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217TlsPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217TlsPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217TlsPoliciesNetworkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217TlsPoliciesNetworkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217TlsPoliciesNetworkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217TlsPoliciesNetworkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217TlsPoliciesNetworkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217TlsPoliciesNetworkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217TlsPoliciesNetworkInterfacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PolicyMemberResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217TlsPoliciesNetworkInterfacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217TlsPoliciesNetworkInterfacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217UsageGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupQuotaGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217UsageGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217UsageGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217UsageUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserQuotaGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217UsageUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217UsageUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApi217WormDataPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApi217WormDataPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApi217WormDataPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217WormDataPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WormDataPoliciesGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217WormDataPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217WormDataPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApi217WormDataPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WormDataPoliciesResponse
}

// Status returns HTTPResponse.Status
func (r PatchApi217WormDataPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApi217WormDataPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApi217WormDataPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WormDataPoliciesResponse
}

// Status returns HTTPResponse.Status
func (r PostApi217WormDataPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApi217WormDataPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApi217WormDataPoliciesMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WormDataPoliciesMembersGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApi217WormDataPoliciesMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApi217WormDataPoliciesMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiApiVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiVersion
}

// Status returns HTTPResponse.Status
func (r GetApiApiVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiApiVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Login
}

// Status returns HTTPResponse.Status
func (r PostApiLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiLoginBannerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginBannerGetResponse
}

// Status returns HTTPResponse.Status
func (r GetApiLoginBannerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiLoginBannerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostApiLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostApiLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostApiLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOauth210TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OauthToken200
	JSON400      *OauthToken400
	JSON401      *OauthToken401
}

// Status returns HTTPResponse.Status
func (r PostOauth210TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOauth210TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteApi217ActiveDirectoryWithResponse request returning *DeleteApi217ActiveDirectoryResponse
func (c *ClientWithResponses) DeleteApi217ActiveDirectoryWithResponse(ctx context.Context, params *DeleteApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*DeleteApi217ActiveDirectoryResponse, error) {
	rsp, err := c.DeleteApi217ActiveDirectory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ActiveDirectoryResponse(rsp)
}

// GetApi217ActiveDirectoryWithResponse request returning *GetApi217ActiveDirectoryResponse
func (c *ClientWithResponses) GetApi217ActiveDirectoryWithResponse(ctx context.Context, params *GetApi217ActiveDirectoryParams, reqEditors ...RequestEditorFn) (*GetApi217ActiveDirectoryResponse, error) {
	rsp, err := c.GetApi217ActiveDirectory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ActiveDirectoryResponse(rsp)
}

// PatchApi217ActiveDirectoryWithBodyWithResponse request with arbitrary body returning *PatchApi217ActiveDirectoryResponse
func (c *ClientWithResponses) PatchApi217ActiveDirectoryWithBodyWithResponse(ctx context.Context, params *PatchApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ActiveDirectoryResponse, error) {
	rsp, err := c.PatchApi217ActiveDirectoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ActiveDirectoryResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ActiveDirectoryWithResponse(ctx context.Context, params *PatchApi217ActiveDirectoryParams, body PatchApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ActiveDirectoryResponse, error) {
	rsp, err := c.PatchApi217ActiveDirectory(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ActiveDirectoryResponse(rsp)
}

// PostApi217ActiveDirectoryWithBodyWithResponse request with arbitrary body returning *PostApi217ActiveDirectoryResponse
func (c *ClientWithResponses) PostApi217ActiveDirectoryWithBodyWithResponse(ctx context.Context, params *PostApi217ActiveDirectoryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ActiveDirectoryResponse, error) {
	rsp, err := c.PostApi217ActiveDirectoryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ActiveDirectoryResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ActiveDirectoryWithResponse(ctx context.Context, params *PostApi217ActiveDirectoryParams, body PostApi217ActiveDirectoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ActiveDirectoryResponse, error) {
	rsp, err := c.PostApi217ActiveDirectory(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ActiveDirectoryResponse(rsp)
}

// GetApi217ActiveDirectoryTestWithResponse request returning *GetApi217ActiveDirectoryTestResponse
func (c *ClientWithResponses) GetApi217ActiveDirectoryTestWithResponse(ctx context.Context, params *GetApi217ActiveDirectoryTestParams, reqEditors ...RequestEditorFn) (*GetApi217ActiveDirectoryTestResponse, error) {
	rsp, err := c.GetApi217ActiveDirectoryTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ActiveDirectoryTestResponse(rsp)
}

// DeleteApi217AdminsWithResponse request returning *DeleteApi217AdminsResponse
func (c *ClientWithResponses) DeleteApi217AdminsWithResponse(ctx context.Context, params *DeleteApi217AdminsParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsResponse, error) {
	rsp, err := c.DeleteApi217Admins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217AdminsResponse(rsp)
}

// GetApi217AdminsWithResponse request returning *GetApi217AdminsResponse
func (c *ClientWithResponses) GetApi217AdminsWithResponse(ctx context.Context, params *GetApi217AdminsParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsResponse, error) {
	rsp, err := c.GetApi217Admins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AdminsResponse(rsp)
}

// PatchApi217AdminsWithBodyWithResponse request with arbitrary body returning *PatchApi217AdminsResponse
func (c *ClientWithResponses) PatchApi217AdminsWithBodyWithResponse(ctx context.Context, params *PatchApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AdminsResponse, error) {
	rsp, err := c.PatchApi217AdminsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AdminsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217AdminsWithResponse(ctx context.Context, params *PatchApi217AdminsParams, body PatchApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AdminsResponse, error) {
	rsp, err := c.PatchApi217Admins(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AdminsResponse(rsp)
}

// PostApi217AdminsWithBodyWithResponse request with arbitrary body returning *PostApi217AdminsResponse
func (c *ClientWithResponses) PostApi217AdminsWithBodyWithResponse(ctx context.Context, params *PostApi217AdminsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217AdminsResponse, error) {
	rsp, err := c.PostApi217AdminsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AdminsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217AdminsWithResponse(ctx context.Context, params *PostApi217AdminsParams, body PostApi217AdminsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217AdminsResponse, error) {
	rsp, err := c.PostApi217Admins(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AdminsResponse(rsp)
}

// DeleteApi217AdminsApiTokensWithResponse request returning *DeleteApi217AdminsApiTokensResponse
func (c *ClientWithResponses) DeleteApi217AdminsApiTokensWithResponse(ctx context.Context, params *DeleteApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsApiTokensResponse, error) {
	rsp, err := c.DeleteApi217AdminsApiTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217AdminsApiTokensResponse(rsp)
}

// GetApi217AdminsApiTokensWithResponse request returning *GetApi217AdminsApiTokensResponse
func (c *ClientWithResponses) GetApi217AdminsApiTokensWithResponse(ctx context.Context, params *GetApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsApiTokensResponse, error) {
	rsp, err := c.GetApi217AdminsApiTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AdminsApiTokensResponse(rsp)
}

// PostApi217AdminsApiTokensWithResponse request returning *PostApi217AdminsApiTokensResponse
func (c *ClientWithResponses) PostApi217AdminsApiTokensWithResponse(ctx context.Context, params *PostApi217AdminsApiTokensParams, reqEditors ...RequestEditorFn) (*PostApi217AdminsApiTokensResponse, error) {
	rsp, err := c.PostApi217AdminsApiTokens(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AdminsApiTokensResponse(rsp)
}

// DeleteApi217AdminsCacheWithResponse request returning *DeleteApi217AdminsCacheResponse
func (c *ClientWithResponses) DeleteApi217AdminsCacheWithResponse(ctx context.Context, params *DeleteApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsCacheResponse, error) {
	rsp, err := c.DeleteApi217AdminsCache(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217AdminsCacheResponse(rsp)
}

// GetApi217AdminsCacheWithResponse request returning *GetApi217AdminsCacheResponse
func (c *ClientWithResponses) GetApi217AdminsCacheWithResponse(ctx context.Context, params *GetApi217AdminsCacheParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsCacheResponse, error) {
	rsp, err := c.GetApi217AdminsCache(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AdminsCacheResponse(rsp)
}

// GetApi217AdminsSettingsWithResponse request returning *GetApi217AdminsSettingsResponse
func (c *ClientWithResponses) GetApi217AdminsSettingsWithResponse(ctx context.Context, params *GetApi217AdminsSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsSettingsResponse, error) {
	rsp, err := c.GetApi217AdminsSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AdminsSettingsResponse(rsp)
}

// PatchApi217AdminsSettingsWithBodyWithResponse request with arbitrary body returning *PatchApi217AdminsSettingsResponse
func (c *ClientWithResponses) PatchApi217AdminsSettingsWithBodyWithResponse(ctx context.Context, params *PatchApi217AdminsSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AdminsSettingsResponse, error) {
	rsp, err := c.PatchApi217AdminsSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AdminsSettingsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217AdminsSettingsWithResponse(ctx context.Context, params *PatchApi217AdminsSettingsParams, body PatchApi217AdminsSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AdminsSettingsResponse, error) {
	rsp, err := c.PatchApi217AdminsSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AdminsSettingsResponse(rsp)
}

// DeleteApi217AdminsSshCertificateAuthorityPoliciesWithResponse request returning *DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) DeleteApi217AdminsSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *DeleteApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.DeleteApi217AdminsSshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217AdminsSshCertificateAuthorityPoliciesResponse(rsp)
}

// GetApi217AdminsSshCertificateAuthorityPoliciesWithResponse request returning *GetApi217AdminsSshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) GetApi217AdminsSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *GetApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217AdminsSshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.GetApi217AdminsSshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AdminsSshCertificateAuthorityPoliciesResponse(rsp)
}

// PostApi217AdminsSshCertificateAuthorityPoliciesWithResponse request returning *PostApi217AdminsSshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) PostApi217AdminsSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PostApi217AdminsSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217AdminsSshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.PostApi217AdminsSshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AdminsSshCertificateAuthorityPoliciesResponse(rsp)
}

// DeleteApi217AlertWatchersWithResponse request returning *DeleteApi217AlertWatchersResponse
func (c *ClientWithResponses) DeleteApi217AlertWatchersWithResponse(ctx context.Context, params *DeleteApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*DeleteApi217AlertWatchersResponse, error) {
	rsp, err := c.DeleteApi217AlertWatchers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217AlertWatchersResponse(rsp)
}

// GetApi217AlertWatchersWithResponse request returning *GetApi217AlertWatchersResponse
func (c *ClientWithResponses) GetApi217AlertWatchersWithResponse(ctx context.Context, params *GetApi217AlertWatchersParams, reqEditors ...RequestEditorFn) (*GetApi217AlertWatchersResponse, error) {
	rsp, err := c.GetApi217AlertWatchers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AlertWatchersResponse(rsp)
}

// PatchApi217AlertWatchersWithBodyWithResponse request with arbitrary body returning *PatchApi217AlertWatchersResponse
func (c *ClientWithResponses) PatchApi217AlertWatchersWithBodyWithResponse(ctx context.Context, params *PatchApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AlertWatchersResponse, error) {
	rsp, err := c.PatchApi217AlertWatchersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AlertWatchersResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217AlertWatchersWithResponse(ctx context.Context, params *PatchApi217AlertWatchersParams, body PatchApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AlertWatchersResponse, error) {
	rsp, err := c.PatchApi217AlertWatchers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AlertWatchersResponse(rsp)
}

// PostApi217AlertWatchersWithBodyWithResponse request with arbitrary body returning *PostApi217AlertWatchersResponse
func (c *ClientWithResponses) PostApi217AlertWatchersWithBodyWithResponse(ctx context.Context, params *PostApi217AlertWatchersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217AlertWatchersResponse, error) {
	rsp, err := c.PostApi217AlertWatchersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AlertWatchersResponse(rsp)
}

func (c *ClientWithResponses) PostApi217AlertWatchersWithResponse(ctx context.Context, params *PostApi217AlertWatchersParams, body PostApi217AlertWatchersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217AlertWatchersResponse, error) {
	rsp, err := c.PostApi217AlertWatchers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AlertWatchersResponse(rsp)
}

// GetApi217AlertWatchersTestWithResponse request returning *GetApi217AlertWatchersTestResponse
func (c *ClientWithResponses) GetApi217AlertWatchersTestWithResponse(ctx context.Context, params *GetApi217AlertWatchersTestParams, reqEditors ...RequestEditorFn) (*GetApi217AlertWatchersTestResponse, error) {
	rsp, err := c.GetApi217AlertWatchersTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AlertWatchersTestResponse(rsp)
}

// GetApi217AlertsWithResponse request returning *GetApi217AlertsResponse
func (c *ClientWithResponses) GetApi217AlertsWithResponse(ctx context.Context, params *GetApi217AlertsParams, reqEditors ...RequestEditorFn) (*GetApi217AlertsResponse, error) {
	rsp, err := c.GetApi217Alerts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AlertsResponse(rsp)
}

// PatchApi217AlertsWithBodyWithResponse request with arbitrary body returning *PatchApi217AlertsResponse
func (c *ClientWithResponses) PatchApi217AlertsWithBodyWithResponse(ctx context.Context, params *PatchApi217AlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AlertsResponse, error) {
	rsp, err := c.PatchApi217AlertsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AlertsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217AlertsWithResponse(ctx context.Context, params *PatchApi217AlertsParams, body PatchApi217AlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AlertsResponse, error) {
	rsp, err := c.PatchApi217Alerts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AlertsResponse(rsp)
}

// DeleteApi217ApiClientsWithResponse request returning *DeleteApi217ApiClientsResponse
func (c *ClientWithResponses) DeleteApi217ApiClientsWithResponse(ctx context.Context, params *DeleteApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ApiClientsResponse, error) {
	rsp, err := c.DeleteApi217ApiClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ApiClientsResponse(rsp)
}

// GetApi217ApiClientsWithResponse request returning *GetApi217ApiClientsResponse
func (c *ClientWithResponses) GetApi217ApiClientsWithResponse(ctx context.Context, params *GetApi217ApiClientsParams, reqEditors ...RequestEditorFn) (*GetApi217ApiClientsResponse, error) {
	rsp, err := c.GetApi217ApiClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ApiClientsResponse(rsp)
}

// PatchApi217ApiClientsWithBodyWithResponse request with arbitrary body returning *PatchApi217ApiClientsResponse
func (c *ClientWithResponses) PatchApi217ApiClientsWithBodyWithResponse(ctx context.Context, params *PatchApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ApiClientsResponse, error) {
	rsp, err := c.PatchApi217ApiClientsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ApiClientsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ApiClientsWithResponse(ctx context.Context, params *PatchApi217ApiClientsParams, body PatchApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ApiClientsResponse, error) {
	rsp, err := c.PatchApi217ApiClients(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ApiClientsResponse(rsp)
}

// PostApi217ApiClientsWithBodyWithResponse request with arbitrary body returning *PostApi217ApiClientsResponse
func (c *ClientWithResponses) PostApi217ApiClientsWithBodyWithResponse(ctx context.Context, params *PostApi217ApiClientsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ApiClientsResponse, error) {
	rsp, err := c.PostApi217ApiClientsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ApiClientsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ApiClientsWithResponse(ctx context.Context, params *PostApi217ApiClientsParams, body PostApi217ApiClientsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ApiClientsResponse, error) {
	rsp, err := c.PostApi217ApiClients(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ApiClientsResponse(rsp)
}

// DeleteApi217ArrayConnectionsWithResponse request returning *DeleteApi217ArrayConnectionsResponse
func (c *ClientWithResponses) DeleteApi217ArrayConnectionsWithResponse(ctx context.Context, params *DeleteApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ArrayConnectionsResponse, error) {
	rsp, err := c.DeleteApi217ArrayConnections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ArrayConnectionsResponse(rsp)
}

// GetApi217ArrayConnectionsWithResponse request returning *GetApi217ArrayConnectionsResponse
func (c *ClientWithResponses) GetApi217ArrayConnectionsWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsResponse, error) {
	rsp, err := c.GetApi217ArrayConnections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArrayConnectionsResponse(rsp)
}

// PatchApi217ArrayConnectionsWithBodyWithResponse request with arbitrary body returning *PatchApi217ArrayConnectionsResponse
func (c *ClientWithResponses) PatchApi217ArrayConnectionsWithBodyWithResponse(ctx context.Context, params *PatchApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ArrayConnectionsResponse, error) {
	rsp, err := c.PatchApi217ArrayConnectionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ArrayConnectionsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ArrayConnectionsWithResponse(ctx context.Context, params *PatchApi217ArrayConnectionsParams, body PatchApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ArrayConnectionsResponse, error) {
	rsp, err := c.PatchApi217ArrayConnections(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ArrayConnectionsResponse(rsp)
}

// PostApi217ArrayConnectionsWithBodyWithResponse request with arbitrary body returning *PostApi217ArrayConnectionsResponse
func (c *ClientWithResponses) PostApi217ArrayConnectionsWithBodyWithResponse(ctx context.Context, params *PostApi217ArrayConnectionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ArrayConnectionsResponse, error) {
	rsp, err := c.PostApi217ArrayConnectionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ArrayConnectionsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ArrayConnectionsWithResponse(ctx context.Context, params *PostApi217ArrayConnectionsParams, body PostApi217ArrayConnectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ArrayConnectionsResponse, error) {
	rsp, err := c.PostApi217ArrayConnections(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ArrayConnectionsResponse(rsp)
}

// GetApi217ArrayConnectionsConnectionKeyWithResponse request returning *GetApi217ArrayConnectionsConnectionKeyResponse
func (c *ClientWithResponses) GetApi217ArrayConnectionsConnectionKeyWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsConnectionKeyResponse, error) {
	rsp, err := c.GetApi217ArrayConnectionsConnectionKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArrayConnectionsConnectionKeyResponse(rsp)
}

// PostApi217ArrayConnectionsConnectionKeyWithResponse request returning *PostApi217ArrayConnectionsConnectionKeyResponse
func (c *ClientWithResponses) PostApi217ArrayConnectionsConnectionKeyWithResponse(ctx context.Context, params *PostApi217ArrayConnectionsConnectionKeyParams, reqEditors ...RequestEditorFn) (*PostApi217ArrayConnectionsConnectionKeyResponse, error) {
	rsp, err := c.PostApi217ArrayConnectionsConnectionKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ArrayConnectionsConnectionKeyResponse(rsp)
}

// GetApi217ArrayConnectionsPathWithResponse request returning *GetApi217ArrayConnectionsPathResponse
func (c *ClientWithResponses) GetApi217ArrayConnectionsPathWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsPathParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsPathResponse, error) {
	rsp, err := c.GetApi217ArrayConnectionsPath(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArrayConnectionsPathResponse(rsp)
}

// GetApi217ArrayConnectionsPerformanceReplicationWithResponse request returning *GetApi217ArrayConnectionsPerformanceReplicationResponse
func (c *ClientWithResponses) GetApi217ArrayConnectionsPerformanceReplicationWithResponse(ctx context.Context, params *GetApi217ArrayConnectionsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*GetApi217ArrayConnectionsPerformanceReplicationResponse, error) {
	rsp, err := c.GetApi217ArrayConnectionsPerformanceReplication(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArrayConnectionsPerformanceReplicationResponse(rsp)
}

// GetApi217ArraysWithResponse request returning *GetApi217ArraysResponse
func (c *ClientWithResponses) GetApi217ArraysWithResponse(ctx context.Context, params *GetApi217ArraysParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysResponse, error) {
	rsp, err := c.GetApi217Arrays(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysResponse(rsp)
}

// PatchApi217ArraysWithBodyWithResponse request with arbitrary body returning *PatchApi217ArraysResponse
func (c *ClientWithResponses) PatchApi217ArraysWithBodyWithResponse(ctx context.Context, params *PatchApi217ArraysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ArraysResponse, error) {
	rsp, err := c.PatchApi217ArraysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ArraysResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ArraysWithResponse(ctx context.Context, params *PatchApi217ArraysParams, body PatchApi217ArraysJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ArraysResponse, error) {
	rsp, err := c.PatchApi217Arrays(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ArraysResponse(rsp)
}

// GetApi217ArraysClientsPerformanceWithResponse request returning *GetApi217ArraysClientsPerformanceResponse
func (c *ClientWithResponses) GetApi217ArraysClientsPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysClientsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysClientsPerformanceResponse, error) {
	rsp, err := c.GetApi217ArraysClientsPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysClientsPerformanceResponse(rsp)
}

// GetApi217ArraysEulaWithResponse request returning *GetApi217ArraysEulaResponse
func (c *ClientWithResponses) GetApi217ArraysEulaWithResponse(ctx context.Context, params *GetApi217ArraysEulaParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysEulaResponse, error) {
	rsp, err := c.GetApi217ArraysEula(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysEulaResponse(rsp)
}

// PatchApi217ArraysEulaWithBodyWithResponse request with arbitrary body returning *PatchApi217ArraysEulaResponse
func (c *ClientWithResponses) PatchApi217ArraysEulaWithBodyWithResponse(ctx context.Context, params *PatchApi217ArraysEulaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ArraysEulaResponse, error) {
	rsp, err := c.PatchApi217ArraysEulaWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ArraysEulaResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ArraysEulaWithResponse(ctx context.Context, params *PatchApi217ArraysEulaParams, body PatchApi217ArraysEulaJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ArraysEulaResponse, error) {
	rsp, err := c.PatchApi217ArraysEula(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ArraysEulaResponse(rsp)
}

// DeleteApi217ArraysFactoryResetTokenWithResponse request returning *DeleteApi217ArraysFactoryResetTokenResponse
func (c *ClientWithResponses) DeleteApi217ArraysFactoryResetTokenWithResponse(ctx context.Context, params *DeleteApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*DeleteApi217ArraysFactoryResetTokenResponse, error) {
	rsp, err := c.DeleteApi217ArraysFactoryResetToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ArraysFactoryResetTokenResponse(rsp)
}

// GetApi217ArraysFactoryResetTokenWithResponse request returning *GetApi217ArraysFactoryResetTokenResponse
func (c *ClientWithResponses) GetApi217ArraysFactoryResetTokenWithResponse(ctx context.Context, params *GetApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysFactoryResetTokenResponse, error) {
	rsp, err := c.GetApi217ArraysFactoryResetToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysFactoryResetTokenResponse(rsp)
}

// PostApi217ArraysFactoryResetTokenWithResponse request returning *PostApi217ArraysFactoryResetTokenResponse
func (c *ClientWithResponses) PostApi217ArraysFactoryResetTokenWithResponse(ctx context.Context, params *PostApi217ArraysFactoryResetTokenParams, reqEditors ...RequestEditorFn) (*PostApi217ArraysFactoryResetTokenResponse, error) {
	rsp, err := c.PostApi217ArraysFactoryResetToken(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ArraysFactoryResetTokenResponse(rsp)
}

// GetApi217ArraysHttpSpecificPerformanceWithResponse request returning *GetApi217ArraysHttpSpecificPerformanceResponse
func (c *ClientWithResponses) GetApi217ArraysHttpSpecificPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysHttpSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysHttpSpecificPerformanceResponse, error) {
	rsp, err := c.GetApi217ArraysHttpSpecificPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysHttpSpecificPerformanceResponse(rsp)
}

// GetApi217ArraysNfsSpecificPerformanceWithResponse request returning *GetApi217ArraysNfsSpecificPerformanceResponse
func (c *ClientWithResponses) GetApi217ArraysNfsSpecificPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysNfsSpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysNfsSpecificPerformanceResponse, error) {
	rsp, err := c.GetApi217ArraysNfsSpecificPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysNfsSpecificPerformanceResponse(rsp)
}

// GetApi217ArraysPerformanceWithResponse request returning *GetApi217ArraysPerformanceResponse
func (c *ClientWithResponses) GetApi217ArraysPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysPerformanceResponse, error) {
	rsp, err := c.GetApi217ArraysPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysPerformanceResponse(rsp)
}

// GetApi217ArraysPerformanceReplicationWithResponse request returning *GetApi217ArraysPerformanceReplicationResponse
func (c *ClientWithResponses) GetApi217ArraysPerformanceReplicationWithResponse(ctx context.Context, params *GetApi217ArraysPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysPerformanceReplicationResponse, error) {
	rsp, err := c.GetApi217ArraysPerformanceReplication(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysPerformanceReplicationResponse(rsp)
}

// GetApi217ArraysS3SpecificPerformanceWithResponse request returning *GetApi217ArraysS3SpecificPerformanceResponse
func (c *ClientWithResponses) GetApi217ArraysS3SpecificPerformanceWithResponse(ctx context.Context, params *GetApi217ArraysS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysS3SpecificPerformanceResponse, error) {
	rsp, err := c.GetApi217ArraysS3SpecificPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysS3SpecificPerformanceResponse(rsp)
}

// GetApi217ArraysSpaceWithResponse request returning *GetApi217ArraysSpaceResponse
func (c *ClientWithResponses) GetApi217ArraysSpaceWithResponse(ctx context.Context, params *GetApi217ArraysSpaceParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSpaceResponse, error) {
	rsp, err := c.GetApi217ArraysSpace(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysSpaceResponse(rsp)
}

// GetApi217ArraysSpaceStorageClassesWithResponse request returning *GetApi217ArraysSpaceStorageClassesResponse
func (c *ClientWithResponses) GetApi217ArraysSpaceStorageClassesWithResponse(ctx context.Context, params *GetApi217ArraysSpaceStorageClassesParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSpaceStorageClassesResponse, error) {
	rsp, err := c.GetApi217ArraysSpaceStorageClasses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysSpaceStorageClassesResponse(rsp)
}

// DeleteApi217ArraysSshCertificateAuthorityPoliciesWithResponse request returning *DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) DeleteApi217ArraysSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *DeleteApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.DeleteApi217ArraysSshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ArraysSshCertificateAuthorityPoliciesResponse(rsp)
}

// GetApi217ArraysSshCertificateAuthorityPoliciesWithResponse request returning *GetApi217ArraysSshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) GetApi217ArraysSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *GetApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.GetApi217ArraysSshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysSshCertificateAuthorityPoliciesResponse(rsp)
}

// PostApi217ArraysSshCertificateAuthorityPoliciesWithResponse request returning *PostApi217ArraysSshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) PostApi217ArraysSshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PostApi217ArraysSshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217ArraysSshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.PostApi217ArraysSshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ArraysSshCertificateAuthorityPoliciesResponse(rsp)
}

// GetApi217ArraysSupportedTimeZonesWithResponse request returning *GetApi217ArraysSupportedTimeZonesResponse
func (c *ClientWithResponses) GetApi217ArraysSupportedTimeZonesWithResponse(ctx context.Context, params *GetApi217ArraysSupportedTimeZonesParams, reqEditors ...RequestEditorFn) (*GetApi217ArraysSupportedTimeZonesResponse, error) {
	rsp, err := c.GetApi217ArraysSupportedTimeZones(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ArraysSupportedTimeZonesResponse(rsp)
}

// DeleteApi217AuditFileSystemsPoliciesWithResponse request returning *DeleteApi217AuditFileSystemsPoliciesResponse
func (c *ClientWithResponses) DeleteApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217AuditFileSystemsPoliciesResponse, error) {
	rsp, err := c.DeleteApi217AuditFileSystemsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217AuditFileSystemsPoliciesResponse(rsp)
}

// GetApi217AuditFileSystemsPoliciesWithResponse request returning *GetApi217AuditFileSystemsPoliciesResponse
func (c *ClientWithResponses) GetApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217AuditFileSystemsPoliciesResponse, error) {
	rsp, err := c.GetApi217AuditFileSystemsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AuditFileSystemsPoliciesResponse(rsp)
}

// PatchApi217AuditFileSystemsPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217AuditFileSystemsPoliciesResponse
func (c *ClientWithResponses) PatchApi217AuditFileSystemsPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217AuditFileSystemsPoliciesResponse, error) {
	rsp, err := c.PatchApi217AuditFileSystemsPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AuditFileSystemsPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *PatchApi217AuditFileSystemsPoliciesParams, body PatchApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217AuditFileSystemsPoliciesResponse, error) {
	rsp, err := c.PatchApi217AuditFileSystemsPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217AuditFileSystemsPoliciesResponse(rsp)
}

// PostApi217AuditFileSystemsPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217AuditFileSystemsPoliciesResponse
func (c *ClientWithResponses) PostApi217AuditFileSystemsPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217AuditFileSystemsPoliciesResponse, error) {
	rsp, err := c.PostApi217AuditFileSystemsPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AuditFileSystemsPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217AuditFileSystemsPoliciesWithResponse(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesParams, body PostApi217AuditFileSystemsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217AuditFileSystemsPoliciesResponse, error) {
	rsp, err := c.PostApi217AuditFileSystemsPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AuditFileSystemsPoliciesResponse(rsp)
}

// DeleteApi217AuditFileSystemsPoliciesMembersWithResponse request returning *DeleteApi217AuditFileSystemsPoliciesMembersResponse
func (c *ClientWithResponses) DeleteApi217AuditFileSystemsPoliciesMembersWithResponse(ctx context.Context, params *DeleteApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*DeleteApi217AuditFileSystemsPoliciesMembersResponse, error) {
	rsp, err := c.DeleteApi217AuditFileSystemsPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217AuditFileSystemsPoliciesMembersResponse(rsp)
}

// GetApi217AuditFileSystemsPoliciesMembersWithResponse request returning *GetApi217AuditFileSystemsPoliciesMembersResponse
func (c *ClientWithResponses) GetApi217AuditFileSystemsPoliciesMembersWithResponse(ctx context.Context, params *GetApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217AuditFileSystemsPoliciesMembersResponse, error) {
	rsp, err := c.GetApi217AuditFileSystemsPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AuditFileSystemsPoliciesMembersResponse(rsp)
}

// PostApi217AuditFileSystemsPoliciesMembersWithResponse request returning *PostApi217AuditFileSystemsPoliciesMembersResponse
func (c *ClientWithResponses) PostApi217AuditFileSystemsPoliciesMembersWithResponse(ctx context.Context, params *PostApi217AuditFileSystemsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*PostApi217AuditFileSystemsPoliciesMembersResponse, error) {
	rsp, err := c.PostApi217AuditFileSystemsPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217AuditFileSystemsPoliciesMembersResponse(rsp)
}

// GetApi217AuditsWithResponse request returning *GetApi217AuditsResponse
func (c *ClientWithResponses) GetApi217AuditsWithResponse(ctx context.Context, params *GetApi217AuditsParams, reqEditors ...RequestEditorFn) (*GetApi217AuditsResponse, error) {
	rsp, err := c.GetApi217Audits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217AuditsResponse(rsp)
}

// GetApi217BladesWithResponse request returning *GetApi217BladesResponse
func (c *ClientWithResponses) GetApi217BladesWithResponse(ctx context.Context, params *GetApi217BladesParams, reqEditors ...RequestEditorFn) (*GetApi217BladesResponse, error) {
	rsp, err := c.GetApi217Blades(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BladesResponse(rsp)
}

// DeleteApi217BucketReplicaLinksWithResponse request returning *DeleteApi217BucketReplicaLinksResponse
func (c *ClientWithResponses) DeleteApi217BucketReplicaLinksWithResponse(ctx context.Context, params *DeleteApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketReplicaLinksResponse, error) {
	rsp, err := c.DeleteApi217BucketReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217BucketReplicaLinksResponse(rsp)
}

// GetApi217BucketReplicaLinksWithResponse request returning *GetApi217BucketReplicaLinksResponse
func (c *ClientWithResponses) GetApi217BucketReplicaLinksWithResponse(ctx context.Context, params *GetApi217BucketReplicaLinksParams, reqEditors ...RequestEditorFn) (*GetApi217BucketReplicaLinksResponse, error) {
	rsp, err := c.GetApi217BucketReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketReplicaLinksResponse(rsp)
}

// PatchApi217BucketReplicaLinksWithBodyWithResponse request with arbitrary body returning *PatchApi217BucketReplicaLinksResponse
func (c *ClientWithResponses) PatchApi217BucketReplicaLinksWithBodyWithResponse(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217BucketReplicaLinksResponse, error) {
	rsp, err := c.PatchApi217BucketReplicaLinksWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217BucketReplicaLinksResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217BucketReplicaLinksWithResponse(ctx context.Context, params *PatchApi217BucketReplicaLinksParams, body PatchApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217BucketReplicaLinksResponse, error) {
	rsp, err := c.PatchApi217BucketReplicaLinks(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217BucketReplicaLinksResponse(rsp)
}

// PostApi217BucketReplicaLinksWithBodyWithResponse request with arbitrary body returning *PostApi217BucketReplicaLinksResponse
func (c *ClientWithResponses) PostApi217BucketReplicaLinksWithBodyWithResponse(ctx context.Context, params *PostApi217BucketReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketReplicaLinksResponse, error) {
	rsp, err := c.PostApi217BucketReplicaLinksWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketReplicaLinksResponse(rsp)
}

func (c *ClientWithResponses) PostApi217BucketReplicaLinksWithResponse(ctx context.Context, params *PostApi217BucketReplicaLinksParams, body PostApi217BucketReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketReplicaLinksResponse, error) {
	rsp, err := c.PostApi217BucketReplicaLinks(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketReplicaLinksResponse(rsp)
}

// DeleteApi217BucketsWithResponse request returning *DeleteApi217BucketsResponse
func (c *ClientWithResponses) DeleteApi217BucketsWithResponse(ctx context.Context, params *DeleteApi217BucketsParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsResponse, error) {
	rsp, err := c.DeleteApi217Buckets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217BucketsResponse(rsp)
}

// GetApi217BucketsWithResponse request returning *GetApi217BucketsResponse
func (c *ClientWithResponses) GetApi217BucketsWithResponse(ctx context.Context, params *GetApi217BucketsParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsResponse, error) {
	rsp, err := c.GetApi217Buckets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketsResponse(rsp)
}

// PatchApi217BucketsWithBodyWithResponse request with arbitrary body returning *PatchApi217BucketsResponse
func (c *ClientWithResponses) PatchApi217BucketsWithBodyWithResponse(ctx context.Context, params *PatchApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217BucketsResponse, error) {
	rsp, err := c.PatchApi217BucketsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217BucketsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217BucketsWithResponse(ctx context.Context, params *PatchApi217BucketsParams, body PatchApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217BucketsResponse, error) {
	rsp, err := c.PatchApi217Buckets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217BucketsResponse(rsp)
}

// PostApi217BucketsWithBodyWithResponse request with arbitrary body returning *PostApi217BucketsResponse
func (c *ClientWithResponses) PostApi217BucketsWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsResponse, error) {
	rsp, err := c.PostApi217BucketsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217BucketsWithResponse(ctx context.Context, params *PostApi217BucketsParams, body PostApi217BucketsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsResponse, error) {
	rsp, err := c.PostApi217Buckets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsResponse(rsp)
}

// DeleteApi217BucketsBucketAccessPoliciesWithResponse request returning *DeleteApi217BucketsBucketAccessPoliciesResponse
func (c *ClientWithResponses) DeleteApi217BucketsBucketAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsBucketAccessPoliciesResponse, error) {
	rsp, err := c.DeleteApi217BucketsBucketAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217BucketsBucketAccessPoliciesResponse(rsp)
}

// GetApi217BucketsBucketAccessPoliciesWithResponse request returning *GetApi217BucketsBucketAccessPoliciesResponse
func (c *ClientWithResponses) GetApi217BucketsBucketAccessPoliciesWithResponse(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsBucketAccessPoliciesResponse, error) {
	rsp, err := c.GetApi217BucketsBucketAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketsBucketAccessPoliciesResponse(rsp)
}

// PostApi217BucketsBucketAccessPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217BucketsBucketAccessPoliciesResponse
func (c *ClientWithResponses) PostApi217BucketsBucketAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesResponse, error) {
	rsp, err := c.PostApi217BucketsBucketAccessPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsBucketAccessPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217BucketsBucketAccessPoliciesWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesParams, body PostApi217BucketsBucketAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesResponse, error) {
	rsp, err := c.PostApi217BucketsBucketAccessPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsBucketAccessPoliciesResponse(rsp)
}

// DeleteApi217BucketsBucketAccessPoliciesRulesWithResponse request returning *DeleteApi217BucketsBucketAccessPoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217BucketsBucketAccessPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsBucketAccessPoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217BucketsBucketAccessPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217BucketsBucketAccessPoliciesRulesResponse(rsp)
}

// GetApi217BucketsBucketAccessPoliciesRulesWithResponse request returning *GetApi217BucketsBucketAccessPoliciesRulesResponse
func (c *ClientWithResponses) GetApi217BucketsBucketAccessPoliciesRulesWithResponse(ctx context.Context, params *GetApi217BucketsBucketAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsBucketAccessPoliciesRulesResponse, error) {
	rsp, err := c.GetApi217BucketsBucketAccessPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketsBucketAccessPoliciesRulesResponse(rsp)
}

// PostApi217BucketsBucketAccessPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217BucketsBucketAccessPoliciesRulesResponse
func (c *ClientWithResponses) PostApi217BucketsBucketAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217BucketsBucketAccessPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsBucketAccessPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217BucketsBucketAccessPoliciesRulesWithResponse(ctx context.Context, params *PostApi217BucketsBucketAccessPoliciesRulesParams, body PostApi217BucketsBucketAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsBucketAccessPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217BucketsBucketAccessPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsBucketAccessPoliciesRulesResponse(rsp)
}

// DeleteApi217BucketsCrossOriginResourceSharingPoliciesWithResponse request returning *DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse
func (c *ClientWithResponses) DeleteApi217BucketsCrossOriginResourceSharingPoliciesWithResponse(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse, error) {
	rsp, err := c.DeleteApi217BucketsCrossOriginResourceSharingPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse(rsp)
}

// GetApi217BucketsCrossOriginResourceSharingPoliciesWithResponse request returning *GetApi217BucketsCrossOriginResourceSharingPoliciesResponse
func (c *ClientWithResponses) GetApi217BucketsCrossOriginResourceSharingPoliciesWithResponse(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsCrossOriginResourceSharingPoliciesResponse, error) {
	rsp, err := c.GetApi217BucketsCrossOriginResourceSharingPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketsCrossOriginResourceSharingPoliciesResponse(rsp)
}

// PostApi217BucketsCrossOriginResourceSharingPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217BucketsCrossOriginResourceSharingPoliciesResponse
func (c *ClientWithResponses) PostApi217BucketsCrossOriginResourceSharingPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesResponse, error) {
	rsp, err := c.PostApi217BucketsCrossOriginResourceSharingPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsCrossOriginResourceSharingPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217BucketsCrossOriginResourceSharingPoliciesWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesResponse, error) {
	rsp, err := c.PostApi217BucketsCrossOriginResourceSharingPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsCrossOriginResourceSharingPoliciesResponse(rsp)
}

// DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse request returning *DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse(rsp)
}

// GetApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse request returning *GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse
func (c *ClientWithResponses) GetApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse(ctx context.Context, params *GetApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error) {
	rsp, err := c.GetApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse(rsp)
}

// PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse
func (c *ClientWithResponses) PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse(ctx context.Context, params *PostApi217BucketsCrossOriginResourceSharingPoliciesRulesParams, body PostApi217BucketsCrossOriginResourceSharingPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217BucketsCrossOriginResourceSharingPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse(rsp)
}

// GetApi217BucketsPerformanceWithResponse request returning *GetApi217BucketsPerformanceResponse
func (c *ClientWithResponses) GetApi217BucketsPerformanceWithResponse(ctx context.Context, params *GetApi217BucketsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsPerformanceResponse, error) {
	rsp, err := c.GetApi217BucketsPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketsPerformanceResponse(rsp)
}

// GetApi217BucketsS3SpecificPerformanceWithResponse request returning *GetApi217BucketsS3SpecificPerformanceResponse
func (c *ClientWithResponses) GetApi217BucketsS3SpecificPerformanceWithResponse(ctx context.Context, params *GetApi217BucketsS3SpecificPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217BucketsS3SpecificPerformanceResponse, error) {
	rsp, err := c.GetApi217BucketsS3SpecificPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217BucketsS3SpecificPerformanceResponse(rsp)
}

// DeleteApi217CertificateGroupsWithResponse request returning *DeleteApi217CertificateGroupsResponse
func (c *ClientWithResponses) DeleteApi217CertificateGroupsWithResponse(ctx context.Context, params *DeleteApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificateGroupsResponse, error) {
	rsp, err := c.DeleteApi217CertificateGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217CertificateGroupsResponse(rsp)
}

// GetApi217CertificateGroupsWithResponse request returning *GetApi217CertificateGroupsResponse
func (c *ClientWithResponses) GetApi217CertificateGroupsWithResponse(ctx context.Context, params *GetApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217CertificateGroupsResponse, error) {
	rsp, err := c.GetApi217CertificateGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217CertificateGroupsResponse(rsp)
}

// PostApi217CertificateGroupsWithResponse request returning *PostApi217CertificateGroupsResponse
func (c *ClientWithResponses) PostApi217CertificateGroupsWithResponse(ctx context.Context, params *PostApi217CertificateGroupsParams, reqEditors ...RequestEditorFn) (*PostApi217CertificateGroupsResponse, error) {
	rsp, err := c.PostApi217CertificateGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217CertificateGroupsResponse(rsp)
}

// DeleteApi217CertificateGroupsCertificatesWithResponse request returning *DeleteApi217CertificateGroupsCertificatesResponse
func (c *ClientWithResponses) DeleteApi217CertificateGroupsCertificatesWithResponse(ctx context.Context, params *DeleteApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificateGroupsCertificatesResponse, error) {
	rsp, err := c.DeleteApi217CertificateGroupsCertificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217CertificateGroupsCertificatesResponse(rsp)
}

// GetApi217CertificateGroupsCertificatesWithResponse request returning *GetApi217CertificateGroupsCertificatesResponse
func (c *ClientWithResponses) GetApi217CertificateGroupsCertificatesWithResponse(ctx context.Context, params *GetApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificateGroupsCertificatesResponse, error) {
	rsp, err := c.GetApi217CertificateGroupsCertificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217CertificateGroupsCertificatesResponse(rsp)
}

// PostApi217CertificateGroupsCertificatesWithResponse request returning *PostApi217CertificateGroupsCertificatesResponse
func (c *ClientWithResponses) PostApi217CertificateGroupsCertificatesWithResponse(ctx context.Context, params *PostApi217CertificateGroupsCertificatesParams, reqEditors ...RequestEditorFn) (*PostApi217CertificateGroupsCertificatesResponse, error) {
	rsp, err := c.PostApi217CertificateGroupsCertificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217CertificateGroupsCertificatesResponse(rsp)
}

// GetApi217CertificateGroupsUsesWithResponse request returning *GetApi217CertificateGroupsUsesResponse
func (c *ClientWithResponses) GetApi217CertificateGroupsUsesWithResponse(ctx context.Context, params *GetApi217CertificateGroupsUsesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificateGroupsUsesResponse, error) {
	rsp, err := c.GetApi217CertificateGroupsUses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217CertificateGroupsUsesResponse(rsp)
}

// DeleteApi217CertificatesWithResponse request returning *DeleteApi217CertificatesResponse
func (c *ClientWithResponses) DeleteApi217CertificatesWithResponse(ctx context.Context, params *DeleteApi217CertificatesParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificatesResponse, error) {
	rsp, err := c.DeleteApi217Certificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217CertificatesResponse(rsp)
}

// GetApi217CertificatesWithResponse request returning *GetApi217CertificatesResponse
func (c *ClientWithResponses) GetApi217CertificatesWithResponse(ctx context.Context, params *GetApi217CertificatesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificatesResponse, error) {
	rsp, err := c.GetApi217Certificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217CertificatesResponse(rsp)
}

// PatchApi217CertificatesWithBodyWithResponse request with arbitrary body returning *PatchApi217CertificatesResponse
func (c *ClientWithResponses) PatchApi217CertificatesWithBodyWithResponse(ctx context.Context, params *PatchApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217CertificatesResponse, error) {
	rsp, err := c.PatchApi217CertificatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217CertificatesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217CertificatesWithResponse(ctx context.Context, params *PatchApi217CertificatesParams, body PatchApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217CertificatesResponse, error) {
	rsp, err := c.PatchApi217Certificates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217CertificatesResponse(rsp)
}

// PostApi217CertificatesWithBodyWithResponse request with arbitrary body returning *PostApi217CertificatesResponse
func (c *ClientWithResponses) PostApi217CertificatesWithBodyWithResponse(ctx context.Context, params *PostApi217CertificatesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217CertificatesResponse, error) {
	rsp, err := c.PostApi217CertificatesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217CertificatesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217CertificatesWithResponse(ctx context.Context, params *PostApi217CertificatesParams, body PostApi217CertificatesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217CertificatesResponse, error) {
	rsp, err := c.PostApi217Certificates(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217CertificatesResponse(rsp)
}

// DeleteApi217CertificatesCertificateGroupsWithResponse request returning *DeleteApi217CertificatesCertificateGroupsResponse
func (c *ClientWithResponses) DeleteApi217CertificatesCertificateGroupsWithResponse(ctx context.Context, params *DeleteApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217CertificatesCertificateGroupsResponse, error) {
	rsp, err := c.DeleteApi217CertificatesCertificateGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217CertificatesCertificateGroupsResponse(rsp)
}

// GetApi217CertificatesCertificateGroupsWithResponse request returning *GetApi217CertificatesCertificateGroupsResponse
func (c *ClientWithResponses) GetApi217CertificatesCertificateGroupsWithResponse(ctx context.Context, params *GetApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217CertificatesCertificateGroupsResponse, error) {
	rsp, err := c.GetApi217CertificatesCertificateGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217CertificatesCertificateGroupsResponse(rsp)
}

// PostApi217CertificatesCertificateGroupsWithResponse request returning *PostApi217CertificatesCertificateGroupsResponse
func (c *ClientWithResponses) PostApi217CertificatesCertificateGroupsWithResponse(ctx context.Context, params *PostApi217CertificatesCertificateGroupsParams, reqEditors ...RequestEditorFn) (*PostApi217CertificatesCertificateGroupsResponse, error) {
	rsp, err := c.PostApi217CertificatesCertificateGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217CertificatesCertificateGroupsResponse(rsp)
}

// GetApi217CertificatesUsesWithResponse request returning *GetApi217CertificatesUsesResponse
func (c *ClientWithResponses) GetApi217CertificatesUsesWithResponse(ctx context.Context, params *GetApi217CertificatesUsesParams, reqEditors ...RequestEditorFn) (*GetApi217CertificatesUsesResponse, error) {
	rsp, err := c.GetApi217CertificatesUses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217CertificatesUsesResponse(rsp)
}

// GetApi217DirectoryServicesWithResponse request returning *GetApi217DirectoryServicesResponse
func (c *ClientWithResponses) GetApi217DirectoryServicesWithResponse(ctx context.Context, params *GetApi217DirectoryServicesParams, reqEditors ...RequestEditorFn) (*GetApi217DirectoryServicesResponse, error) {
	rsp, err := c.GetApi217DirectoryServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217DirectoryServicesResponse(rsp)
}

// PatchApi217DirectoryServicesWithBodyWithResponse request with arbitrary body returning *PatchApi217DirectoryServicesResponse
func (c *ClientWithResponses) PatchApi217DirectoryServicesWithBodyWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesResponse, error) {
	rsp, err := c.PatchApi217DirectoryServicesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DirectoryServicesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217DirectoryServicesWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesParams, body PatchApi217DirectoryServicesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesResponse, error) {
	rsp, err := c.PatchApi217DirectoryServices(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DirectoryServicesResponse(rsp)
}

// DeleteApi217DirectoryServicesRolesWithResponse request returning *DeleteApi217DirectoryServicesRolesResponse
func (c *ClientWithResponses) DeleteApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *DeleteApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*DeleteApi217DirectoryServicesRolesResponse, error) {
	rsp, err := c.DeleteApi217DirectoryServicesRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217DirectoryServicesRolesResponse(rsp)
}

// GetApi217DirectoryServicesRolesWithResponse request returning *GetApi217DirectoryServicesRolesResponse
func (c *ClientWithResponses) GetApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *GetApi217DirectoryServicesRolesParams, reqEditors ...RequestEditorFn) (*GetApi217DirectoryServicesRolesResponse, error) {
	rsp, err := c.GetApi217DirectoryServicesRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217DirectoryServicesRolesResponse(rsp)
}

// PatchApi217DirectoryServicesRolesWithBodyWithResponse request with arbitrary body returning *PatchApi217DirectoryServicesRolesResponse
func (c *ClientWithResponses) PatchApi217DirectoryServicesRolesWithBodyWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesRolesResponse, error) {
	rsp, err := c.PatchApi217DirectoryServicesRolesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DirectoryServicesRolesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesRolesParams, body PatchApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesRolesResponse, error) {
	rsp, err := c.PatchApi217DirectoryServicesRoles(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DirectoryServicesRolesResponse(rsp)
}

// PostApi217DirectoryServicesRolesWithBodyWithResponse request with arbitrary body returning *PostApi217DirectoryServicesRolesResponse
func (c *ClientWithResponses) PostApi217DirectoryServicesRolesWithBodyWithResponse(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217DirectoryServicesRolesResponse, error) {
	rsp, err := c.PostApi217DirectoryServicesRolesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217DirectoryServicesRolesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217DirectoryServicesRolesWithResponse(ctx context.Context, params *PostApi217DirectoryServicesRolesParams, body PostApi217DirectoryServicesRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217DirectoryServicesRolesResponse, error) {
	rsp, err := c.PostApi217DirectoryServicesRoles(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217DirectoryServicesRolesResponse(rsp)
}

// GetApi217DirectoryServicesTestWithResponse request returning *GetApi217DirectoryServicesTestResponse
func (c *ClientWithResponses) GetApi217DirectoryServicesTestWithResponse(ctx context.Context, params *GetApi217DirectoryServicesTestParams, reqEditors ...RequestEditorFn) (*GetApi217DirectoryServicesTestResponse, error) {
	rsp, err := c.GetApi217DirectoryServicesTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217DirectoryServicesTestResponse(rsp)
}

// PatchApi217DirectoryServicesTestWithBodyWithResponse request with arbitrary body returning *PatchApi217DirectoryServicesTestResponse
func (c *ClientWithResponses) PatchApi217DirectoryServicesTestWithBodyWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesTestResponse, error) {
	rsp, err := c.PatchApi217DirectoryServicesTestWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DirectoryServicesTestResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217DirectoryServicesTestWithResponse(ctx context.Context, params *PatchApi217DirectoryServicesTestParams, body PatchApi217DirectoryServicesTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DirectoryServicesTestResponse, error) {
	rsp, err := c.PatchApi217DirectoryServicesTest(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DirectoryServicesTestResponse(rsp)
}

// DeleteApi217DnsWithResponse request returning *DeleteApi217DnsResponse
func (c *ClientWithResponses) DeleteApi217DnsWithResponse(ctx context.Context, params *DeleteApi217DnsParams, reqEditors ...RequestEditorFn) (*DeleteApi217DnsResponse, error) {
	rsp, err := c.DeleteApi217Dns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217DnsResponse(rsp)
}

// GetApi217DnsWithResponse request returning *GetApi217DnsResponse
func (c *ClientWithResponses) GetApi217DnsWithResponse(ctx context.Context, params *GetApi217DnsParams, reqEditors ...RequestEditorFn) (*GetApi217DnsResponse, error) {
	rsp, err := c.GetApi217Dns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217DnsResponse(rsp)
}

// PatchApi217DnsWithBodyWithResponse request with arbitrary body returning *PatchApi217DnsResponse
func (c *ClientWithResponses) PatchApi217DnsWithBodyWithResponse(ctx context.Context, params *PatchApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217DnsResponse, error) {
	rsp, err := c.PatchApi217DnsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DnsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217DnsWithResponse(ctx context.Context, params *PatchApi217DnsParams, body PatchApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217DnsResponse, error) {
	rsp, err := c.PatchApi217Dns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217DnsResponse(rsp)
}

// PostApi217DnsWithBodyWithResponse request with arbitrary body returning *PostApi217DnsResponse
func (c *ClientWithResponses) PostApi217DnsWithBodyWithResponse(ctx context.Context, params *PostApi217DnsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217DnsResponse, error) {
	rsp, err := c.PostApi217DnsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217DnsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217DnsWithResponse(ctx context.Context, params *PostApi217DnsParams, body PostApi217DnsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217DnsResponse, error) {
	rsp, err := c.PostApi217Dns(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217DnsResponse(rsp)
}

// GetApi217DrivesWithResponse request returning *GetApi217DrivesResponse
func (c *ClientWithResponses) GetApi217DrivesWithResponse(ctx context.Context, params *GetApi217DrivesParams, reqEditors ...RequestEditorFn) (*GetApi217DrivesResponse, error) {
	rsp, err := c.GetApi217Drives(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217DrivesResponse(rsp)
}

// DeleteApi217FileSystemExportsWithResponse request returning *DeleteApi217FileSystemExportsResponse
func (c *ClientWithResponses) DeleteApi217FileSystemExportsWithResponse(ctx context.Context, params *DeleteApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemExportsResponse, error) {
	rsp, err := c.DeleteApi217FileSystemExports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemExportsResponse(rsp)
}

// GetApi217FileSystemExportsWithResponse request returning *GetApi217FileSystemExportsResponse
func (c *ClientWithResponses) GetApi217FileSystemExportsWithResponse(ctx context.Context, params *GetApi217FileSystemExportsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemExportsResponse, error) {
	rsp, err := c.GetApi217FileSystemExports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemExportsResponse(rsp)
}

// PatchApi217FileSystemExportsWithBodyWithResponse request with arbitrary body returning *PatchApi217FileSystemExportsResponse
func (c *ClientWithResponses) PatchApi217FileSystemExportsWithBodyWithResponse(ctx context.Context, params *PatchApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemExportsResponse, error) {
	rsp, err := c.PatchApi217FileSystemExportsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FileSystemExportsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217FileSystemExportsWithResponse(ctx context.Context, params *PatchApi217FileSystemExportsParams, body PatchApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemExportsResponse, error) {
	rsp, err := c.PatchApi217FileSystemExports(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FileSystemExportsResponse(rsp)
}

// PostApi217FileSystemExportsWithBodyWithResponse request with arbitrary body returning *PostApi217FileSystemExportsResponse
func (c *ClientWithResponses) PostApi217FileSystemExportsWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemExportsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemExportsResponse, error) {
	rsp, err := c.PostApi217FileSystemExportsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemExportsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217FileSystemExportsWithResponse(ctx context.Context, params *PostApi217FileSystemExportsParams, body PostApi217FileSystemExportsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemExportsResponse, error) {
	rsp, err := c.PostApi217FileSystemExports(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemExportsResponse(rsp)
}

// DeleteApi217FileSystemReplicaLinksWithResponse request returning *DeleteApi217FileSystemReplicaLinksResponse
func (c *ClientWithResponses) DeleteApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemReplicaLinksResponse, error) {
	rsp, err := c.DeleteApi217FileSystemReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemReplicaLinksResponse(rsp)
}

// GetApi217FileSystemReplicaLinksWithResponse request returning *GetApi217FileSystemReplicaLinksResponse
func (c *ClientWithResponses) GetApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *GetApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemReplicaLinksResponse, error) {
	rsp, err := c.GetApi217FileSystemReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemReplicaLinksResponse(rsp)
}

// PatchApi217FileSystemReplicaLinksWithResponse request returning *PatchApi217FileSystemReplicaLinksResponse
func (c *ClientWithResponses) PatchApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *PatchApi217FileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemReplicaLinksResponse, error) {
	rsp, err := c.PatchApi217FileSystemReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FileSystemReplicaLinksResponse(rsp)
}

// PostApi217FileSystemReplicaLinksWithBodyWithResponse request with arbitrary body returning *PostApi217FileSystemReplicaLinksResponse
func (c *ClientWithResponses) PostApi217FileSystemReplicaLinksWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemReplicaLinksResponse, error) {
	rsp, err := c.PostApi217FileSystemReplicaLinksWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemReplicaLinksResponse(rsp)
}

func (c *ClientWithResponses) PostApi217FileSystemReplicaLinksWithResponse(ctx context.Context, params *PostApi217FileSystemReplicaLinksParams, body PostApi217FileSystemReplicaLinksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemReplicaLinksResponse, error) {
	rsp, err := c.PostApi217FileSystemReplicaLinks(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemReplicaLinksResponse(rsp)
}

// DeleteApi217FileSystemReplicaLinksPoliciesWithResponse request returning *DeleteApi217FileSystemReplicaLinksPoliciesResponse
func (c *ClientWithResponses) DeleteApi217FileSystemReplicaLinksPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemReplicaLinksPoliciesResponse, error) {
	rsp, err := c.DeleteApi217FileSystemReplicaLinksPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemReplicaLinksPoliciesResponse(rsp)
}

// GetApi217FileSystemReplicaLinksPoliciesWithResponse request returning *GetApi217FileSystemReplicaLinksPoliciesResponse
func (c *ClientWithResponses) GetApi217FileSystemReplicaLinksPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemReplicaLinksPoliciesResponse, error) {
	rsp, err := c.GetApi217FileSystemReplicaLinksPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemReplicaLinksPoliciesResponse(rsp)
}

// PostApi217FileSystemReplicaLinksPoliciesWithResponse request returning *PostApi217FileSystemReplicaLinksPoliciesResponse
func (c *ClientWithResponses) PostApi217FileSystemReplicaLinksPoliciesWithResponse(ctx context.Context, params *PostApi217FileSystemReplicaLinksPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemReplicaLinksPoliciesResponse, error) {
	rsp, err := c.PostApi217FileSystemReplicaLinksPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemReplicaLinksPoliciesResponse(rsp)
}

// GetApi217FileSystemReplicaLinksTransferWithResponse request returning *GetApi217FileSystemReplicaLinksTransferResponse
func (c *ClientWithResponses) GetApi217FileSystemReplicaLinksTransferWithResponse(ctx context.Context, params *GetApi217FileSystemReplicaLinksTransferParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemReplicaLinksTransferResponse, error) {
	rsp, err := c.GetApi217FileSystemReplicaLinksTransfer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemReplicaLinksTransferResponse(rsp)
}

// DeleteApi217FileSystemSnapshotsWithResponse request returning *DeleteApi217FileSystemSnapshotsResponse
func (c *ClientWithResponses) DeleteApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *DeleteApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemSnapshotsResponse, error) {
	rsp, err := c.DeleteApi217FileSystemSnapshots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemSnapshotsResponse(rsp)
}

// GetApi217FileSystemSnapshotsWithResponse request returning *GetApi217FileSystemSnapshotsResponse
func (c *ClientWithResponses) GetApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *GetApi217FileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemSnapshotsResponse, error) {
	rsp, err := c.GetApi217FileSystemSnapshots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemSnapshotsResponse(rsp)
}

// PatchApi217FileSystemSnapshotsWithBodyWithResponse request with arbitrary body returning *PatchApi217FileSystemSnapshotsResponse
func (c *ClientWithResponses) PatchApi217FileSystemSnapshotsWithBodyWithResponse(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemSnapshotsResponse, error) {
	rsp, err := c.PatchApi217FileSystemSnapshotsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FileSystemSnapshotsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *PatchApi217FileSystemSnapshotsParams, body PatchApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemSnapshotsResponse, error) {
	rsp, err := c.PatchApi217FileSystemSnapshots(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FileSystemSnapshotsResponse(rsp)
}

// PostApi217FileSystemSnapshotsWithBodyWithResponse request with arbitrary body returning *PostApi217FileSystemSnapshotsResponse
func (c *ClientWithResponses) PostApi217FileSystemSnapshotsWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemSnapshotsResponse, error) {
	rsp, err := c.PostApi217FileSystemSnapshotsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemSnapshotsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217FileSystemSnapshotsWithResponse(ctx context.Context, params *PostApi217FileSystemSnapshotsParams, body PostApi217FileSystemSnapshotsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemSnapshotsResponse, error) {
	rsp, err := c.PostApi217FileSystemSnapshots(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemSnapshotsResponse(rsp)
}

// DeleteApi217FileSystemSnapshotsPoliciesWithResponse request returning *DeleteApi217FileSystemSnapshotsPoliciesResponse
func (c *ClientWithResponses) DeleteApi217FileSystemSnapshotsPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemSnapshotsPoliciesResponse, error) {
	rsp, err := c.DeleteApi217FileSystemSnapshotsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemSnapshotsPoliciesResponse(rsp)
}

// GetApi217FileSystemSnapshotsPoliciesWithResponse request returning *GetApi217FileSystemSnapshotsPoliciesResponse
func (c *ClientWithResponses) GetApi217FileSystemSnapshotsPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemSnapshotsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemSnapshotsPoliciesResponse, error) {
	rsp, err := c.GetApi217FileSystemSnapshotsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemSnapshotsPoliciesResponse(rsp)
}

// DeleteApi217FileSystemSnapshotsTransferWithResponse request returning *DeleteApi217FileSystemSnapshotsTransferResponse
func (c *ClientWithResponses) DeleteApi217FileSystemSnapshotsTransferWithResponse(ctx context.Context, params *DeleteApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemSnapshotsTransferResponse, error) {
	rsp, err := c.DeleteApi217FileSystemSnapshotsTransfer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemSnapshotsTransferResponse(rsp)
}

// GetApi217FileSystemSnapshotsTransferWithResponse request returning *GetApi217FileSystemSnapshotsTransferResponse
func (c *ClientWithResponses) GetApi217FileSystemSnapshotsTransferWithResponse(ctx context.Context, params *GetApi217FileSystemSnapshotsTransferParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemSnapshotsTransferResponse, error) {
	rsp, err := c.GetApi217FileSystemSnapshotsTransfer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemSnapshotsTransferResponse(rsp)
}

// DeleteApi217FileSystemsWithResponse request returning *DeleteApi217FileSystemsResponse
func (c *ClientWithResponses) DeleteApi217FileSystemsWithResponse(ctx context.Context, params *DeleteApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsResponse, error) {
	rsp, err := c.DeleteApi217FileSystems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemsResponse(rsp)
}

// GetApi217FileSystemsWithResponse request returning *GetApi217FileSystemsResponse
func (c *ClientWithResponses) GetApi217FileSystemsWithResponse(ctx context.Context, params *GetApi217FileSystemsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsResponse, error) {
	rsp, err := c.GetApi217FileSystems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsResponse(rsp)
}

// PatchApi217FileSystemsWithBodyWithResponse request with arbitrary body returning *PatchApi217FileSystemsResponse
func (c *ClientWithResponses) PatchApi217FileSystemsWithBodyWithResponse(ctx context.Context, params *PatchApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemsResponse, error) {
	rsp, err := c.PatchApi217FileSystemsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FileSystemsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217FileSystemsWithResponse(ctx context.Context, params *PatchApi217FileSystemsParams, body PatchApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FileSystemsResponse, error) {
	rsp, err := c.PatchApi217FileSystems(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FileSystemsResponse(rsp)
}

// PostApi217FileSystemsWithBodyWithResponse request with arbitrary body returning *PostApi217FileSystemsResponse
func (c *ClientWithResponses) PostApi217FileSystemsWithBodyWithResponse(ctx context.Context, params *PostApi217FileSystemsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsResponse, error) {
	rsp, err := c.PostApi217FileSystemsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217FileSystemsWithResponse(ctx context.Context, params *PostApi217FileSystemsParams, body PostApi217FileSystemsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsResponse, error) {
	rsp, err := c.PostApi217FileSystems(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemsResponse(rsp)
}

// DeleteApi217FileSystemsAuditPoliciesWithResponse request returning *DeleteApi217FileSystemsAuditPoliciesResponse
func (c *ClientWithResponses) DeleteApi217FileSystemsAuditPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsAuditPoliciesResponse, error) {
	rsp, err := c.DeleteApi217FileSystemsAuditPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemsAuditPoliciesResponse(rsp)
}

// GetApi217FileSystemsAuditPoliciesWithResponse request returning *GetApi217FileSystemsAuditPoliciesResponse
func (c *ClientWithResponses) GetApi217FileSystemsAuditPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsAuditPoliciesResponse, error) {
	rsp, err := c.GetApi217FileSystemsAuditPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsAuditPoliciesResponse(rsp)
}

// PostApi217FileSystemsAuditPoliciesWithResponse request returning *PostApi217FileSystemsAuditPoliciesResponse
func (c *ClientWithResponses) PostApi217FileSystemsAuditPoliciesWithResponse(ctx context.Context, params *PostApi217FileSystemsAuditPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsAuditPoliciesResponse, error) {
	rsp, err := c.PostApi217FileSystemsAuditPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemsAuditPoliciesResponse(rsp)
}

// GetApi217FileSystemsGroupsPerformanceWithResponse request returning *GetApi217FileSystemsGroupsPerformanceResponse
func (c *ClientWithResponses) GetApi217FileSystemsGroupsPerformanceWithResponse(ctx context.Context, params *GetApi217FileSystemsGroupsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsGroupsPerformanceResponse, error) {
	rsp, err := c.GetApi217FileSystemsGroupsPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsGroupsPerformanceResponse(rsp)
}

// DeleteApi217FileSystemsLocksWithResponse request returning *DeleteApi217FileSystemsLocksResponse
func (c *ClientWithResponses) DeleteApi217FileSystemsLocksWithResponse(ctx context.Context, params *DeleteApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsLocksResponse, error) {
	rsp, err := c.DeleteApi217FileSystemsLocks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemsLocksResponse(rsp)
}

// GetApi217FileSystemsLocksWithResponse request returning *GetApi217FileSystemsLocksResponse
func (c *ClientWithResponses) GetApi217FileSystemsLocksWithResponse(ctx context.Context, params *GetApi217FileSystemsLocksParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsLocksResponse, error) {
	rsp, err := c.GetApi217FileSystemsLocks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsLocksResponse(rsp)
}

// GetApi217FileSystemsLocksClientsWithResponse request returning *GetApi217FileSystemsLocksClientsResponse
func (c *ClientWithResponses) GetApi217FileSystemsLocksClientsWithResponse(ctx context.Context, params *GetApi217FileSystemsLocksClientsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsLocksClientsResponse, error) {
	rsp, err := c.GetApi217FileSystemsLocksClients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsLocksClientsResponse(rsp)
}

// PostApi217FileSystemsLocksNlmReclamationsWithResponse request returning *PostApi217FileSystemsLocksNlmReclamationsResponse
func (c *ClientWithResponses) PostApi217FileSystemsLocksNlmReclamationsWithResponse(ctx context.Context, params *PostApi217FileSystemsLocksNlmReclamationsParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsLocksNlmReclamationsResponse, error) {
	rsp, err := c.PostApi217FileSystemsLocksNlmReclamations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemsLocksNlmReclamationsResponse(rsp)
}

// DeleteApi217FileSystemsOpenFilesWithResponse request returning *DeleteApi217FileSystemsOpenFilesResponse
func (c *ClientWithResponses) DeleteApi217FileSystemsOpenFilesWithResponse(ctx context.Context, params *DeleteApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsOpenFilesResponse, error) {
	rsp, err := c.DeleteApi217FileSystemsOpenFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemsOpenFilesResponse(rsp)
}

// GetApi217FileSystemsOpenFilesWithResponse request returning *GetApi217FileSystemsOpenFilesResponse
func (c *ClientWithResponses) GetApi217FileSystemsOpenFilesWithResponse(ctx context.Context, params *GetApi217FileSystemsOpenFilesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsOpenFilesResponse, error) {
	rsp, err := c.GetApi217FileSystemsOpenFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsOpenFilesResponse(rsp)
}

// GetApi217FileSystemsPerformanceWithResponse request returning *GetApi217FileSystemsPerformanceResponse
func (c *ClientWithResponses) GetApi217FileSystemsPerformanceWithResponse(ctx context.Context, params *GetApi217FileSystemsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsPerformanceResponse, error) {
	rsp, err := c.GetApi217FileSystemsPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsPerformanceResponse(rsp)
}

// DeleteApi217FileSystemsPoliciesWithResponse request returning *DeleteApi217FileSystemsPoliciesResponse
func (c *ClientWithResponses) DeleteApi217FileSystemsPoliciesWithResponse(ctx context.Context, params *DeleteApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsPoliciesResponse, error) {
	rsp, err := c.DeleteApi217FileSystemsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemsPoliciesResponse(rsp)
}

// GetApi217FileSystemsPoliciesWithResponse request returning *GetApi217FileSystemsPoliciesResponse
func (c *ClientWithResponses) GetApi217FileSystemsPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsPoliciesResponse, error) {
	rsp, err := c.GetApi217FileSystemsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsPoliciesResponse(rsp)
}

// PostApi217FileSystemsPoliciesWithResponse request returning *PostApi217FileSystemsPoliciesResponse
func (c *ClientWithResponses) PostApi217FileSystemsPoliciesWithResponse(ctx context.Context, params *PostApi217FileSystemsPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217FileSystemsPoliciesResponse, error) {
	rsp, err := c.PostApi217FileSystemsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FileSystemsPoliciesResponse(rsp)
}

// GetApi217FileSystemsPoliciesAllWithResponse request returning *GetApi217FileSystemsPoliciesAllResponse
func (c *ClientWithResponses) GetApi217FileSystemsPoliciesAllWithResponse(ctx context.Context, params *GetApi217FileSystemsPoliciesAllParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsPoliciesAllResponse, error) {
	rsp, err := c.GetApi217FileSystemsPoliciesAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsPoliciesAllResponse(rsp)
}

// DeleteApi217FileSystemsSessionsWithResponse request returning *DeleteApi217FileSystemsSessionsResponse
func (c *ClientWithResponses) DeleteApi217FileSystemsSessionsWithResponse(ctx context.Context, params *DeleteApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FileSystemsSessionsResponse, error) {
	rsp, err := c.DeleteApi217FileSystemsSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FileSystemsSessionsResponse(rsp)
}

// GetApi217FileSystemsSessionsWithResponse request returning *GetApi217FileSystemsSessionsResponse
func (c *ClientWithResponses) GetApi217FileSystemsSessionsWithResponse(ctx context.Context, params *GetApi217FileSystemsSessionsParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsSessionsResponse, error) {
	rsp, err := c.GetApi217FileSystemsSessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsSessionsResponse(rsp)
}

// GetApi217FileSystemsUsersPerformanceWithResponse request returning *GetApi217FileSystemsUsersPerformanceResponse
func (c *ClientWithResponses) GetApi217FileSystemsUsersPerformanceWithResponse(ctx context.Context, params *GetApi217FileSystemsUsersPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsUsersPerformanceResponse, error) {
	rsp, err := c.GetApi217FileSystemsUsersPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsUsersPerformanceResponse(rsp)
}

// GetApi217FileSystemsWormDataPoliciesWithResponse request returning *GetApi217FileSystemsWormDataPoliciesResponse
func (c *ClientWithResponses) GetApi217FileSystemsWormDataPoliciesWithResponse(ctx context.Context, params *GetApi217FileSystemsWormDataPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217FileSystemsWormDataPoliciesResponse, error) {
	rsp, err := c.GetApi217FileSystemsWormDataPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FileSystemsWormDataPoliciesResponse(rsp)
}

// DeleteApi217FleetsWithResponse request returning *DeleteApi217FleetsResponse
func (c *ClientWithResponses) DeleteApi217FleetsWithResponse(ctx context.Context, params *DeleteApi217FleetsParams, reqEditors ...RequestEditorFn) (*DeleteApi217FleetsResponse, error) {
	rsp, err := c.DeleteApi217Fleets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FleetsResponse(rsp)
}

// GetApi217FleetsWithResponse request returning *GetApi217FleetsResponse
func (c *ClientWithResponses) GetApi217FleetsWithResponse(ctx context.Context, params *GetApi217FleetsParams, reqEditors ...RequestEditorFn) (*GetApi217FleetsResponse, error) {
	rsp, err := c.GetApi217Fleets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FleetsResponse(rsp)
}

// PatchApi217FleetsWithBodyWithResponse request with arbitrary body returning *PatchApi217FleetsResponse
func (c *ClientWithResponses) PatchApi217FleetsWithBodyWithResponse(ctx context.Context, params *PatchApi217FleetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217FleetsResponse, error) {
	rsp, err := c.PatchApi217FleetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FleetsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217FleetsWithResponse(ctx context.Context, params *PatchApi217FleetsParams, body PatchApi217FleetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217FleetsResponse, error) {
	rsp, err := c.PatchApi217Fleets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217FleetsResponse(rsp)
}

// PostApi217FleetsWithResponse request returning *PostApi217FleetsResponse
func (c *ClientWithResponses) PostApi217FleetsWithResponse(ctx context.Context, params *PostApi217FleetsParams, reqEditors ...RequestEditorFn) (*PostApi217FleetsResponse, error) {
	rsp, err := c.PostApi217Fleets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FleetsResponse(rsp)
}

// GetApi217FleetsFleetKeyWithResponse request returning *GetApi217FleetsFleetKeyResponse
func (c *ClientWithResponses) GetApi217FleetsFleetKeyWithResponse(ctx context.Context, params *GetApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*GetApi217FleetsFleetKeyResponse, error) {
	rsp, err := c.GetApi217FleetsFleetKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FleetsFleetKeyResponse(rsp)
}

// PostApi217FleetsFleetKeyWithResponse request returning *PostApi217FleetsFleetKeyResponse
func (c *ClientWithResponses) PostApi217FleetsFleetKeyWithResponse(ctx context.Context, params *PostApi217FleetsFleetKeyParams, reqEditors ...RequestEditorFn) (*PostApi217FleetsFleetKeyResponse, error) {
	rsp, err := c.PostApi217FleetsFleetKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FleetsFleetKeyResponse(rsp)
}

// DeleteApi217FleetsMembersWithResponse request returning *DeleteApi217FleetsMembersResponse
func (c *ClientWithResponses) DeleteApi217FleetsMembersWithResponse(ctx context.Context, params *DeleteApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*DeleteApi217FleetsMembersResponse, error) {
	rsp, err := c.DeleteApi217FleetsMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217FleetsMembersResponse(rsp)
}

// GetApi217FleetsMembersWithResponse request returning *GetApi217FleetsMembersResponse
func (c *ClientWithResponses) GetApi217FleetsMembersWithResponse(ctx context.Context, params *GetApi217FleetsMembersParams, reqEditors ...RequestEditorFn) (*GetApi217FleetsMembersResponse, error) {
	rsp, err := c.GetApi217FleetsMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217FleetsMembersResponse(rsp)
}

// PostApi217FleetsMembersWithBodyWithResponse request with arbitrary body returning *PostApi217FleetsMembersResponse
func (c *ClientWithResponses) PostApi217FleetsMembersWithBodyWithResponse(ctx context.Context, params *PostApi217FleetsMembersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217FleetsMembersResponse, error) {
	rsp, err := c.PostApi217FleetsMembersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FleetsMembersResponse(rsp)
}

func (c *ClientWithResponses) PostApi217FleetsMembersWithResponse(ctx context.Context, params *PostApi217FleetsMembersParams, body PostApi217FleetsMembersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217FleetsMembersResponse, error) {
	rsp, err := c.PostApi217FleetsMembers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217FleetsMembersResponse(rsp)
}

// GetApi217HardwareWithResponse request returning *GetApi217HardwareResponse
func (c *ClientWithResponses) GetApi217HardwareWithResponse(ctx context.Context, params *GetApi217HardwareParams, reqEditors ...RequestEditorFn) (*GetApi217HardwareResponse, error) {
	rsp, err := c.GetApi217Hardware(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217HardwareResponse(rsp)
}

// PatchApi217HardwareWithBodyWithResponse request with arbitrary body returning *PatchApi217HardwareResponse
func (c *ClientWithResponses) PatchApi217HardwareWithBodyWithResponse(ctx context.Context, params *PatchApi217HardwareParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217HardwareResponse, error) {
	rsp, err := c.PatchApi217HardwareWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217HardwareResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217HardwareWithResponse(ctx context.Context, params *PatchApi217HardwareParams, body PatchApi217HardwareJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217HardwareResponse, error) {
	rsp, err := c.PatchApi217Hardware(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217HardwareResponse(rsp)
}

// GetApi217HardwareConnectorsWithResponse request returning *GetApi217HardwareConnectorsResponse
func (c *ClientWithResponses) GetApi217HardwareConnectorsWithResponse(ctx context.Context, params *GetApi217HardwareConnectorsParams, reqEditors ...RequestEditorFn) (*GetApi217HardwareConnectorsResponse, error) {
	rsp, err := c.GetApi217HardwareConnectors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217HardwareConnectorsResponse(rsp)
}

// PatchApi217HardwareConnectorsWithBodyWithResponse request with arbitrary body returning *PatchApi217HardwareConnectorsResponse
func (c *ClientWithResponses) PatchApi217HardwareConnectorsWithBodyWithResponse(ctx context.Context, params *PatchApi217HardwareConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217HardwareConnectorsResponse, error) {
	rsp, err := c.PatchApi217HardwareConnectorsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217HardwareConnectorsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217HardwareConnectorsWithResponse(ctx context.Context, params *PatchApi217HardwareConnectorsParams, body PatchApi217HardwareConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217HardwareConnectorsResponse, error) {
	rsp, err := c.PatchApi217HardwareConnectors(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217HardwareConnectorsResponse(rsp)
}

// GetApi217HardwareConnectorsPerformanceWithResponse request returning *GetApi217HardwareConnectorsPerformanceResponse
func (c *ClientWithResponses) GetApi217HardwareConnectorsPerformanceWithResponse(ctx context.Context, params *GetApi217HardwareConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217HardwareConnectorsPerformanceResponse, error) {
	rsp, err := c.GetApi217HardwareConnectorsPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217HardwareConnectorsPerformanceResponse(rsp)
}

// DeleteApi217KeytabsWithResponse request returning *DeleteApi217KeytabsResponse
func (c *ClientWithResponses) DeleteApi217KeytabsWithResponse(ctx context.Context, params *DeleteApi217KeytabsParams, reqEditors ...RequestEditorFn) (*DeleteApi217KeytabsResponse, error) {
	rsp, err := c.DeleteApi217Keytabs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217KeytabsResponse(rsp)
}

// GetApi217KeytabsWithResponse request returning *GetApi217KeytabsResponse
func (c *ClientWithResponses) GetApi217KeytabsWithResponse(ctx context.Context, params *GetApi217KeytabsParams, reqEditors ...RequestEditorFn) (*GetApi217KeytabsResponse, error) {
	rsp, err := c.GetApi217Keytabs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217KeytabsResponse(rsp)
}

// PostApi217KeytabsWithBodyWithResponse request with arbitrary body returning *PostApi217KeytabsResponse
func (c *ClientWithResponses) PostApi217KeytabsWithBodyWithResponse(ctx context.Context, params *PostApi217KeytabsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217KeytabsResponse, error) {
	rsp, err := c.PostApi217KeytabsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217KeytabsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217KeytabsWithResponse(ctx context.Context, params *PostApi217KeytabsParams, body PostApi217KeytabsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217KeytabsResponse, error) {
	rsp, err := c.PostApi217Keytabs(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217KeytabsResponse(rsp)
}

// GetApi217KeytabsDownloadWithResponse request returning *GetApi217KeytabsDownloadResponse
func (c *ClientWithResponses) GetApi217KeytabsDownloadWithResponse(ctx context.Context, params *GetApi217KeytabsDownloadParams, reqEditors ...RequestEditorFn) (*GetApi217KeytabsDownloadResponse, error) {
	rsp, err := c.GetApi217KeytabsDownload(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217KeytabsDownloadResponse(rsp)
}

// PostApi217KeytabsUploadWithBodyWithResponse request with arbitrary body returning *PostApi217KeytabsUploadResponse
func (c *ClientWithResponses) PostApi217KeytabsUploadWithBodyWithResponse(ctx context.Context, params *PostApi217KeytabsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217KeytabsUploadResponse, error) {
	rsp, err := c.PostApi217KeytabsUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217KeytabsUploadResponse(rsp)
}

// DeleteApi217KmipWithResponse request returning *DeleteApi217KmipResponse
func (c *ClientWithResponses) DeleteApi217KmipWithResponse(ctx context.Context, params *DeleteApi217KmipParams, reqEditors ...RequestEditorFn) (*DeleteApi217KmipResponse, error) {
	rsp, err := c.DeleteApi217Kmip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217KmipResponse(rsp)
}

// GetApi217KmipWithResponse request returning *GetApi217KmipResponse
func (c *ClientWithResponses) GetApi217KmipWithResponse(ctx context.Context, params *GetApi217KmipParams, reqEditors ...RequestEditorFn) (*GetApi217KmipResponse, error) {
	rsp, err := c.GetApi217Kmip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217KmipResponse(rsp)
}

// PatchApi217KmipWithBodyWithResponse request with arbitrary body returning *PatchApi217KmipResponse
func (c *ClientWithResponses) PatchApi217KmipWithBodyWithResponse(ctx context.Context, params *PatchApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217KmipResponse, error) {
	rsp, err := c.PatchApi217KmipWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217KmipResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217KmipWithResponse(ctx context.Context, params *PatchApi217KmipParams, body PatchApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217KmipResponse, error) {
	rsp, err := c.PatchApi217Kmip(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217KmipResponse(rsp)
}

// PostApi217KmipWithBodyWithResponse request with arbitrary body returning *PostApi217KmipResponse
func (c *ClientWithResponses) PostApi217KmipWithBodyWithResponse(ctx context.Context, params *PostApi217KmipParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217KmipResponse, error) {
	rsp, err := c.PostApi217KmipWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217KmipResponse(rsp)
}

func (c *ClientWithResponses) PostApi217KmipWithResponse(ctx context.Context, params *PostApi217KmipParams, body PostApi217KmipJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217KmipResponse, error) {
	rsp, err := c.PostApi217Kmip(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217KmipResponse(rsp)
}

// GetApi217KmipTestWithResponse request returning *GetApi217KmipTestResponse
func (c *ClientWithResponses) GetApi217KmipTestWithResponse(ctx context.Context, params *GetApi217KmipTestParams, reqEditors ...RequestEditorFn) (*GetApi217KmipTestResponse, error) {
	rsp, err := c.GetApi217KmipTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217KmipTestResponse(rsp)
}

// DeleteApi217LegalHoldsWithResponse request returning *DeleteApi217LegalHoldsResponse
func (c *ClientWithResponses) DeleteApi217LegalHoldsWithResponse(ctx context.Context, params *DeleteApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*DeleteApi217LegalHoldsResponse, error) {
	rsp, err := c.DeleteApi217LegalHolds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217LegalHoldsResponse(rsp)
}

// GetApi217LegalHoldsWithResponse request returning *GetApi217LegalHoldsResponse
func (c *ClientWithResponses) GetApi217LegalHoldsWithResponse(ctx context.Context, params *GetApi217LegalHoldsParams, reqEditors ...RequestEditorFn) (*GetApi217LegalHoldsResponse, error) {
	rsp, err := c.GetApi217LegalHolds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217LegalHoldsResponse(rsp)
}

// PatchApi217LegalHoldsWithBodyWithResponse request with arbitrary body returning *PatchApi217LegalHoldsResponse
func (c *ClientWithResponses) PatchApi217LegalHoldsWithBodyWithResponse(ctx context.Context, params *PatchApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LegalHoldsResponse, error) {
	rsp, err := c.PatchApi217LegalHoldsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LegalHoldsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217LegalHoldsWithResponse(ctx context.Context, params *PatchApi217LegalHoldsParams, body PatchApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LegalHoldsResponse, error) {
	rsp, err := c.PatchApi217LegalHolds(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LegalHoldsResponse(rsp)
}

// PostApi217LegalHoldsWithBodyWithResponse request with arbitrary body returning *PostApi217LegalHoldsResponse
func (c *ClientWithResponses) PostApi217LegalHoldsWithBodyWithResponse(ctx context.Context, params *PostApi217LegalHoldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217LegalHoldsResponse, error) {
	rsp, err := c.PostApi217LegalHoldsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217LegalHoldsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217LegalHoldsWithResponse(ctx context.Context, params *PostApi217LegalHoldsParams, body PostApi217LegalHoldsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217LegalHoldsResponse, error) {
	rsp, err := c.PostApi217LegalHolds(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217LegalHoldsResponse(rsp)
}

// GetApi217LegalHoldsHeldEntitiesWithResponse request returning *GetApi217LegalHoldsHeldEntitiesResponse
func (c *ClientWithResponses) GetApi217LegalHoldsHeldEntitiesWithResponse(ctx context.Context, params *GetApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*GetApi217LegalHoldsHeldEntitiesResponse, error) {
	rsp, err := c.GetApi217LegalHoldsHeldEntities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217LegalHoldsHeldEntitiesResponse(rsp)
}

// PatchApi217LegalHoldsHeldEntitiesWithResponse request returning *PatchApi217LegalHoldsHeldEntitiesResponse
func (c *ClientWithResponses) PatchApi217LegalHoldsHeldEntitiesWithResponse(ctx context.Context, params *PatchApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*PatchApi217LegalHoldsHeldEntitiesResponse, error) {
	rsp, err := c.PatchApi217LegalHoldsHeldEntities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LegalHoldsHeldEntitiesResponse(rsp)
}

// PostApi217LegalHoldsHeldEntitiesWithResponse request returning *PostApi217LegalHoldsHeldEntitiesResponse
func (c *ClientWithResponses) PostApi217LegalHoldsHeldEntitiesWithResponse(ctx context.Context, params *PostApi217LegalHoldsHeldEntitiesParams, reqEditors ...RequestEditorFn) (*PostApi217LegalHoldsHeldEntitiesResponse, error) {
	rsp, err := c.PostApi217LegalHoldsHeldEntities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217LegalHoldsHeldEntitiesResponse(rsp)
}

// DeleteApi217LifecycleRulesWithResponse request returning *DeleteApi217LifecycleRulesResponse
func (c *ClientWithResponses) DeleteApi217LifecycleRulesWithResponse(ctx context.Context, params *DeleteApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217LifecycleRulesResponse, error) {
	rsp, err := c.DeleteApi217LifecycleRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217LifecycleRulesResponse(rsp)
}

// GetApi217LifecycleRulesWithResponse request returning *GetApi217LifecycleRulesResponse
func (c *ClientWithResponses) GetApi217LifecycleRulesWithResponse(ctx context.Context, params *GetApi217LifecycleRulesParams, reqEditors ...RequestEditorFn) (*GetApi217LifecycleRulesResponse, error) {
	rsp, err := c.GetApi217LifecycleRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217LifecycleRulesResponse(rsp)
}

// PatchApi217LifecycleRulesWithBodyWithResponse request with arbitrary body returning *PatchApi217LifecycleRulesResponse
func (c *ClientWithResponses) PatchApi217LifecycleRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LifecycleRulesResponse, error) {
	rsp, err := c.PatchApi217LifecycleRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LifecycleRulesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217LifecycleRulesWithResponse(ctx context.Context, params *PatchApi217LifecycleRulesParams, body PatchApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LifecycleRulesResponse, error) {
	rsp, err := c.PatchApi217LifecycleRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LifecycleRulesResponse(rsp)
}

// PostApi217LifecycleRulesWithBodyWithResponse request with arbitrary body returning *PostApi217LifecycleRulesResponse
func (c *ClientWithResponses) PostApi217LifecycleRulesWithBodyWithResponse(ctx context.Context, params *PostApi217LifecycleRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217LifecycleRulesResponse, error) {
	rsp, err := c.PostApi217LifecycleRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217LifecycleRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217LifecycleRulesWithResponse(ctx context.Context, params *PostApi217LifecycleRulesParams, body PostApi217LifecycleRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217LifecycleRulesResponse, error) {
	rsp, err := c.PostApi217LifecycleRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217LifecycleRulesResponse(rsp)
}

// DeleteApi217LinkAggregationGroupsWithResponse request returning *DeleteApi217LinkAggregationGroupsResponse
func (c *ClientWithResponses) DeleteApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *DeleteApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217LinkAggregationGroupsResponse, error) {
	rsp, err := c.DeleteApi217LinkAggregationGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217LinkAggregationGroupsResponse(rsp)
}

// GetApi217LinkAggregationGroupsWithResponse request returning *GetApi217LinkAggregationGroupsResponse
func (c *ClientWithResponses) GetApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *GetApi217LinkAggregationGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217LinkAggregationGroupsResponse, error) {
	rsp, err := c.GetApi217LinkAggregationGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217LinkAggregationGroupsResponse(rsp)
}

// PatchApi217LinkAggregationGroupsWithBodyWithResponse request with arbitrary body returning *PatchApi217LinkAggregationGroupsResponse
func (c *ClientWithResponses) PatchApi217LinkAggregationGroupsWithBodyWithResponse(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LinkAggregationGroupsResponse, error) {
	rsp, err := c.PatchApi217LinkAggregationGroupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LinkAggregationGroupsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *PatchApi217LinkAggregationGroupsParams, body PatchApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LinkAggregationGroupsResponse, error) {
	rsp, err := c.PatchApi217LinkAggregationGroups(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LinkAggregationGroupsResponse(rsp)
}

// PostApi217LinkAggregationGroupsWithBodyWithResponse request with arbitrary body returning *PostApi217LinkAggregationGroupsResponse
func (c *ClientWithResponses) PostApi217LinkAggregationGroupsWithBodyWithResponse(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217LinkAggregationGroupsResponse, error) {
	rsp, err := c.PostApi217LinkAggregationGroupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217LinkAggregationGroupsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217LinkAggregationGroupsWithResponse(ctx context.Context, params *PostApi217LinkAggregationGroupsParams, body PostApi217LinkAggregationGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217LinkAggregationGroupsResponse, error) {
	rsp, err := c.PostApi217LinkAggregationGroups(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217LinkAggregationGroupsResponse(rsp)
}

// GetApi217LogsWithResponse request returning *GetApi217LogsResponse
func (c *ClientWithResponses) GetApi217LogsWithResponse(ctx context.Context, params *GetApi217LogsParams, reqEditors ...RequestEditorFn) (*GetApi217LogsResponse, error) {
	rsp, err := c.GetApi217Logs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217LogsResponse(rsp)
}

// GetApi217LogsAsyncWithResponse request returning *GetApi217LogsAsyncResponse
func (c *ClientWithResponses) GetApi217LogsAsyncWithResponse(ctx context.Context, params *GetApi217LogsAsyncParams, reqEditors ...RequestEditorFn) (*GetApi217LogsAsyncResponse, error) {
	rsp, err := c.GetApi217LogsAsync(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217LogsAsyncResponse(rsp)
}

// PatchApi217LogsAsyncWithBodyWithResponse request with arbitrary body returning *PatchApi217LogsAsyncResponse
func (c *ClientWithResponses) PatchApi217LogsAsyncWithBodyWithResponse(ctx context.Context, params *PatchApi217LogsAsyncParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217LogsAsyncResponse, error) {
	rsp, err := c.PatchApi217LogsAsyncWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LogsAsyncResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217LogsAsyncWithResponse(ctx context.Context, params *PatchApi217LogsAsyncParams, body PatchApi217LogsAsyncJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217LogsAsyncResponse, error) {
	rsp, err := c.PatchApi217LogsAsync(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217LogsAsyncResponse(rsp)
}

// GetApi217LogsAsyncDownloadWithResponse request returning *GetApi217LogsAsyncDownloadResponse
func (c *ClientWithResponses) GetApi217LogsAsyncDownloadWithResponse(ctx context.Context, params *GetApi217LogsAsyncDownloadParams, reqEditors ...RequestEditorFn) (*GetApi217LogsAsyncDownloadResponse, error) {
	rsp, err := c.GetApi217LogsAsyncDownload(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217LogsAsyncDownloadResponse(rsp)
}

// DeleteApi217MaintenanceWindowsWithResponse request returning *DeleteApi217MaintenanceWindowsResponse
func (c *ClientWithResponses) DeleteApi217MaintenanceWindowsWithResponse(ctx context.Context, params *DeleteApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*DeleteApi217MaintenanceWindowsResponse, error) {
	rsp, err := c.DeleteApi217MaintenanceWindows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217MaintenanceWindowsResponse(rsp)
}

// GetApi217MaintenanceWindowsWithResponse request returning *GetApi217MaintenanceWindowsResponse
func (c *ClientWithResponses) GetApi217MaintenanceWindowsWithResponse(ctx context.Context, params *GetApi217MaintenanceWindowsParams, reqEditors ...RequestEditorFn) (*GetApi217MaintenanceWindowsResponse, error) {
	rsp, err := c.GetApi217MaintenanceWindows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217MaintenanceWindowsResponse(rsp)
}

// PostApi217MaintenanceWindowsWithBodyWithResponse request with arbitrary body returning *PostApi217MaintenanceWindowsResponse
func (c *ClientWithResponses) PostApi217MaintenanceWindowsWithBodyWithResponse(ctx context.Context, params *PostApi217MaintenanceWindowsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217MaintenanceWindowsResponse, error) {
	rsp, err := c.PostApi217MaintenanceWindowsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217MaintenanceWindowsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217MaintenanceWindowsWithResponse(ctx context.Context, params *PostApi217MaintenanceWindowsParams, body PostApi217MaintenanceWindowsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217MaintenanceWindowsResponse, error) {
	rsp, err := c.PostApi217MaintenanceWindows(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217MaintenanceWindowsResponse(rsp)
}

// GetApi217NetworkAccessPoliciesWithResponse request returning *GetApi217NetworkAccessPoliciesResponse
func (c *ClientWithResponses) GetApi217NetworkAccessPoliciesWithResponse(ctx context.Context, params *GetApi217NetworkAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkAccessPoliciesResponse, error) {
	rsp, err := c.GetApi217NetworkAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkAccessPoliciesResponse(rsp)
}

// PatchApi217NetworkAccessPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217NetworkAccessPoliciesResponse
func (c *ClientWithResponses) PatchApi217NetworkAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesResponse, error) {
	rsp, err := c.PatchApi217NetworkAccessPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkAccessPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217NetworkAccessPoliciesWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesParams, body PatchApi217NetworkAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesResponse, error) {
	rsp, err := c.PatchApi217NetworkAccessPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkAccessPoliciesResponse(rsp)
}

// GetApi217NetworkAccessPoliciesMembersWithResponse request returning *GetApi217NetworkAccessPoliciesMembersResponse
func (c *ClientWithResponses) GetApi217NetworkAccessPoliciesMembersWithResponse(ctx context.Context, params *GetApi217NetworkAccessPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkAccessPoliciesMembersResponse, error) {
	rsp, err := c.GetApi217NetworkAccessPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkAccessPoliciesMembersResponse(rsp)
}

// DeleteApi217NetworkAccessPoliciesRulesWithResponse request returning *DeleteApi217NetworkAccessPoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NetworkAccessPoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217NetworkAccessPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217NetworkAccessPoliciesRulesResponse(rsp)
}

// GetApi217NetworkAccessPoliciesRulesWithResponse request returning *GetApi217NetworkAccessPoliciesRulesResponse
func (c *ClientWithResponses) GetApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *GetApi217NetworkAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkAccessPoliciesRulesResponse, error) {
	rsp, err := c.GetApi217NetworkAccessPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkAccessPoliciesRulesResponse(rsp)
}

// PatchApi217NetworkAccessPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PatchApi217NetworkAccessPoliciesRulesResponse
func (c *ClientWithResponses) PatchApi217NetworkAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217NetworkAccessPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkAccessPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217NetworkAccessPoliciesRulesParams, body PatchApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkAccessPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217NetworkAccessPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkAccessPoliciesRulesResponse(rsp)
}

// PostApi217NetworkAccessPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217NetworkAccessPoliciesRulesResponse
func (c *ClientWithResponses) PostApi217NetworkAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NetworkAccessPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217NetworkAccessPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NetworkAccessPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217NetworkAccessPoliciesRulesWithResponse(ctx context.Context, params *PostApi217NetworkAccessPoliciesRulesParams, body PostApi217NetworkAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NetworkAccessPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217NetworkAccessPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NetworkAccessPoliciesRulesResponse(rsp)
}

// DeleteApi217NetworkInterfacesWithResponse request returning *DeleteApi217NetworkInterfacesResponse
func (c *ClientWithResponses) DeleteApi217NetworkInterfacesWithResponse(ctx context.Context, params *DeleteApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NetworkInterfacesResponse, error) {
	rsp, err := c.DeleteApi217NetworkInterfaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217NetworkInterfacesResponse(rsp)
}

// GetApi217NetworkInterfacesWithResponse request returning *GetApi217NetworkInterfacesResponse
func (c *ClientWithResponses) GetApi217NetworkInterfacesWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesResponse, error) {
	rsp, err := c.GetApi217NetworkInterfaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkInterfacesResponse(rsp)
}

// PatchApi217NetworkInterfacesWithBodyWithResponse request with arbitrary body returning *PatchApi217NetworkInterfacesResponse
func (c *ClientWithResponses) PatchApi217NetworkInterfacesWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesResponse, error) {
	rsp, err := c.PatchApi217NetworkInterfacesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkInterfacesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217NetworkInterfacesWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesParams, body PatchApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesResponse, error) {
	rsp, err := c.PatchApi217NetworkInterfaces(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkInterfacesResponse(rsp)
}

// PostApi217NetworkInterfacesWithBodyWithResponse request with arbitrary body returning *PostApi217NetworkInterfacesResponse
func (c *ClientWithResponses) PostApi217NetworkInterfacesWithBodyWithResponse(ctx context.Context, params *PostApi217NetworkInterfacesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NetworkInterfacesResponse, error) {
	rsp, err := c.PostApi217NetworkInterfacesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NetworkInterfacesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217NetworkInterfacesWithResponse(ctx context.Context, params *PostApi217NetworkInterfacesParams, body PostApi217NetworkInterfacesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NetworkInterfacesResponse, error) {
	rsp, err := c.PostApi217NetworkInterfaces(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NetworkInterfacesResponse(rsp)
}

// GetApi217NetworkInterfacesConnectorsWithResponse request returning *GetApi217NetworkInterfacesConnectorsResponse
func (c *ClientWithResponses) GetApi217NetworkInterfacesConnectorsWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesConnectorsResponse, error) {
	rsp, err := c.GetApi217NetworkInterfacesConnectors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkInterfacesConnectorsResponse(rsp)
}

// PatchApi217NetworkInterfacesConnectorsWithBodyWithResponse request with arbitrary body returning *PatchApi217NetworkInterfacesConnectorsResponse
func (c *ClientWithResponses) PatchApi217NetworkInterfacesConnectorsWithBodyWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesConnectorsResponse, error) {
	rsp, err := c.PatchApi217NetworkInterfacesConnectorsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkInterfacesConnectorsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217NetworkInterfacesConnectorsWithResponse(ctx context.Context, params *PatchApi217NetworkInterfacesConnectorsParams, body PatchApi217NetworkInterfacesConnectorsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NetworkInterfacesConnectorsResponse, error) {
	rsp, err := c.PatchApi217NetworkInterfacesConnectors(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NetworkInterfacesConnectorsResponse(rsp)
}

// GetApi217NetworkInterfacesConnectorsPerformanceWithResponse request returning *GetApi217NetworkInterfacesConnectorsPerformanceResponse
func (c *ClientWithResponses) GetApi217NetworkInterfacesConnectorsPerformanceWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsPerformanceParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesConnectorsPerformanceResponse, error) {
	rsp, err := c.GetApi217NetworkInterfacesConnectorsPerformance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkInterfacesConnectorsPerformanceResponse(rsp)
}

// GetApi217NetworkInterfacesConnectorsSettingsWithResponse request returning *GetApi217NetworkInterfacesConnectorsSettingsResponse
func (c *ClientWithResponses) GetApi217NetworkInterfacesConnectorsSettingsWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesConnectorsSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesConnectorsSettingsResponse, error) {
	rsp, err := c.GetApi217NetworkInterfacesConnectorsSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkInterfacesConnectorsSettingsResponse(rsp)
}

// GetApi217NetworkInterfacesPingWithResponse request returning *GetApi217NetworkInterfacesPingResponse
func (c *ClientWithResponses) GetApi217NetworkInterfacesPingWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesPingParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesPingResponse, error) {
	rsp, err := c.GetApi217NetworkInterfacesPing(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkInterfacesPingResponse(rsp)
}

// DeleteApi217NetworkInterfacesTlsPoliciesWithResponse request returning *DeleteApi217NetworkInterfacesTlsPoliciesResponse
func (c *ClientWithResponses) DeleteApi217NetworkInterfacesTlsPoliciesWithResponse(ctx context.Context, params *DeleteApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NetworkInterfacesTlsPoliciesResponse, error) {
	rsp, err := c.DeleteApi217NetworkInterfacesTlsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217NetworkInterfacesTlsPoliciesResponse(rsp)
}

// GetApi217NetworkInterfacesTlsPoliciesWithResponse request returning *GetApi217NetworkInterfacesTlsPoliciesResponse
func (c *ClientWithResponses) GetApi217NetworkInterfacesTlsPoliciesWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesTlsPoliciesResponse, error) {
	rsp, err := c.GetApi217NetworkInterfacesTlsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkInterfacesTlsPoliciesResponse(rsp)
}

// PostApi217NetworkInterfacesTlsPoliciesWithResponse request returning *PostApi217NetworkInterfacesTlsPoliciesResponse
func (c *ClientWithResponses) PostApi217NetworkInterfacesTlsPoliciesWithResponse(ctx context.Context, params *PostApi217NetworkInterfacesTlsPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217NetworkInterfacesTlsPoliciesResponse, error) {
	rsp, err := c.PostApi217NetworkInterfacesTlsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NetworkInterfacesTlsPoliciesResponse(rsp)
}

// GetApi217NetworkInterfacesTraceWithResponse request returning *GetApi217NetworkInterfacesTraceResponse
func (c *ClientWithResponses) GetApi217NetworkInterfacesTraceWithResponse(ctx context.Context, params *GetApi217NetworkInterfacesTraceParams, reqEditors ...RequestEditorFn) (*GetApi217NetworkInterfacesTraceResponse, error) {
	rsp, err := c.GetApi217NetworkInterfacesTrace(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NetworkInterfacesTraceResponse(rsp)
}

// DeleteApi217NfsExportPoliciesWithResponse request returning *DeleteApi217NfsExportPoliciesResponse
func (c *ClientWithResponses) DeleteApi217NfsExportPoliciesWithResponse(ctx context.Context, params *DeleteApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NfsExportPoliciesResponse, error) {
	rsp, err := c.DeleteApi217NfsExportPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217NfsExportPoliciesResponse(rsp)
}

// GetApi217NfsExportPoliciesWithResponse request returning *GetApi217NfsExportPoliciesResponse
func (c *ClientWithResponses) GetApi217NfsExportPoliciesWithResponse(ctx context.Context, params *GetApi217NfsExportPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217NfsExportPoliciesResponse, error) {
	rsp, err := c.GetApi217NfsExportPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NfsExportPoliciesResponse(rsp)
}

// PatchApi217NfsExportPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217NfsExportPoliciesResponse
func (c *ClientWithResponses) PatchApi217NfsExportPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesResponse, error) {
	rsp, err := c.PatchApi217NfsExportPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NfsExportPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217NfsExportPoliciesWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesParams, body PatchApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesResponse, error) {
	rsp, err := c.PatchApi217NfsExportPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NfsExportPoliciesResponse(rsp)
}

// PostApi217NfsExportPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217NfsExportPoliciesResponse
func (c *ClientWithResponses) PostApi217NfsExportPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesResponse, error) {
	rsp, err := c.PostApi217NfsExportPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NfsExportPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217NfsExportPoliciesWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesParams, body PostApi217NfsExportPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesResponse, error) {
	rsp, err := c.PostApi217NfsExportPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NfsExportPoliciesResponse(rsp)
}

// DeleteApi217NfsExportPoliciesRulesWithResponse request returning *DeleteApi217NfsExportPoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217NfsExportPoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217NfsExportPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217NfsExportPoliciesRulesResponse(rsp)
}

// GetApi217NfsExportPoliciesRulesWithResponse request returning *GetApi217NfsExportPoliciesRulesResponse
func (c *ClientWithResponses) GetApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *GetApi217NfsExportPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217NfsExportPoliciesRulesResponse, error) {
	rsp, err := c.GetApi217NfsExportPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217NfsExportPoliciesRulesResponse(rsp)
}

// PatchApi217NfsExportPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PatchApi217NfsExportPoliciesRulesResponse
func (c *ClientWithResponses) PatchApi217NfsExportPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217NfsExportPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NfsExportPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217NfsExportPoliciesRulesParams, body PatchApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217NfsExportPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217NfsExportPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217NfsExportPoliciesRulesResponse(rsp)
}

// PostApi217NfsExportPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217NfsExportPoliciesRulesResponse
func (c *ClientWithResponses) PostApi217NfsExportPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217NfsExportPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NfsExportPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217NfsExportPoliciesRulesWithResponse(ctx context.Context, params *PostApi217NfsExportPoliciesRulesParams, body PostApi217NfsExportPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217NfsExportPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217NfsExportPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217NfsExportPoliciesRulesResponse(rsp)
}

// DeleteApi217ObjectStoreAccessKeysWithResponse request returning *DeleteApi217ObjectStoreAccessKeysResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessKeysResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreAccessKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreAccessKeysResponse(rsp)
}

// GetApi217ObjectStoreAccessKeysWithResponse request returning *GetApi217ObjectStoreAccessKeysResponse
func (c *ClientWithResponses) GetApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessKeysParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessKeysResponse, error) {
	rsp, err := c.GetApi217ObjectStoreAccessKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreAccessKeysResponse(rsp)
}

// PatchApi217ObjectStoreAccessKeysWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreAccessKeysResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreAccessKeysWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessKeysResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccessKeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccessKeysResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessKeysParams, body PatchApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessKeysResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccessKeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccessKeysResponse(rsp)
}

// PostApi217ObjectStoreAccessKeysWithBodyWithResponse request with arbitrary body returning *PostApi217ObjectStoreAccessKeysResponse
func (c *ClientWithResponses) PostApi217ObjectStoreAccessKeysWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessKeysResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessKeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessKeysResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ObjectStoreAccessKeysWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessKeysParams, body PostApi217ObjectStoreAccessKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessKeysResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessKeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessKeysResponse(rsp)
}

// DeleteApi217ObjectStoreAccessPoliciesWithResponse request returning *DeleteApi217ObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreAccessPoliciesResponse(rsp)
}

// GetApi217ObjectStoreAccessPoliciesWithResponse request returning *GetApi217ObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreAccessPoliciesResponse(rsp)
}

// PatchApi217ObjectStoreAccessPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccessPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccessPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesParams, body PatchApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccessPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccessPoliciesResponse(rsp)
}

// PostApi217ObjectStoreAccessPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217ObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) PostApi217ObjectStoreAccessPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesParams, body PostApi217ObjectStoreAccessPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessPoliciesResponse(rsp)
}

// DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse request returning *DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse(rsp)
}

// GetApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse request returning *GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse(rsp)
}

// PostApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse request returning *PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse
func (c *ClientWithResponses) PostApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessPoliciesObjectStoreRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse(rsp)
}

// DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse request returning *DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse(rsp)
}

// GetApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse request returning *GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse
func (c *ClientWithResponses) GetApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error) {
	rsp, err := c.GetApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse(rsp)
}

// PostApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse request returning *PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse
func (c *ClientWithResponses) PostApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessPoliciesObjectStoreUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse(rsp)
}

// DeleteApi217ObjectStoreAccessPoliciesRulesWithResponse request returning *DeleteApi217ObjectStoreAccessPoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreAccessPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreAccessPoliciesRulesResponse(rsp)
}

// GetApi217ObjectStoreAccessPoliciesRulesWithResponse request returning *GetApi217ObjectStoreAccessPoliciesRulesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreAccessPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreAccessPoliciesRulesResponse(rsp)
}

// PatchApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreAccessPoliciesRulesResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccessPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccessPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccessPoliciesRulesParams, body PatchApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccessPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccessPoliciesRulesResponse(rsp)
}

// PostApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217ObjectStoreAccessPoliciesRulesResponse
func (c *ClientWithResponses) PostApi217ObjectStoreAccessPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ObjectStoreAccessPoliciesRulesWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccessPoliciesRulesParams, body PostApi217ObjectStoreAccessPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccessPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccessPoliciesRulesResponse(rsp)
}

// GetApi217ObjectStoreAccessPolicyActionsWithResponse request returning *GetApi217ObjectStoreAccessPolicyActionsResponse
func (c *ClientWithResponses) GetApi217ObjectStoreAccessPolicyActionsWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccessPolicyActionsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccessPolicyActionsResponse, error) {
	rsp, err := c.GetApi217ObjectStoreAccessPolicyActions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreAccessPolicyActionsResponse(rsp)
}

// DeleteApi217ObjectStoreAccountsWithResponse request returning *DeleteApi217ObjectStoreAccountsResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreAccountsResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreAccountsResponse(rsp)
}

// GetApi217ObjectStoreAccountsWithResponse request returning *GetApi217ObjectStoreAccountsResponse
func (c *ClientWithResponses) GetApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *GetApi217ObjectStoreAccountsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreAccountsResponse, error) {
	rsp, err := c.GetApi217ObjectStoreAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreAccountsResponse(rsp)
}

// PatchApi217ObjectStoreAccountsWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreAccountsResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreAccountsWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccountsResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccountsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *PatchApi217ObjectStoreAccountsParams, body PatchApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreAccountsResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreAccountsResponse(rsp)
}

// PostApi217ObjectStoreAccountsWithBodyWithResponse request with arbitrary body returning *PostApi217ObjectStoreAccountsResponse
func (c *ClientWithResponses) PostApi217ObjectStoreAccountsWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccountsResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccountsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ObjectStoreAccountsWithResponse(ctx context.Context, params *PostApi217ObjectStoreAccountsParams, body PostApi217ObjectStoreAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreAccountsResponse, error) {
	rsp, err := c.PostApi217ObjectStoreAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreAccountsResponse(rsp)
}

// DeleteApi217ObjectStoreRemoteCredentialsWithResponse request returning *DeleteApi217ObjectStoreRemoteCredentialsResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRemoteCredentialsResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreRemoteCredentials(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreRemoteCredentialsResponse(rsp)
}

// GetApi217ObjectStoreRemoteCredentialsWithResponse request returning *GetApi217ObjectStoreRemoteCredentialsResponse
func (c *ClientWithResponses) GetApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *GetApi217ObjectStoreRemoteCredentialsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRemoteCredentialsResponse, error) {
	rsp, err := c.GetApi217ObjectStoreRemoteCredentials(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreRemoteCredentialsResponse(rsp)
}

// PatchApi217ObjectStoreRemoteCredentialsWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreRemoteCredentialsResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreRemoteCredentialsWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRemoteCredentialsResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRemoteCredentialsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRemoteCredentialsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRemoteCredentialsParams, body PatchApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRemoteCredentialsResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRemoteCredentials(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRemoteCredentialsResponse(rsp)
}

// PostApi217ObjectStoreRemoteCredentialsWithBodyWithResponse request with arbitrary body returning *PostApi217ObjectStoreRemoteCredentialsResponse
func (c *ClientWithResponses) PostApi217ObjectStoreRemoteCredentialsWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRemoteCredentialsResponse, error) {
	rsp, err := c.PostApi217ObjectStoreRemoteCredentialsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreRemoteCredentialsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ObjectStoreRemoteCredentialsWithResponse(ctx context.Context, params *PostApi217ObjectStoreRemoteCredentialsParams, body PostApi217ObjectStoreRemoteCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRemoteCredentialsResponse, error) {
	rsp, err := c.PostApi217ObjectStoreRemoteCredentials(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreRemoteCredentialsResponse(rsp)
}

// DeleteApi217ObjectStoreRolesWithResponse request returning *DeleteApi217ObjectStoreRolesResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreRolesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRolesResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreRolesResponse(rsp)
}

// GetApi217ObjectStoreRolesWithResponse request returning *GetApi217ObjectStoreRolesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreRolesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreRolesResponse(rsp)
}

// PatchApi217ObjectStoreRolesWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreRolesResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreRolesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRolesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRolesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreRolesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesParams, body PatchApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRoles(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRolesResponse(rsp)
}

// PostApi217ObjectStoreRolesWithBodyWithResponse request with arbitrary body returning *PostApi217ObjectStoreRolesResponse
func (c *ClientWithResponses) PostApi217ObjectStoreRolesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreRolesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreRolesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ObjectStoreRolesWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesParams, body PostApi217ObjectStoreRolesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreRoles(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreRolesResponse(rsp)
}

// DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse request returning *DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse(rsp)
}

// GetApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse request returning *GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse(rsp)
}

// PostApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse request returning *PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) PostApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreRolesObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse(rsp)
}

// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesWithResponse request returning *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreRolesObjectStoreTrustPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreRolesObjectStoreTrustPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse(rsp)
}

// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadWithResponse request returning *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse
func (c *ClientWithResponses) GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse, error) {
	rsp, err := c.GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownload(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse(rsp)
}

// DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse request returning *DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp)
}

// GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse request returning *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp)
}

// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp)
}

// PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse
func (c *ClientWithResponses) PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse(ctx context.Context, params *PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesParams, body PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp)
}

// PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBodyWithResponse request with arbitrary body returning *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse
func (c *ClientWithResponses) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBodyWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithResponse(ctx context.Context, params *PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadParams, body PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse, error) {
	rsp, err := c.PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUpload(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse(rsp)
}

// DeleteApi217ObjectStoreUsersWithResponse request returning *DeleteApi217ObjectStoreUsersResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreUsersWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreUsersResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreUsersResponse(rsp)
}

// GetApi217ObjectStoreUsersWithResponse request returning *GetApi217ObjectStoreUsersResponse
func (c *ClientWithResponses) GetApi217ObjectStoreUsersWithResponse(ctx context.Context, params *GetApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreUsersResponse, error) {
	rsp, err := c.GetApi217ObjectStoreUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreUsersResponse(rsp)
}

// PostApi217ObjectStoreUsersWithResponse request returning *PostApi217ObjectStoreUsersResponse
func (c *ClientWithResponses) PostApi217ObjectStoreUsersWithResponse(ctx context.Context, params *PostApi217ObjectStoreUsersParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreUsersResponse, error) {
	rsp, err := c.PostApi217ObjectStoreUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreUsersResponse(rsp)
}

// DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse request returning *DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse(rsp)
}

// GetApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse request returning *GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) GetApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *GetApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.GetApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse(rsp)
}

// PostApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse request returning *PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse
func (c *ClientWithResponses) PostApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse(ctx context.Context, params *PostApi217ObjectStoreUsersObjectStoreAccessPoliciesParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error) {
	rsp, err := c.PostApi217ObjectStoreUsersObjectStoreAccessPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse(rsp)
}

// DeleteApi217ObjectStoreVirtualHostsWithResponse request returning *DeleteApi217ObjectStoreVirtualHostsResponse
func (c *ClientWithResponses) DeleteApi217ObjectStoreVirtualHostsWithResponse(ctx context.Context, params *DeleteApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*DeleteApi217ObjectStoreVirtualHostsResponse, error) {
	rsp, err := c.DeleteApi217ObjectStoreVirtualHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ObjectStoreVirtualHostsResponse(rsp)
}

// GetApi217ObjectStoreVirtualHostsWithResponse request returning *GetApi217ObjectStoreVirtualHostsResponse
func (c *ClientWithResponses) GetApi217ObjectStoreVirtualHostsWithResponse(ctx context.Context, params *GetApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*GetApi217ObjectStoreVirtualHostsResponse, error) {
	rsp, err := c.GetApi217ObjectStoreVirtualHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ObjectStoreVirtualHostsResponse(rsp)
}

// PostApi217ObjectStoreVirtualHostsWithResponse request returning *PostApi217ObjectStoreVirtualHostsResponse
func (c *ClientWithResponses) PostApi217ObjectStoreVirtualHostsWithResponse(ctx context.Context, params *PostApi217ObjectStoreVirtualHostsParams, reqEditors ...RequestEditorFn) (*PostApi217ObjectStoreVirtualHostsResponse, error) {
	rsp, err := c.PostApi217ObjectStoreVirtualHosts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ObjectStoreVirtualHostsResponse(rsp)
}

// GetApi217PasswordPoliciesWithResponse request returning *GetApi217PasswordPoliciesResponse
func (c *ClientWithResponses) GetApi217PasswordPoliciesWithResponse(ctx context.Context, params *GetApi217PasswordPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217PasswordPoliciesResponse, error) {
	rsp, err := c.GetApi217PasswordPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PasswordPoliciesResponse(rsp)
}

// PatchApi217PasswordPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217PasswordPoliciesResponse
func (c *ClientWithResponses) PatchApi217PasswordPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217PasswordPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217PasswordPoliciesResponse, error) {
	rsp, err := c.PatchApi217PasswordPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217PasswordPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217PasswordPoliciesWithResponse(ctx context.Context, params *PatchApi217PasswordPoliciesParams, body PatchApi217PasswordPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217PasswordPoliciesResponse, error) {
	rsp, err := c.PatchApi217PasswordPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217PasswordPoliciesResponse(rsp)
}

// DeleteApi217PoliciesWithResponse request returning *DeleteApi217PoliciesResponse
func (c *ClientWithResponses) DeleteApi217PoliciesWithResponse(ctx context.Context, params *DeleteApi217PoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesResponse, error) {
	rsp, err := c.DeleteApi217Policies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217PoliciesResponse(rsp)
}

// GetApi217PoliciesWithResponse request returning *GetApi217PoliciesResponse
func (c *ClientWithResponses) GetApi217PoliciesWithResponse(ctx context.Context, params *GetApi217PoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesResponse, error) {
	rsp, err := c.GetApi217Policies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PoliciesResponse(rsp)
}

// PatchApi217PoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217PoliciesResponse
func (c *ClientWithResponses) PatchApi217PoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217PoliciesResponse, error) {
	rsp, err := c.PatchApi217PoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217PoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217PoliciesWithResponse(ctx context.Context, params *PatchApi217PoliciesParams, body PatchApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217PoliciesResponse, error) {
	rsp, err := c.PatchApi217Policies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217PoliciesResponse(rsp)
}

// PostApi217PoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217PoliciesResponse
func (c *ClientWithResponses) PostApi217PoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217PoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217PoliciesResponse, error) {
	rsp, err := c.PostApi217PoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217PoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217PoliciesWithResponse(ctx context.Context, params *PostApi217PoliciesParams, body PostApi217PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217PoliciesResponse, error) {
	rsp, err := c.PostApi217Policies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217PoliciesResponse(rsp)
}

// GetApi217PoliciesAllWithResponse request returning *GetApi217PoliciesAllResponse
func (c *ClientWithResponses) GetApi217PoliciesAllWithResponse(ctx context.Context, params *GetApi217PoliciesAllParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesAllResponse, error) {
	rsp, err := c.GetApi217PoliciesAll(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PoliciesAllResponse(rsp)
}

// GetApi217PoliciesAllMembersWithResponse request returning *GetApi217PoliciesAllMembersResponse
func (c *ClientWithResponses) GetApi217PoliciesAllMembersWithResponse(ctx context.Context, params *GetApi217PoliciesAllMembersParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesAllMembersResponse, error) {
	rsp, err := c.GetApi217PoliciesAllMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PoliciesAllMembersResponse(rsp)
}

// DeleteApi217PoliciesFileSystemReplicaLinksWithResponse request returning *DeleteApi217PoliciesFileSystemReplicaLinksResponse
func (c *ClientWithResponses) DeleteApi217PoliciesFileSystemReplicaLinksWithResponse(ctx context.Context, params *DeleteApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesFileSystemReplicaLinksResponse, error) {
	rsp, err := c.DeleteApi217PoliciesFileSystemReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217PoliciesFileSystemReplicaLinksResponse(rsp)
}

// GetApi217PoliciesFileSystemReplicaLinksWithResponse request returning *GetApi217PoliciesFileSystemReplicaLinksResponse
func (c *ClientWithResponses) GetApi217PoliciesFileSystemReplicaLinksWithResponse(ctx context.Context, params *GetApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesFileSystemReplicaLinksResponse, error) {
	rsp, err := c.GetApi217PoliciesFileSystemReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PoliciesFileSystemReplicaLinksResponse(rsp)
}

// PostApi217PoliciesFileSystemReplicaLinksWithResponse request returning *PostApi217PoliciesFileSystemReplicaLinksResponse
func (c *ClientWithResponses) PostApi217PoliciesFileSystemReplicaLinksWithResponse(ctx context.Context, params *PostApi217PoliciesFileSystemReplicaLinksParams, reqEditors ...RequestEditorFn) (*PostApi217PoliciesFileSystemReplicaLinksResponse, error) {
	rsp, err := c.PostApi217PoliciesFileSystemReplicaLinks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217PoliciesFileSystemReplicaLinksResponse(rsp)
}

// DeleteApi217PoliciesFileSystemSnapshotsWithResponse request returning *DeleteApi217PoliciesFileSystemSnapshotsResponse
func (c *ClientWithResponses) DeleteApi217PoliciesFileSystemSnapshotsWithResponse(ctx context.Context, params *DeleteApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesFileSystemSnapshotsResponse, error) {
	rsp, err := c.DeleteApi217PoliciesFileSystemSnapshots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217PoliciesFileSystemSnapshotsResponse(rsp)
}

// GetApi217PoliciesFileSystemSnapshotsWithResponse request returning *GetApi217PoliciesFileSystemSnapshotsResponse
func (c *ClientWithResponses) GetApi217PoliciesFileSystemSnapshotsWithResponse(ctx context.Context, params *GetApi217PoliciesFileSystemSnapshotsParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesFileSystemSnapshotsResponse, error) {
	rsp, err := c.GetApi217PoliciesFileSystemSnapshots(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PoliciesFileSystemSnapshotsResponse(rsp)
}

// DeleteApi217PoliciesFileSystemsWithResponse request returning *DeleteApi217PoliciesFileSystemsResponse
func (c *ClientWithResponses) DeleteApi217PoliciesFileSystemsWithResponse(ctx context.Context, params *DeleteApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*DeleteApi217PoliciesFileSystemsResponse, error) {
	rsp, err := c.DeleteApi217PoliciesFileSystems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217PoliciesFileSystemsResponse(rsp)
}

// GetApi217PoliciesFileSystemsWithResponse request returning *GetApi217PoliciesFileSystemsResponse
func (c *ClientWithResponses) GetApi217PoliciesFileSystemsWithResponse(ctx context.Context, params *GetApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesFileSystemsResponse, error) {
	rsp, err := c.GetApi217PoliciesFileSystems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PoliciesFileSystemsResponse(rsp)
}

// PostApi217PoliciesFileSystemsWithResponse request returning *PostApi217PoliciesFileSystemsResponse
func (c *ClientWithResponses) PostApi217PoliciesFileSystemsWithResponse(ctx context.Context, params *PostApi217PoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*PostApi217PoliciesFileSystemsResponse, error) {
	rsp, err := c.PostApi217PoliciesFileSystems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217PoliciesFileSystemsResponse(rsp)
}

// GetApi217PoliciesMembersWithResponse request returning *GetApi217PoliciesMembersResponse
func (c *ClientWithResponses) GetApi217PoliciesMembersWithResponse(ctx context.Context, params *GetApi217PoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217PoliciesMembersResponse, error) {
	rsp, err := c.GetApi217PoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PoliciesMembersResponse(rsp)
}

// DeleteApi217PublicKeysWithResponse request returning *DeleteApi217PublicKeysResponse
func (c *ClientWithResponses) DeleteApi217PublicKeysWithResponse(ctx context.Context, params *DeleteApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*DeleteApi217PublicKeysResponse, error) {
	rsp, err := c.DeleteApi217PublicKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217PublicKeysResponse(rsp)
}

// GetApi217PublicKeysWithResponse request returning *GetApi217PublicKeysResponse
func (c *ClientWithResponses) GetApi217PublicKeysWithResponse(ctx context.Context, params *GetApi217PublicKeysParams, reqEditors ...RequestEditorFn) (*GetApi217PublicKeysResponse, error) {
	rsp, err := c.GetApi217PublicKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PublicKeysResponse(rsp)
}

// PostApi217PublicKeysWithBodyWithResponse request with arbitrary body returning *PostApi217PublicKeysResponse
func (c *ClientWithResponses) PostApi217PublicKeysWithBodyWithResponse(ctx context.Context, params *PostApi217PublicKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217PublicKeysResponse, error) {
	rsp, err := c.PostApi217PublicKeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217PublicKeysResponse(rsp)
}

func (c *ClientWithResponses) PostApi217PublicKeysWithResponse(ctx context.Context, params *PostApi217PublicKeysParams, body PostApi217PublicKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217PublicKeysResponse, error) {
	rsp, err := c.PostApi217PublicKeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217PublicKeysResponse(rsp)
}

// GetApi217PublicKeysUsesWithResponse request returning *GetApi217PublicKeysUsesResponse
func (c *ClientWithResponses) GetApi217PublicKeysUsesWithResponse(ctx context.Context, params *GetApi217PublicKeysUsesParams, reqEditors ...RequestEditorFn) (*GetApi217PublicKeysUsesResponse, error) {
	rsp, err := c.GetApi217PublicKeysUses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217PublicKeysUsesResponse(rsp)
}

// DeleteApi217QosPoliciesWithResponse request returning *DeleteApi217QosPoliciesResponse
func (c *ClientWithResponses) DeleteApi217QosPoliciesWithResponse(ctx context.Context, params *DeleteApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217QosPoliciesResponse, error) {
	rsp, err := c.DeleteApi217QosPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217QosPoliciesResponse(rsp)
}

// GetApi217QosPoliciesWithResponse request returning *GetApi217QosPoliciesResponse
func (c *ClientWithResponses) GetApi217QosPoliciesWithResponse(ctx context.Context, params *GetApi217QosPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217QosPoliciesResponse, error) {
	rsp, err := c.GetApi217QosPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217QosPoliciesResponse(rsp)
}

// PatchApi217QosPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217QosPoliciesResponse
func (c *ClientWithResponses) PatchApi217QosPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QosPoliciesResponse, error) {
	rsp, err := c.PatchApi217QosPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QosPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217QosPoliciesWithResponse(ctx context.Context, params *PatchApi217QosPoliciesParams, body PatchApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QosPoliciesResponse, error) {
	rsp, err := c.PatchApi217QosPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QosPoliciesResponse(rsp)
}

// PostApi217QosPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217QosPoliciesResponse
func (c *ClientWithResponses) PostApi217QosPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217QosPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217QosPoliciesResponse, error) {
	rsp, err := c.PostApi217QosPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217QosPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217QosPoliciesWithResponse(ctx context.Context, params *PostApi217QosPoliciesParams, body PostApi217QosPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217QosPoliciesResponse, error) {
	rsp, err := c.PostApi217QosPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217QosPoliciesResponse(rsp)
}

// GetApi217QosPoliciesFileSystemsWithResponse request returning *GetApi217QosPoliciesFileSystemsResponse
func (c *ClientWithResponses) GetApi217QosPoliciesFileSystemsWithResponse(ctx context.Context, params *GetApi217QosPoliciesFileSystemsParams, reqEditors ...RequestEditorFn) (*GetApi217QosPoliciesFileSystemsResponse, error) {
	rsp, err := c.GetApi217QosPoliciesFileSystems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217QosPoliciesFileSystemsResponse(rsp)
}

// GetApi217QosPoliciesMembersWithResponse request returning *GetApi217QosPoliciesMembersResponse
func (c *ClientWithResponses) GetApi217QosPoliciesMembersWithResponse(ctx context.Context, params *GetApi217QosPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217QosPoliciesMembersResponse, error) {
	rsp, err := c.GetApi217QosPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217QosPoliciesMembersResponse(rsp)
}

// DeleteApi217QuotasGroupsWithResponse request returning *DeleteApi217QuotasGroupsResponse
func (c *ClientWithResponses) DeleteApi217QuotasGroupsWithResponse(ctx context.Context, params *DeleteApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*DeleteApi217QuotasGroupsResponse, error) {
	rsp, err := c.DeleteApi217QuotasGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217QuotasGroupsResponse(rsp)
}

// GetApi217QuotasGroupsWithResponse request returning *GetApi217QuotasGroupsResponse
func (c *ClientWithResponses) GetApi217QuotasGroupsWithResponse(ctx context.Context, params *GetApi217QuotasGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217QuotasGroupsResponse, error) {
	rsp, err := c.GetApi217QuotasGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217QuotasGroupsResponse(rsp)
}

// PatchApi217QuotasGroupsWithBodyWithResponse request with arbitrary body returning *PatchApi217QuotasGroupsResponse
func (c *ClientWithResponses) PatchApi217QuotasGroupsWithBodyWithResponse(ctx context.Context, params *PatchApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QuotasGroupsResponse, error) {
	rsp, err := c.PatchApi217QuotasGroupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QuotasGroupsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217QuotasGroupsWithResponse(ctx context.Context, params *PatchApi217QuotasGroupsParams, body PatchApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QuotasGroupsResponse, error) {
	rsp, err := c.PatchApi217QuotasGroups(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QuotasGroupsResponse(rsp)
}

// PostApi217QuotasGroupsWithBodyWithResponse request with arbitrary body returning *PostApi217QuotasGroupsResponse
func (c *ClientWithResponses) PostApi217QuotasGroupsWithBodyWithResponse(ctx context.Context, params *PostApi217QuotasGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217QuotasGroupsResponse, error) {
	rsp, err := c.PostApi217QuotasGroupsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217QuotasGroupsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217QuotasGroupsWithResponse(ctx context.Context, params *PostApi217QuotasGroupsParams, body PostApi217QuotasGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217QuotasGroupsResponse, error) {
	rsp, err := c.PostApi217QuotasGroups(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217QuotasGroupsResponse(rsp)
}

// GetApi217QuotasSettingsWithResponse request returning *GetApi217QuotasSettingsResponse
func (c *ClientWithResponses) GetApi217QuotasSettingsWithResponse(ctx context.Context, params *GetApi217QuotasSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217QuotasSettingsResponse, error) {
	rsp, err := c.GetApi217QuotasSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217QuotasSettingsResponse(rsp)
}

// PatchApi217QuotasSettingsWithBodyWithResponse request with arbitrary body returning *PatchApi217QuotasSettingsResponse
func (c *ClientWithResponses) PatchApi217QuotasSettingsWithBodyWithResponse(ctx context.Context, params *PatchApi217QuotasSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QuotasSettingsResponse, error) {
	rsp, err := c.PatchApi217QuotasSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QuotasSettingsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217QuotasSettingsWithResponse(ctx context.Context, params *PatchApi217QuotasSettingsParams, body PatchApi217QuotasSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QuotasSettingsResponse, error) {
	rsp, err := c.PatchApi217QuotasSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QuotasSettingsResponse(rsp)
}

// DeleteApi217QuotasUsersWithResponse request returning *DeleteApi217QuotasUsersResponse
func (c *ClientWithResponses) DeleteApi217QuotasUsersWithResponse(ctx context.Context, params *DeleteApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*DeleteApi217QuotasUsersResponse, error) {
	rsp, err := c.DeleteApi217QuotasUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217QuotasUsersResponse(rsp)
}

// GetApi217QuotasUsersWithResponse request returning *GetApi217QuotasUsersResponse
func (c *ClientWithResponses) GetApi217QuotasUsersWithResponse(ctx context.Context, params *GetApi217QuotasUsersParams, reqEditors ...RequestEditorFn) (*GetApi217QuotasUsersResponse, error) {
	rsp, err := c.GetApi217QuotasUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217QuotasUsersResponse(rsp)
}

// PatchApi217QuotasUsersWithBodyWithResponse request with arbitrary body returning *PatchApi217QuotasUsersResponse
func (c *ClientWithResponses) PatchApi217QuotasUsersWithBodyWithResponse(ctx context.Context, params *PatchApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217QuotasUsersResponse, error) {
	rsp, err := c.PatchApi217QuotasUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QuotasUsersResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217QuotasUsersWithResponse(ctx context.Context, params *PatchApi217QuotasUsersParams, body PatchApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217QuotasUsersResponse, error) {
	rsp, err := c.PatchApi217QuotasUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217QuotasUsersResponse(rsp)
}

// PostApi217QuotasUsersWithBodyWithResponse request with arbitrary body returning *PostApi217QuotasUsersResponse
func (c *ClientWithResponses) PostApi217QuotasUsersWithBodyWithResponse(ctx context.Context, params *PostApi217QuotasUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217QuotasUsersResponse, error) {
	rsp, err := c.PostApi217QuotasUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217QuotasUsersResponse(rsp)
}

func (c *ClientWithResponses) PostApi217QuotasUsersWithResponse(ctx context.Context, params *PostApi217QuotasUsersParams, body PostApi217QuotasUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217QuotasUsersResponse, error) {
	rsp, err := c.PostApi217QuotasUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217QuotasUsersResponse(rsp)
}

// GetApi217RapidDataLockingWithResponse request returning *GetApi217RapidDataLockingResponse
func (c *ClientWithResponses) GetApi217RapidDataLockingWithResponse(ctx context.Context, params *GetApi217RapidDataLockingParams, reqEditors ...RequestEditorFn) (*GetApi217RapidDataLockingResponse, error) {
	rsp, err := c.GetApi217RapidDataLocking(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217RapidDataLockingResponse(rsp)
}

// PatchApi217RapidDataLockingWithBodyWithResponse request with arbitrary body returning *PatchApi217RapidDataLockingResponse
func (c *ClientWithResponses) PatchApi217RapidDataLockingWithBodyWithResponse(ctx context.Context, params *PatchApi217RapidDataLockingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217RapidDataLockingResponse, error) {
	rsp, err := c.PatchApi217RapidDataLockingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217RapidDataLockingResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217RapidDataLockingWithResponse(ctx context.Context, params *PatchApi217RapidDataLockingParams, body PatchApi217RapidDataLockingJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217RapidDataLockingResponse, error) {
	rsp, err := c.PatchApi217RapidDataLocking(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217RapidDataLockingResponse(rsp)
}

// PostApi217RapidDataLockingRotateWithResponse request returning *PostApi217RapidDataLockingRotateResponse
func (c *ClientWithResponses) PostApi217RapidDataLockingRotateWithResponse(ctx context.Context, params *PostApi217RapidDataLockingRotateParams, reqEditors ...RequestEditorFn) (*PostApi217RapidDataLockingRotateResponse, error) {
	rsp, err := c.PostApi217RapidDataLockingRotate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217RapidDataLockingRotateResponse(rsp)
}

// GetApi217RapidDataLockingTestWithResponse request returning *GetApi217RapidDataLockingTestResponse
func (c *ClientWithResponses) GetApi217RapidDataLockingTestWithResponse(ctx context.Context, params *GetApi217RapidDataLockingTestParams, reqEditors ...RequestEditorFn) (*GetApi217RapidDataLockingTestResponse, error) {
	rsp, err := c.GetApi217RapidDataLockingTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217RapidDataLockingTestResponse(rsp)
}

// GetApi217RemoteArraysWithResponse request returning *GetApi217RemoteArraysResponse
func (c *ClientWithResponses) GetApi217RemoteArraysWithResponse(ctx context.Context, params *GetApi217RemoteArraysParams, reqEditors ...RequestEditorFn) (*GetApi217RemoteArraysResponse, error) {
	rsp, err := c.GetApi217RemoteArrays(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217RemoteArraysResponse(rsp)
}

// GetApi217RolesWithResponse request returning *GetApi217RolesResponse
func (c *ClientWithResponses) GetApi217RolesWithResponse(ctx context.Context, params *GetApi217RolesParams, reqEditors ...RequestEditorFn) (*GetApi217RolesResponse, error) {
	rsp, err := c.GetApi217Roles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217RolesResponse(rsp)
}

// DeleteApi217ServersWithResponse request returning *DeleteApi217ServersResponse
func (c *ClientWithResponses) DeleteApi217ServersWithResponse(ctx context.Context, params *DeleteApi217ServersParams, reqEditors ...RequestEditorFn) (*DeleteApi217ServersResponse, error) {
	rsp, err := c.DeleteApi217Servers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217ServersResponse(rsp)
}

// GetApi217ServersWithResponse request returning *GetApi217ServersResponse
func (c *ClientWithResponses) GetApi217ServersWithResponse(ctx context.Context, params *GetApi217ServersParams, reqEditors ...RequestEditorFn) (*GetApi217ServersResponse, error) {
	rsp, err := c.GetApi217Servers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217ServersResponse(rsp)
}

// PatchApi217ServersWithBodyWithResponse request with arbitrary body returning *PatchApi217ServersResponse
func (c *ClientWithResponses) PatchApi217ServersWithBodyWithResponse(ctx context.Context, params *PatchApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217ServersResponse, error) {
	rsp, err := c.PatchApi217ServersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ServersResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217ServersWithResponse(ctx context.Context, params *PatchApi217ServersParams, body PatchApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217ServersResponse, error) {
	rsp, err := c.PatchApi217Servers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217ServersResponse(rsp)
}

// PostApi217ServersWithBodyWithResponse request with arbitrary body returning *PostApi217ServersResponse
func (c *ClientWithResponses) PostApi217ServersWithBodyWithResponse(ctx context.Context, params *PostApi217ServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217ServersResponse, error) {
	rsp, err := c.PostApi217ServersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ServersResponse(rsp)
}

func (c *ClientWithResponses) PostApi217ServersWithResponse(ctx context.Context, params *PostApi217ServersParams, body PostApi217ServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217ServersResponse, error) {
	rsp, err := c.PostApi217Servers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217ServersResponse(rsp)
}

// GetApi217SessionsWithResponse request returning *GetApi217SessionsResponse
func (c *ClientWithResponses) GetApi217SessionsWithResponse(ctx context.Context, params *GetApi217SessionsParams, reqEditors ...RequestEditorFn) (*GetApi217SessionsResponse, error) {
	rsp, err := c.GetApi217Sessions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SessionsResponse(rsp)
}

// DeleteApi217SmbClientPoliciesWithResponse request returning *DeleteApi217SmbClientPoliciesResponse
func (c *ClientWithResponses) DeleteApi217SmbClientPoliciesWithResponse(ctx context.Context, params *DeleteApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbClientPoliciesResponse, error) {
	rsp, err := c.DeleteApi217SmbClientPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SmbClientPoliciesResponse(rsp)
}

// GetApi217SmbClientPoliciesWithResponse request returning *GetApi217SmbClientPoliciesResponse
func (c *ClientWithResponses) GetApi217SmbClientPoliciesWithResponse(ctx context.Context, params *GetApi217SmbClientPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbClientPoliciesResponse, error) {
	rsp, err := c.GetApi217SmbClientPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SmbClientPoliciesResponse(rsp)
}

// PatchApi217SmbClientPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217SmbClientPoliciesResponse
func (c *ClientWithResponses) PatchApi217SmbClientPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesResponse, error) {
	rsp, err := c.PatchApi217SmbClientPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbClientPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SmbClientPoliciesWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesParams, body PatchApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesResponse, error) {
	rsp, err := c.PatchApi217SmbClientPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbClientPoliciesResponse(rsp)
}

// PostApi217SmbClientPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217SmbClientPoliciesResponse
func (c *ClientWithResponses) PostApi217SmbClientPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesResponse, error) {
	rsp, err := c.PostApi217SmbClientPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbClientPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SmbClientPoliciesWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesParams, body PostApi217SmbClientPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesResponse, error) {
	rsp, err := c.PostApi217SmbClientPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbClientPoliciesResponse(rsp)
}

// DeleteApi217SmbClientPoliciesRulesWithResponse request returning *DeleteApi217SmbClientPoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbClientPoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217SmbClientPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SmbClientPoliciesRulesResponse(rsp)
}

// GetApi217SmbClientPoliciesRulesWithResponse request returning *GetApi217SmbClientPoliciesRulesResponse
func (c *ClientWithResponses) GetApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *GetApi217SmbClientPoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbClientPoliciesRulesResponse, error) {
	rsp, err := c.GetApi217SmbClientPoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SmbClientPoliciesRulesResponse(rsp)
}

// PatchApi217SmbClientPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PatchApi217SmbClientPoliciesRulesResponse
func (c *ClientWithResponses) PatchApi217SmbClientPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217SmbClientPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbClientPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *PatchApi217SmbClientPoliciesRulesParams, body PatchApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbClientPoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217SmbClientPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbClientPoliciesRulesResponse(rsp)
}

// PostApi217SmbClientPoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217SmbClientPoliciesRulesResponse
func (c *ClientWithResponses) PostApi217SmbClientPoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217SmbClientPoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbClientPoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SmbClientPoliciesRulesWithResponse(ctx context.Context, params *PostApi217SmbClientPoliciesRulesParams, body PostApi217SmbClientPoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbClientPoliciesRulesResponse, error) {
	rsp, err := c.PostApi217SmbClientPoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbClientPoliciesRulesResponse(rsp)
}

// DeleteApi217SmbSharePoliciesWithResponse request returning *DeleteApi217SmbSharePoliciesResponse
func (c *ClientWithResponses) DeleteApi217SmbSharePoliciesWithResponse(ctx context.Context, params *DeleteApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbSharePoliciesResponse, error) {
	rsp, err := c.DeleteApi217SmbSharePolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SmbSharePoliciesResponse(rsp)
}

// GetApi217SmbSharePoliciesWithResponse request returning *GetApi217SmbSharePoliciesResponse
func (c *ClientWithResponses) GetApi217SmbSharePoliciesWithResponse(ctx context.Context, params *GetApi217SmbSharePoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbSharePoliciesResponse, error) {
	rsp, err := c.GetApi217SmbSharePolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SmbSharePoliciesResponse(rsp)
}

// PatchApi217SmbSharePoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217SmbSharePoliciesResponse
func (c *ClientWithResponses) PatchApi217SmbSharePoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesResponse, error) {
	rsp, err := c.PatchApi217SmbSharePoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbSharePoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SmbSharePoliciesWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesParams, body PatchApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesResponse, error) {
	rsp, err := c.PatchApi217SmbSharePolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbSharePoliciesResponse(rsp)
}

// PostApi217SmbSharePoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217SmbSharePoliciesResponse
func (c *ClientWithResponses) PostApi217SmbSharePoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesResponse, error) {
	rsp, err := c.PostApi217SmbSharePoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbSharePoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SmbSharePoliciesWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesParams, body PostApi217SmbSharePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesResponse, error) {
	rsp, err := c.PostApi217SmbSharePolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbSharePoliciesResponse(rsp)
}

// DeleteApi217SmbSharePoliciesRulesWithResponse request returning *DeleteApi217SmbSharePoliciesRulesResponse
func (c *ClientWithResponses) DeleteApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *DeleteApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SmbSharePoliciesRulesResponse, error) {
	rsp, err := c.DeleteApi217SmbSharePoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SmbSharePoliciesRulesResponse(rsp)
}

// GetApi217SmbSharePoliciesRulesWithResponse request returning *GetApi217SmbSharePoliciesRulesResponse
func (c *ClientWithResponses) GetApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *GetApi217SmbSharePoliciesRulesParams, reqEditors ...RequestEditorFn) (*GetApi217SmbSharePoliciesRulesResponse, error) {
	rsp, err := c.GetApi217SmbSharePoliciesRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SmbSharePoliciesRulesResponse(rsp)
}

// PatchApi217SmbSharePoliciesRulesWithBodyWithResponse request with arbitrary body returning *PatchApi217SmbSharePoliciesRulesResponse
func (c *ClientWithResponses) PatchApi217SmbSharePoliciesRulesWithBodyWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217SmbSharePoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbSharePoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *PatchApi217SmbSharePoliciesRulesParams, body PatchApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmbSharePoliciesRulesResponse, error) {
	rsp, err := c.PatchApi217SmbSharePoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmbSharePoliciesRulesResponse(rsp)
}

// PostApi217SmbSharePoliciesRulesWithBodyWithResponse request with arbitrary body returning *PostApi217SmbSharePoliciesRulesResponse
func (c *ClientWithResponses) PostApi217SmbSharePoliciesRulesWithBodyWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesRulesResponse, error) {
	rsp, err := c.PostApi217SmbSharePoliciesRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbSharePoliciesRulesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SmbSharePoliciesRulesWithResponse(ctx context.Context, params *PostApi217SmbSharePoliciesRulesParams, body PostApi217SmbSharePoliciesRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SmbSharePoliciesRulesResponse, error) {
	rsp, err := c.PostApi217SmbSharePoliciesRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SmbSharePoliciesRulesResponse(rsp)
}

// GetApi217SmtpServersWithResponse request returning *GetApi217SmtpServersResponse
func (c *ClientWithResponses) GetApi217SmtpServersWithResponse(ctx context.Context, params *GetApi217SmtpServersParams, reqEditors ...RequestEditorFn) (*GetApi217SmtpServersResponse, error) {
	rsp, err := c.GetApi217SmtpServers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SmtpServersResponse(rsp)
}

// PatchApi217SmtpServersWithBodyWithResponse request with arbitrary body returning *PatchApi217SmtpServersResponse
func (c *ClientWithResponses) PatchApi217SmtpServersWithBodyWithResponse(ctx context.Context, params *PatchApi217SmtpServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SmtpServersResponse, error) {
	rsp, err := c.PatchApi217SmtpServersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmtpServersResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SmtpServersWithResponse(ctx context.Context, params *PatchApi217SmtpServersParams, body PatchApi217SmtpServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SmtpServersResponse, error) {
	rsp, err := c.PatchApi217SmtpServers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SmtpServersResponse(rsp)
}

// GetApi217SnmpAgentsWithResponse request returning *GetApi217SnmpAgentsResponse
func (c *ClientWithResponses) GetApi217SnmpAgentsWithResponse(ctx context.Context, params *GetApi217SnmpAgentsParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpAgentsResponse, error) {
	rsp, err := c.GetApi217SnmpAgents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SnmpAgentsResponse(rsp)
}

// PatchApi217SnmpAgentsWithBodyWithResponse request with arbitrary body returning *PatchApi217SnmpAgentsResponse
func (c *ClientWithResponses) PatchApi217SnmpAgentsWithBodyWithResponse(ctx context.Context, params *PatchApi217SnmpAgentsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SnmpAgentsResponse, error) {
	rsp, err := c.PatchApi217SnmpAgentsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SnmpAgentsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SnmpAgentsWithResponse(ctx context.Context, params *PatchApi217SnmpAgentsParams, body PatchApi217SnmpAgentsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SnmpAgentsResponse, error) {
	rsp, err := c.PatchApi217SnmpAgents(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SnmpAgentsResponse(rsp)
}

// GetApi217SnmpAgentsMibWithResponse request returning *GetApi217SnmpAgentsMibResponse
func (c *ClientWithResponses) GetApi217SnmpAgentsMibWithResponse(ctx context.Context, params *GetApi217SnmpAgentsMibParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpAgentsMibResponse, error) {
	rsp, err := c.GetApi217SnmpAgentsMib(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SnmpAgentsMibResponse(rsp)
}

// DeleteApi217SnmpManagersWithResponse request returning *DeleteApi217SnmpManagersResponse
func (c *ClientWithResponses) DeleteApi217SnmpManagersWithResponse(ctx context.Context, params *DeleteApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*DeleteApi217SnmpManagersResponse, error) {
	rsp, err := c.DeleteApi217SnmpManagers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SnmpManagersResponse(rsp)
}

// GetApi217SnmpManagersWithResponse request returning *GetApi217SnmpManagersResponse
func (c *ClientWithResponses) GetApi217SnmpManagersWithResponse(ctx context.Context, params *GetApi217SnmpManagersParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpManagersResponse, error) {
	rsp, err := c.GetApi217SnmpManagers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SnmpManagersResponse(rsp)
}

// PatchApi217SnmpManagersWithBodyWithResponse request with arbitrary body returning *PatchApi217SnmpManagersResponse
func (c *ClientWithResponses) PatchApi217SnmpManagersWithBodyWithResponse(ctx context.Context, params *PatchApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SnmpManagersResponse, error) {
	rsp, err := c.PatchApi217SnmpManagersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SnmpManagersResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SnmpManagersWithResponse(ctx context.Context, params *PatchApi217SnmpManagersParams, body PatchApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SnmpManagersResponse, error) {
	rsp, err := c.PatchApi217SnmpManagers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SnmpManagersResponse(rsp)
}

// PostApi217SnmpManagersWithBodyWithResponse request with arbitrary body returning *PostApi217SnmpManagersResponse
func (c *ClientWithResponses) PostApi217SnmpManagersWithBodyWithResponse(ctx context.Context, params *PostApi217SnmpManagersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SnmpManagersResponse, error) {
	rsp, err := c.PostApi217SnmpManagersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SnmpManagersResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SnmpManagersWithResponse(ctx context.Context, params *PostApi217SnmpManagersParams, body PostApi217SnmpManagersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SnmpManagersResponse, error) {
	rsp, err := c.PostApi217SnmpManagers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SnmpManagersResponse(rsp)
}

// GetApi217SnmpManagersTestWithResponse request returning *GetApi217SnmpManagersTestResponse
func (c *ClientWithResponses) GetApi217SnmpManagersTestWithResponse(ctx context.Context, params *GetApi217SnmpManagersTestParams, reqEditors ...RequestEditorFn) (*GetApi217SnmpManagersTestResponse, error) {
	rsp, err := c.GetApi217SnmpManagersTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SnmpManagersTestResponse(rsp)
}

// GetApi217SoftwareCheckWithResponse request returning *GetApi217SoftwareCheckResponse
func (c *ClientWithResponses) GetApi217SoftwareCheckWithResponse(ctx context.Context, params *GetApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*GetApi217SoftwareCheckResponse, error) {
	rsp, err := c.GetApi217SoftwareCheck(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SoftwareCheckResponse(rsp)
}

// PostApi217SoftwareCheckWithResponse request returning *PostApi217SoftwareCheckResponse
func (c *ClientWithResponses) PostApi217SoftwareCheckWithResponse(ctx context.Context, params *PostApi217SoftwareCheckParams, reqEditors ...RequestEditorFn) (*PostApi217SoftwareCheckResponse, error) {
	rsp, err := c.PostApi217SoftwareCheck(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SoftwareCheckResponse(rsp)
}

// DeleteApi217SshCertificateAuthorityPoliciesWithResponse request returning *DeleteApi217SshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) DeleteApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217SshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.DeleteApi217SshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SshCertificateAuthorityPoliciesResponse(rsp)
}

// GetApi217SshCertificateAuthorityPoliciesWithResponse request returning *GetApi217SshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) GetApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.GetApi217SshCertificateAuthorityPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SshCertificateAuthorityPoliciesResponse(rsp)
}

// PatchApi217SshCertificateAuthorityPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217SshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) PatchApi217SshCertificateAuthorityPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.PatchApi217SshCertificateAuthorityPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SshCertificateAuthorityPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PatchApi217SshCertificateAuthorityPoliciesParams, body PatchApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.PatchApi217SshCertificateAuthorityPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SshCertificateAuthorityPoliciesResponse(rsp)
}

// PostApi217SshCertificateAuthorityPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217SshCertificateAuthorityPoliciesResponse
func (c *ClientWithResponses) PostApi217SshCertificateAuthorityPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.PostApi217SshCertificateAuthorityPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SshCertificateAuthorityPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SshCertificateAuthorityPoliciesWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesParams, body PostApi217SshCertificateAuthorityPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesResponse, error) {
	rsp, err := c.PostApi217SshCertificateAuthorityPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SshCertificateAuthorityPoliciesResponse(rsp)
}

// DeleteApi217SshCertificateAuthorityPoliciesAdminsWithResponse request returning *DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse
func (c *ClientWithResponses) DeleteApi217SshCertificateAuthorityPoliciesAdminsWithResponse(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse, error) {
	rsp, err := c.DeleteApi217SshCertificateAuthorityPoliciesAdmins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SshCertificateAuthorityPoliciesAdminsResponse(rsp)
}

// GetApi217SshCertificateAuthorityPoliciesAdminsWithResponse request returning *GetApi217SshCertificateAuthorityPoliciesAdminsResponse
func (c *ClientWithResponses) GetApi217SshCertificateAuthorityPoliciesAdminsWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesAdminsResponse, error) {
	rsp, err := c.GetApi217SshCertificateAuthorityPoliciesAdmins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SshCertificateAuthorityPoliciesAdminsResponse(rsp)
}

// PostApi217SshCertificateAuthorityPoliciesAdminsWithResponse request returning *PostApi217SshCertificateAuthorityPoliciesAdminsResponse
func (c *ClientWithResponses) PostApi217SshCertificateAuthorityPoliciesAdminsWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesAdminsParams, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesAdminsResponse, error) {
	rsp, err := c.PostApi217SshCertificateAuthorityPoliciesAdmins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SshCertificateAuthorityPoliciesAdminsResponse(rsp)
}

// DeleteApi217SshCertificateAuthorityPoliciesArraysWithResponse request returning *DeleteApi217SshCertificateAuthorityPoliciesArraysResponse
func (c *ClientWithResponses) DeleteApi217SshCertificateAuthorityPoliciesArraysWithResponse(ctx context.Context, params *DeleteApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*DeleteApi217SshCertificateAuthorityPoliciesArraysResponse, error) {
	rsp, err := c.DeleteApi217SshCertificateAuthorityPoliciesArrays(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SshCertificateAuthorityPoliciesArraysResponse(rsp)
}

// GetApi217SshCertificateAuthorityPoliciesArraysWithResponse request returning *GetApi217SshCertificateAuthorityPoliciesArraysResponse
func (c *ClientWithResponses) GetApi217SshCertificateAuthorityPoliciesArraysWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesArraysResponse, error) {
	rsp, err := c.GetApi217SshCertificateAuthorityPoliciesArrays(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SshCertificateAuthorityPoliciesArraysResponse(rsp)
}

// PostApi217SshCertificateAuthorityPoliciesArraysWithResponse request returning *PostApi217SshCertificateAuthorityPoliciesArraysResponse
func (c *ClientWithResponses) PostApi217SshCertificateAuthorityPoliciesArraysWithResponse(ctx context.Context, params *PostApi217SshCertificateAuthorityPoliciesArraysParams, reqEditors ...RequestEditorFn) (*PostApi217SshCertificateAuthorityPoliciesArraysResponse, error) {
	rsp, err := c.PostApi217SshCertificateAuthorityPoliciesArrays(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SshCertificateAuthorityPoliciesArraysResponse(rsp)
}

// GetApi217SshCertificateAuthorityPoliciesMembersWithResponse request returning *GetApi217SshCertificateAuthorityPoliciesMembersResponse
func (c *ClientWithResponses) GetApi217SshCertificateAuthorityPoliciesMembersWithResponse(ctx context.Context, params *GetApi217SshCertificateAuthorityPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217SshCertificateAuthorityPoliciesMembersResponse, error) {
	rsp, err := c.GetApi217SshCertificateAuthorityPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SshCertificateAuthorityPoliciesMembersResponse(rsp)
}

// DeleteApi217SsoOidcIdpsWithResponse request returning *DeleteApi217SsoOidcIdpsResponse
func (c *ClientWithResponses) DeleteApi217SsoOidcIdpsWithResponse(ctx context.Context, params *DeleteApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SsoOidcIdpsResponse, error) {
	rsp, err := c.DeleteApi217SsoOidcIdps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SsoOidcIdpsResponse(rsp)
}

// GetApi217SsoOidcIdpsWithResponse request returning *GetApi217SsoOidcIdpsResponse
func (c *ClientWithResponses) GetApi217SsoOidcIdpsWithResponse(ctx context.Context, params *GetApi217SsoOidcIdpsParams, reqEditors ...RequestEditorFn) (*GetApi217SsoOidcIdpsResponse, error) {
	rsp, err := c.GetApi217SsoOidcIdps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SsoOidcIdpsResponse(rsp)
}

// PatchApi217SsoOidcIdpsWithBodyWithResponse request with arbitrary body returning *PatchApi217SsoOidcIdpsResponse
func (c *ClientWithResponses) PatchApi217SsoOidcIdpsWithBodyWithResponse(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SsoOidcIdpsResponse, error) {
	rsp, err := c.PatchApi217SsoOidcIdpsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SsoOidcIdpsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SsoOidcIdpsWithResponse(ctx context.Context, params *PatchApi217SsoOidcIdpsParams, body PatchApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SsoOidcIdpsResponse, error) {
	rsp, err := c.PatchApi217SsoOidcIdps(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SsoOidcIdpsResponse(rsp)
}

// PostApi217SsoOidcIdpsWithBodyWithResponse request with arbitrary body returning *PostApi217SsoOidcIdpsResponse
func (c *ClientWithResponses) PostApi217SsoOidcIdpsWithBodyWithResponse(ctx context.Context, params *PostApi217SsoOidcIdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SsoOidcIdpsResponse, error) {
	rsp, err := c.PostApi217SsoOidcIdpsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SsoOidcIdpsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SsoOidcIdpsWithResponse(ctx context.Context, params *PostApi217SsoOidcIdpsParams, body PostApi217SsoOidcIdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SsoOidcIdpsResponse, error) {
	rsp, err := c.PostApi217SsoOidcIdps(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SsoOidcIdpsResponse(rsp)
}

// DeleteApi217SsoSaml2IdpsWithResponse request returning *DeleteApi217SsoSaml2IdpsResponse
func (c *ClientWithResponses) DeleteApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *DeleteApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SsoSaml2IdpsResponse, error) {
	rsp, err := c.DeleteApi217SsoSaml2Idps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SsoSaml2IdpsResponse(rsp)
}

// GetApi217SsoSaml2IdpsWithResponse request returning *GetApi217SsoSaml2IdpsResponse
func (c *ClientWithResponses) GetApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *GetApi217SsoSaml2IdpsParams, reqEditors ...RequestEditorFn) (*GetApi217SsoSaml2IdpsResponse, error) {
	rsp, err := c.GetApi217SsoSaml2Idps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SsoSaml2IdpsResponse(rsp)
}

// PatchApi217SsoSaml2IdpsWithBodyWithResponse request with arbitrary body returning *PatchApi217SsoSaml2IdpsResponse
func (c *ClientWithResponses) PatchApi217SsoSaml2IdpsWithBodyWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsResponse, error) {
	rsp, err := c.PatchApi217SsoSaml2IdpsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SsoSaml2IdpsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsParams, body PatchApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsResponse, error) {
	rsp, err := c.PatchApi217SsoSaml2Idps(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SsoSaml2IdpsResponse(rsp)
}

// PostApi217SsoSaml2IdpsWithBodyWithResponse request with arbitrary body returning *PostApi217SsoSaml2IdpsResponse
func (c *ClientWithResponses) PostApi217SsoSaml2IdpsWithBodyWithResponse(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SsoSaml2IdpsResponse, error) {
	rsp, err := c.PostApi217SsoSaml2IdpsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SsoSaml2IdpsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SsoSaml2IdpsWithResponse(ctx context.Context, params *PostApi217SsoSaml2IdpsParams, body PostApi217SsoSaml2IdpsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SsoSaml2IdpsResponse, error) {
	rsp, err := c.PostApi217SsoSaml2Idps(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SsoSaml2IdpsResponse(rsp)
}

// GetApi217SsoSaml2IdpsTestWithResponse request returning *GetApi217SsoSaml2IdpsTestResponse
func (c *ClientWithResponses) GetApi217SsoSaml2IdpsTestWithResponse(ctx context.Context, params *GetApi217SsoSaml2IdpsTestParams, reqEditors ...RequestEditorFn) (*GetApi217SsoSaml2IdpsTestResponse, error) {
	rsp, err := c.GetApi217SsoSaml2IdpsTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SsoSaml2IdpsTestResponse(rsp)
}

// PatchApi217SsoSaml2IdpsTestWithBodyWithResponse request with arbitrary body returning *PatchApi217SsoSaml2IdpsTestResponse
func (c *ClientWithResponses) PatchApi217SsoSaml2IdpsTestWithBodyWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsTestResponse, error) {
	rsp, err := c.PatchApi217SsoSaml2IdpsTestWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SsoSaml2IdpsTestResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SsoSaml2IdpsTestWithResponse(ctx context.Context, params *PatchApi217SsoSaml2IdpsTestParams, body PatchApi217SsoSaml2IdpsTestJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SsoSaml2IdpsTestResponse, error) {
	rsp, err := c.PatchApi217SsoSaml2IdpsTest(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SsoSaml2IdpsTestResponse(rsp)
}

// DeleteApi217SubnetsWithResponse request returning *DeleteApi217SubnetsResponse
func (c *ClientWithResponses) DeleteApi217SubnetsWithResponse(ctx context.Context, params *DeleteApi217SubnetsParams, reqEditors ...RequestEditorFn) (*DeleteApi217SubnetsResponse, error) {
	rsp, err := c.DeleteApi217Subnets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SubnetsResponse(rsp)
}

// GetApi217SubnetsWithResponse request returning *GetApi217SubnetsResponse
func (c *ClientWithResponses) GetApi217SubnetsWithResponse(ctx context.Context, params *GetApi217SubnetsParams, reqEditors ...RequestEditorFn) (*GetApi217SubnetsResponse, error) {
	rsp, err := c.GetApi217Subnets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SubnetsResponse(rsp)
}

// PatchApi217SubnetsWithBodyWithResponse request with arbitrary body returning *PatchApi217SubnetsResponse
func (c *ClientWithResponses) PatchApi217SubnetsWithBodyWithResponse(ctx context.Context, params *PatchApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SubnetsResponse, error) {
	rsp, err := c.PatchApi217SubnetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SubnetsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SubnetsWithResponse(ctx context.Context, params *PatchApi217SubnetsParams, body PatchApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SubnetsResponse, error) {
	rsp, err := c.PatchApi217Subnets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SubnetsResponse(rsp)
}

// PostApi217SubnetsWithBodyWithResponse request with arbitrary body returning *PostApi217SubnetsResponse
func (c *ClientWithResponses) PostApi217SubnetsWithBodyWithResponse(ctx context.Context, params *PostApi217SubnetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SubnetsResponse, error) {
	rsp, err := c.PostApi217SubnetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SubnetsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SubnetsWithResponse(ctx context.Context, params *PostApi217SubnetsParams, body PostApi217SubnetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SubnetsResponse, error) {
	rsp, err := c.PostApi217Subnets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SubnetsResponse(rsp)
}

// GetApi217SupportWithResponse request returning *GetApi217SupportResponse
func (c *ClientWithResponses) GetApi217SupportWithResponse(ctx context.Context, params *GetApi217SupportParams, reqEditors ...RequestEditorFn) (*GetApi217SupportResponse, error) {
	rsp, err := c.GetApi217Support(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SupportResponse(rsp)
}

// PatchApi217SupportWithBodyWithResponse request with arbitrary body returning *PatchApi217SupportResponse
func (c *ClientWithResponses) PatchApi217SupportWithBodyWithResponse(ctx context.Context, params *PatchApi217SupportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SupportResponse, error) {
	rsp, err := c.PatchApi217SupportWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SupportResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SupportWithResponse(ctx context.Context, params *PatchApi217SupportParams, body PatchApi217SupportJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SupportResponse, error) {
	rsp, err := c.PatchApi217Support(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SupportResponse(rsp)
}

// GetApi217SupportDiagnosticsWithResponse request returning *GetApi217SupportDiagnosticsResponse
func (c *ClientWithResponses) GetApi217SupportDiagnosticsWithResponse(ctx context.Context, params *GetApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*GetApi217SupportDiagnosticsResponse, error) {
	rsp, err := c.GetApi217SupportDiagnostics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SupportDiagnosticsResponse(rsp)
}

// PostApi217SupportDiagnosticsWithResponse request returning *PostApi217SupportDiagnosticsResponse
func (c *ClientWithResponses) PostApi217SupportDiagnosticsWithResponse(ctx context.Context, params *PostApi217SupportDiagnosticsParams, reqEditors ...RequestEditorFn) (*PostApi217SupportDiagnosticsResponse, error) {
	rsp, err := c.PostApi217SupportDiagnostics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SupportDiagnosticsResponse(rsp)
}

// GetApi217SupportDiagnosticsDetailsWithResponse request returning *GetApi217SupportDiagnosticsDetailsResponse
func (c *ClientWithResponses) GetApi217SupportDiagnosticsDetailsWithResponse(ctx context.Context, params *GetApi217SupportDiagnosticsDetailsParams, reqEditors ...RequestEditorFn) (*GetApi217SupportDiagnosticsDetailsResponse, error) {
	rsp, err := c.GetApi217SupportDiagnosticsDetails(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SupportDiagnosticsDetailsResponse(rsp)
}

// GetApi217SupportTestWithResponse request returning *GetApi217SupportTestResponse
func (c *ClientWithResponses) GetApi217SupportTestWithResponse(ctx context.Context, params *GetApi217SupportTestParams, reqEditors ...RequestEditorFn) (*GetApi217SupportTestResponse, error) {
	rsp, err := c.GetApi217SupportTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SupportTestResponse(rsp)
}

// GetApi217SupportVerificationKeysWithResponse request returning *GetApi217SupportVerificationKeysResponse
func (c *ClientWithResponses) GetApi217SupportVerificationKeysWithResponse(ctx context.Context, params *GetApi217SupportVerificationKeysParams, reqEditors ...RequestEditorFn) (*GetApi217SupportVerificationKeysResponse, error) {
	rsp, err := c.GetApi217SupportVerificationKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SupportVerificationKeysResponse(rsp)
}

// PatchApi217SupportVerificationKeysWithBodyWithResponse request with arbitrary body returning *PatchApi217SupportVerificationKeysResponse
func (c *ClientWithResponses) PatchApi217SupportVerificationKeysWithBodyWithResponse(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SupportVerificationKeysResponse, error) {
	rsp, err := c.PatchApi217SupportVerificationKeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SupportVerificationKeysResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SupportVerificationKeysWithResponse(ctx context.Context, params *PatchApi217SupportVerificationKeysParams, body PatchApi217SupportVerificationKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SupportVerificationKeysResponse, error) {
	rsp, err := c.PatchApi217SupportVerificationKeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SupportVerificationKeysResponse(rsp)
}

// DeleteApi217SyslogServersWithResponse request returning *DeleteApi217SyslogServersResponse
func (c *ClientWithResponses) DeleteApi217SyslogServersWithResponse(ctx context.Context, params *DeleteApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*DeleteApi217SyslogServersResponse, error) {
	rsp, err := c.DeleteApi217SyslogServers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217SyslogServersResponse(rsp)
}

// GetApi217SyslogServersWithResponse request returning *GetApi217SyslogServersResponse
func (c *ClientWithResponses) GetApi217SyslogServersWithResponse(ctx context.Context, params *GetApi217SyslogServersParams, reqEditors ...RequestEditorFn) (*GetApi217SyslogServersResponse, error) {
	rsp, err := c.GetApi217SyslogServers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SyslogServersResponse(rsp)
}

// PatchApi217SyslogServersWithBodyWithResponse request with arbitrary body returning *PatchApi217SyslogServersResponse
func (c *ClientWithResponses) PatchApi217SyslogServersWithBodyWithResponse(ctx context.Context, params *PatchApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersResponse, error) {
	rsp, err := c.PatchApi217SyslogServersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SyslogServersResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SyslogServersWithResponse(ctx context.Context, params *PatchApi217SyslogServersParams, body PatchApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersResponse, error) {
	rsp, err := c.PatchApi217SyslogServers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SyslogServersResponse(rsp)
}

// PostApi217SyslogServersWithBodyWithResponse request with arbitrary body returning *PostApi217SyslogServersResponse
func (c *ClientWithResponses) PostApi217SyslogServersWithBodyWithResponse(ctx context.Context, params *PostApi217SyslogServersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217SyslogServersResponse, error) {
	rsp, err := c.PostApi217SyslogServersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SyslogServersResponse(rsp)
}

func (c *ClientWithResponses) PostApi217SyslogServersWithResponse(ctx context.Context, params *PostApi217SyslogServersParams, body PostApi217SyslogServersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217SyslogServersResponse, error) {
	rsp, err := c.PostApi217SyslogServers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217SyslogServersResponse(rsp)
}

// GetApi217SyslogServersSettingsWithResponse request returning *GetApi217SyslogServersSettingsResponse
func (c *ClientWithResponses) GetApi217SyslogServersSettingsWithResponse(ctx context.Context, params *GetApi217SyslogServersSettingsParams, reqEditors ...RequestEditorFn) (*GetApi217SyslogServersSettingsResponse, error) {
	rsp, err := c.GetApi217SyslogServersSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SyslogServersSettingsResponse(rsp)
}

// PatchApi217SyslogServersSettingsWithBodyWithResponse request with arbitrary body returning *PatchApi217SyslogServersSettingsResponse
func (c *ClientWithResponses) PatchApi217SyslogServersSettingsWithBodyWithResponse(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersSettingsResponse, error) {
	rsp, err := c.PatchApi217SyslogServersSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SyslogServersSettingsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217SyslogServersSettingsWithResponse(ctx context.Context, params *PatchApi217SyslogServersSettingsParams, body PatchApi217SyslogServersSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217SyslogServersSettingsResponse, error) {
	rsp, err := c.PatchApi217SyslogServersSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217SyslogServersSettingsResponse(rsp)
}

// GetApi217SyslogServersTestWithResponse request returning *GetApi217SyslogServersTestResponse
func (c *ClientWithResponses) GetApi217SyslogServersTestWithResponse(ctx context.Context, params *GetApi217SyslogServersTestParams, reqEditors ...RequestEditorFn) (*GetApi217SyslogServersTestResponse, error) {
	rsp, err := c.GetApi217SyslogServersTest(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217SyslogServersTestResponse(rsp)
}

// DeleteApi217TargetsWithResponse request returning *DeleteApi217TargetsResponse
func (c *ClientWithResponses) DeleteApi217TargetsWithResponse(ctx context.Context, params *DeleteApi217TargetsParams, reqEditors ...RequestEditorFn) (*DeleteApi217TargetsResponse, error) {
	rsp, err := c.DeleteApi217Targets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217TargetsResponse(rsp)
}

// GetApi217TargetsWithResponse request returning *GetApi217TargetsResponse
func (c *ClientWithResponses) GetApi217TargetsWithResponse(ctx context.Context, params *GetApi217TargetsParams, reqEditors ...RequestEditorFn) (*GetApi217TargetsResponse, error) {
	rsp, err := c.GetApi217Targets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217TargetsResponse(rsp)
}

// PatchApi217TargetsWithBodyWithResponse request with arbitrary body returning *PatchApi217TargetsResponse
func (c *ClientWithResponses) PatchApi217TargetsWithBodyWithResponse(ctx context.Context, params *PatchApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217TargetsResponse, error) {
	rsp, err := c.PatchApi217TargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217TargetsResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217TargetsWithResponse(ctx context.Context, params *PatchApi217TargetsParams, body PatchApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217TargetsResponse, error) {
	rsp, err := c.PatchApi217Targets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217TargetsResponse(rsp)
}

// PostApi217TargetsWithBodyWithResponse request with arbitrary body returning *PostApi217TargetsResponse
func (c *ClientWithResponses) PostApi217TargetsWithBodyWithResponse(ctx context.Context, params *PostApi217TargetsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217TargetsResponse, error) {
	rsp, err := c.PostApi217TargetsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217TargetsResponse(rsp)
}

func (c *ClientWithResponses) PostApi217TargetsWithResponse(ctx context.Context, params *PostApi217TargetsParams, body PostApi217TargetsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217TargetsResponse, error) {
	rsp, err := c.PostApi217Targets(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217TargetsResponse(rsp)
}

// GetApi217TargetsPerformanceReplicationWithResponse request returning *GetApi217TargetsPerformanceReplicationResponse
func (c *ClientWithResponses) GetApi217TargetsPerformanceReplicationWithResponse(ctx context.Context, params *GetApi217TargetsPerformanceReplicationParams, reqEditors ...RequestEditorFn) (*GetApi217TargetsPerformanceReplicationResponse, error) {
	rsp, err := c.GetApi217TargetsPerformanceReplication(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217TargetsPerformanceReplicationResponse(rsp)
}

// DeleteApi217TlsPoliciesWithResponse request returning *DeleteApi217TlsPoliciesResponse
func (c *ClientWithResponses) DeleteApi217TlsPoliciesWithResponse(ctx context.Context, params *DeleteApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217TlsPoliciesResponse, error) {
	rsp, err := c.DeleteApi217TlsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217TlsPoliciesResponse(rsp)
}

// GetApi217TlsPoliciesWithResponse request returning *GetApi217TlsPoliciesResponse
func (c *ClientWithResponses) GetApi217TlsPoliciesWithResponse(ctx context.Context, params *GetApi217TlsPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217TlsPoliciesResponse, error) {
	rsp, err := c.GetApi217TlsPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217TlsPoliciesResponse(rsp)
}

// PatchApi217TlsPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217TlsPoliciesResponse
func (c *ClientWithResponses) PatchApi217TlsPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217TlsPoliciesResponse, error) {
	rsp, err := c.PatchApi217TlsPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217TlsPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217TlsPoliciesWithResponse(ctx context.Context, params *PatchApi217TlsPoliciesParams, body PatchApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217TlsPoliciesResponse, error) {
	rsp, err := c.PatchApi217TlsPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217TlsPoliciesResponse(rsp)
}

// PostApi217TlsPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217TlsPoliciesResponse
func (c *ClientWithResponses) PostApi217TlsPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217TlsPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217TlsPoliciesResponse, error) {
	rsp, err := c.PostApi217TlsPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217TlsPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217TlsPoliciesWithResponse(ctx context.Context, params *PostApi217TlsPoliciesParams, body PostApi217TlsPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217TlsPoliciesResponse, error) {
	rsp, err := c.PostApi217TlsPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217TlsPoliciesResponse(rsp)
}

// GetApi217TlsPoliciesMembersWithResponse request returning *GetApi217TlsPoliciesMembersResponse
func (c *ClientWithResponses) GetApi217TlsPoliciesMembersWithResponse(ctx context.Context, params *GetApi217TlsPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217TlsPoliciesMembersResponse, error) {
	rsp, err := c.GetApi217TlsPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217TlsPoliciesMembersResponse(rsp)
}

// DeleteApi217TlsPoliciesNetworkInterfacesWithResponse request returning *DeleteApi217TlsPoliciesNetworkInterfacesResponse
func (c *ClientWithResponses) DeleteApi217TlsPoliciesNetworkInterfacesWithResponse(ctx context.Context, params *DeleteApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*DeleteApi217TlsPoliciesNetworkInterfacesResponse, error) {
	rsp, err := c.DeleteApi217TlsPoliciesNetworkInterfaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217TlsPoliciesNetworkInterfacesResponse(rsp)
}

// GetApi217TlsPoliciesNetworkInterfacesWithResponse request returning *GetApi217TlsPoliciesNetworkInterfacesResponse
func (c *ClientWithResponses) GetApi217TlsPoliciesNetworkInterfacesWithResponse(ctx context.Context, params *GetApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*GetApi217TlsPoliciesNetworkInterfacesResponse, error) {
	rsp, err := c.GetApi217TlsPoliciesNetworkInterfaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217TlsPoliciesNetworkInterfacesResponse(rsp)
}

// PostApi217TlsPoliciesNetworkInterfacesWithResponse request returning *PostApi217TlsPoliciesNetworkInterfacesResponse
func (c *ClientWithResponses) PostApi217TlsPoliciesNetworkInterfacesWithResponse(ctx context.Context, params *PostApi217TlsPoliciesNetworkInterfacesParams, reqEditors ...RequestEditorFn) (*PostApi217TlsPoliciesNetworkInterfacesResponse, error) {
	rsp, err := c.PostApi217TlsPoliciesNetworkInterfaces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217TlsPoliciesNetworkInterfacesResponse(rsp)
}

// GetApi217UsageGroupsWithResponse request returning *GetApi217UsageGroupsResponse
func (c *ClientWithResponses) GetApi217UsageGroupsWithResponse(ctx context.Context, params *GetApi217UsageGroupsParams, reqEditors ...RequestEditorFn) (*GetApi217UsageGroupsResponse, error) {
	rsp, err := c.GetApi217UsageGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217UsageGroupsResponse(rsp)
}

// GetApi217UsageUsersWithResponse request returning *GetApi217UsageUsersResponse
func (c *ClientWithResponses) GetApi217UsageUsersWithResponse(ctx context.Context, params *GetApi217UsageUsersParams, reqEditors ...RequestEditorFn) (*GetApi217UsageUsersResponse, error) {
	rsp, err := c.GetApi217UsageUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217UsageUsersResponse(rsp)
}

// DeleteApi217WormDataPoliciesWithResponse request returning *DeleteApi217WormDataPoliciesResponse
func (c *ClientWithResponses) DeleteApi217WormDataPoliciesWithResponse(ctx context.Context, params *DeleteApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*DeleteApi217WormDataPoliciesResponse, error) {
	rsp, err := c.DeleteApi217WormDataPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApi217WormDataPoliciesResponse(rsp)
}

// GetApi217WormDataPoliciesWithResponse request returning *GetApi217WormDataPoliciesResponse
func (c *ClientWithResponses) GetApi217WormDataPoliciesWithResponse(ctx context.Context, params *GetApi217WormDataPoliciesParams, reqEditors ...RequestEditorFn) (*GetApi217WormDataPoliciesResponse, error) {
	rsp, err := c.GetApi217WormDataPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217WormDataPoliciesResponse(rsp)
}

// PatchApi217WormDataPoliciesWithBodyWithResponse request with arbitrary body returning *PatchApi217WormDataPoliciesResponse
func (c *ClientWithResponses) PatchApi217WormDataPoliciesWithBodyWithResponse(ctx context.Context, params *PatchApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApi217WormDataPoliciesResponse, error) {
	rsp, err := c.PatchApi217WormDataPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217WormDataPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PatchApi217WormDataPoliciesWithResponse(ctx context.Context, params *PatchApi217WormDataPoliciesParams, body PatchApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApi217WormDataPoliciesResponse, error) {
	rsp, err := c.PatchApi217WormDataPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApi217WormDataPoliciesResponse(rsp)
}

// PostApi217WormDataPoliciesWithBodyWithResponse request with arbitrary body returning *PostApi217WormDataPoliciesResponse
func (c *ClientWithResponses) PostApi217WormDataPoliciesWithBodyWithResponse(ctx context.Context, params *PostApi217WormDataPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostApi217WormDataPoliciesResponse, error) {
	rsp, err := c.PostApi217WormDataPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217WormDataPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostApi217WormDataPoliciesWithResponse(ctx context.Context, params *PostApi217WormDataPoliciesParams, body PostApi217WormDataPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostApi217WormDataPoliciesResponse, error) {
	rsp, err := c.PostApi217WormDataPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApi217WormDataPoliciesResponse(rsp)
}

// GetApi217WormDataPoliciesMembersWithResponse request returning *GetApi217WormDataPoliciesMembersResponse
func (c *ClientWithResponses) GetApi217WormDataPoliciesMembersWithResponse(ctx context.Context, params *GetApi217WormDataPoliciesMembersParams, reqEditors ...RequestEditorFn) (*GetApi217WormDataPoliciesMembersResponse, error) {
	rsp, err := c.GetApi217WormDataPoliciesMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApi217WormDataPoliciesMembersResponse(rsp)
}

// GetApiApiVersionWithResponse request returning *GetApiApiVersionResponse
func (c *ClientWithResponses) GetApiApiVersionWithResponse(ctx context.Context, params *GetApiApiVersionParams, reqEditors ...RequestEditorFn) (*GetApiApiVersionResponse, error) {
	rsp, err := c.GetApiApiVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiApiVersionResponse(rsp)
}

// PostApiLoginWithResponse request returning *PostApiLoginResponse
func (c *ClientWithResponses) PostApiLoginWithResponse(ctx context.Context, params *PostApiLoginParams, reqEditors ...RequestEditorFn) (*PostApiLoginResponse, error) {
	rsp, err := c.PostApiLogin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiLoginResponse(rsp)
}

// GetApiLoginBannerWithResponse request returning *GetApiLoginBannerResponse
func (c *ClientWithResponses) GetApiLoginBannerWithResponse(ctx context.Context, params *GetApiLoginBannerParams, reqEditors ...RequestEditorFn) (*GetApiLoginBannerResponse, error) {
	rsp, err := c.GetApiLoginBanner(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiLoginBannerResponse(rsp)
}

// PostApiLogoutWithResponse request returning *PostApiLogoutResponse
func (c *ClientWithResponses) PostApiLogoutWithResponse(ctx context.Context, params *PostApiLogoutParams, reqEditors ...RequestEditorFn) (*PostApiLogoutResponse, error) {
	rsp, err := c.PostApiLogout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostApiLogoutResponse(rsp)
}

// PostOauth210TokenWithBodyWithResponse request with arbitrary body returning *PostOauth210TokenResponse
func (c *ClientWithResponses) PostOauth210TokenWithBodyWithResponse(ctx context.Context, params *PostOauth210TokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth210TokenResponse, error) {
	rsp, err := c.PostOauth210TokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth210TokenResponse(rsp)
}

func (c *ClientWithResponses) PostOauth210TokenWithFormdataBodyWithResponse(ctx context.Context, params *PostOauth210TokenParams, body PostOauth210TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth210TokenResponse, error) {
	rsp, err := c.PostOauth210TokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth210TokenResponse(rsp)
}

// ParseDeleteApi217ActiveDirectoryResponse parses an HTTP response from a DeleteApi217ActiveDirectoryWithResponse call
func ParseDeleteApi217ActiveDirectoryResponse(rsp *http.Response) (*DeleteApi217ActiveDirectoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ActiveDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ActiveDirectoryResponse parses an HTTP response from a GetApi217ActiveDirectoryWithResponse call
func ParseGetApi217ActiveDirectoryResponse(rsp *http.Response) (*GetApi217ActiveDirectoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ActiveDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActiveDirectoryGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ActiveDirectoryResponse parses an HTTP response from a PatchApi217ActiveDirectoryWithResponse call
func ParsePatchApi217ActiveDirectoryResponse(rsp *http.Response) (*PatchApi217ActiveDirectoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ActiveDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActiveDirectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ActiveDirectoryResponse parses an HTTP response from a PostApi217ActiveDirectoryWithResponse call
func ParsePostApi217ActiveDirectoryResponse(rsp *http.Response) (*PostApi217ActiveDirectoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ActiveDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActiveDirectoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ActiveDirectoryTestResponse parses an HTTP response from a GetApi217ActiveDirectoryTestWithResponse call
func ParseGetApi217ActiveDirectoryTestResponse(rsp *http.Response) (*GetApi217ActiveDirectoryTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ActiveDirectoryTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217AdminsResponse parses an HTTP response from a DeleteApi217AdminsWithResponse call
func ParseDeleteApi217AdminsResponse(rsp *http.Response) (*DeleteApi217AdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217AdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217AdminsResponse parses an HTTP response from a GetApi217AdminsWithResponse call
func ParseGetApi217AdminsResponse(rsp *http.Response) (*GetApi217AdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217AdminsResponse parses an HTTP response from a PatchApi217AdminsWithResponse call
func ParsePatchApi217AdminsResponse(rsp *http.Response) (*PatchApi217AdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217AdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217AdminsResponse parses an HTTP response from a PostApi217AdminsWithResponse call
func ParsePostApi217AdminsResponse(rsp *http.Response) (*PostApi217AdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217AdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217AdminsApiTokensResponse parses an HTTP response from a DeleteApi217AdminsApiTokensWithResponse call
func ParseDeleteApi217AdminsApiTokensResponse(rsp *http.Response) (*DeleteApi217AdminsApiTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217AdminsApiTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217AdminsApiTokensResponse parses an HTTP response from a GetApi217AdminsApiTokensWithResponse call
func ParseGetApi217AdminsApiTokensResponse(rsp *http.Response) (*GetApi217AdminsApiTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AdminsApiTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminApiTokenGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217AdminsApiTokensResponse parses an HTTP response from a PostApi217AdminsApiTokensWithResponse call
func ParsePostApi217AdminsApiTokensResponse(rsp *http.Response) (*PostApi217AdminsApiTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217AdminsApiTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminApiTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217AdminsCacheResponse parses an HTTP response from a DeleteApi217AdminsCacheWithResponse call
func ParseDeleteApi217AdminsCacheResponse(rsp *http.Response) (*DeleteApi217AdminsCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217AdminsCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217AdminsCacheResponse parses an HTTP response from a GetApi217AdminsCacheWithResponse call
func ParseGetApi217AdminsCacheResponse(rsp *http.Response) (*GetApi217AdminsCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AdminsCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminCacheGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217AdminsSettingsResponse parses an HTTP response from a GetApi217AdminsSettingsWithResponse call
func ParseGetApi217AdminsSettingsResponse(rsp *http.Response) (*GetApi217AdminsSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AdminsSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSettingsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217AdminsSettingsResponse parses an HTTP response from a PatchApi217AdminsSettingsWithResponse call
func ParsePatchApi217AdminsSettingsResponse(rsp *http.Response) (*PatchApi217AdminsSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217AdminsSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdminSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217AdminsSshCertificateAuthorityPoliciesResponse parses an HTTP response from a DeleteApi217AdminsSshCertificateAuthorityPoliciesWithResponse call
func ParseDeleteApi217AdminsSshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217AdminsSshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217AdminsSshCertificateAuthorityPoliciesResponse parses an HTTP response from a GetApi217AdminsSshCertificateAuthorityPoliciesWithResponse call
func ParseGetApi217AdminsSshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*GetApi217AdminsSshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AdminsSshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217AdminsSshCertificateAuthorityPoliciesResponse parses an HTTP response from a PostApi217AdminsSshCertificateAuthorityPoliciesWithResponse call
func ParsePostApi217AdminsSshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*PostApi217AdminsSshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217AdminsSshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217AlertWatchersResponse parses an HTTP response from a DeleteApi217AlertWatchersWithResponse call
func ParseDeleteApi217AlertWatchersResponse(rsp *http.Response) (*DeleteApi217AlertWatchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217AlertWatchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217AlertWatchersResponse parses an HTTP response from a GetApi217AlertWatchersWithResponse call
func ParseGetApi217AlertWatchersResponse(rsp *http.Response) (*GetApi217AlertWatchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AlertWatchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlertWatcherGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217AlertWatchersResponse parses an HTTP response from a PatchApi217AlertWatchersWithResponse call
func ParsePatchApi217AlertWatchersResponse(rsp *http.Response) (*PatchApi217AlertWatchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217AlertWatchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlertWatcherResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217AlertWatchersResponse parses an HTTP response from a PostApi217AlertWatchersWithResponse call
func ParsePostApi217AlertWatchersResponse(rsp *http.Response) (*PostApi217AlertWatchersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217AlertWatchersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlertWatcherResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217AlertWatchersTestResponse parses an HTTP response from a GetApi217AlertWatchersTestWithResponse call
func ParseGetApi217AlertWatchersTestResponse(rsp *http.Response) (*GetApi217AlertWatchersTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AlertWatchersTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217AlertsResponse parses an HTTP response from a GetApi217AlertsWithResponse call
func ParseGetApi217AlertsResponse(rsp *http.Response) (*GetApi217AlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlertGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217AlertsResponse parses an HTTP response from a PatchApi217AlertsWithResponse call
func ParsePatchApi217AlertsResponse(rsp *http.Response) (*PatchApi217AlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217AlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ApiClientsResponse parses an HTTP response from a DeleteApi217ApiClientsWithResponse call
func ParseDeleteApi217ApiClientsResponse(rsp *http.Response) (*DeleteApi217ApiClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ApiClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ApiClientsResponse parses an HTTP response from a GetApi217ApiClientsWithResponse call
func ParseGetApi217ApiClientsResponse(rsp *http.Response) (*GetApi217ApiClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ApiClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClientsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ApiClientsResponse parses an HTTP response from a PatchApi217ApiClientsWithResponse call
func ParsePatchApi217ApiClientsResponse(rsp *http.Response) (*PatchApi217ApiClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ApiClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClientsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ApiClientsResponse parses an HTTP response from a PostApi217ApiClientsWithResponse call
func ParsePostApi217ApiClientsResponse(rsp *http.Response) (*PostApi217ApiClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ApiClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClientsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ArrayConnectionsResponse parses an HTTP response from a DeleteApi217ArrayConnectionsWithResponse call
func ParseDeleteApi217ArrayConnectionsResponse(rsp *http.Response) (*DeleteApi217ArrayConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ArrayConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ArrayConnectionsResponse parses an HTTP response from a GetApi217ArrayConnectionsWithResponse call
func ParseGetApi217ArrayConnectionsResponse(rsp *http.Response) (*GetApi217ArrayConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArrayConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayConnectionGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ArrayConnectionsResponse parses an HTTP response from a PatchApi217ArrayConnectionsWithResponse call
func ParsePatchApi217ArrayConnectionsResponse(rsp *http.Response) (*PatchApi217ArrayConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ArrayConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayConnectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ArrayConnectionsResponse parses an HTTP response from a PostApi217ArrayConnectionsWithResponse call
func ParsePostApi217ArrayConnectionsResponse(rsp *http.Response) (*PostApi217ArrayConnectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ArrayConnectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayConnectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArrayConnectionsConnectionKeyResponse parses an HTTP response from a GetApi217ArrayConnectionsConnectionKeyWithResponse call
func ParseGetApi217ArrayConnectionsConnectionKeyResponse(rsp *http.Response) (*GetApi217ArrayConnectionsConnectionKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArrayConnectionsConnectionKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayConnectionKeyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ArrayConnectionsConnectionKeyResponse parses an HTTP response from a PostApi217ArrayConnectionsConnectionKeyWithResponse call
func ParsePostApi217ArrayConnectionsConnectionKeyResponse(rsp *http.Response) (*PostApi217ArrayConnectionsConnectionKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ArrayConnectionsConnectionKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayConnectionKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArrayConnectionsPathResponse parses an HTTP response from a GetApi217ArrayConnectionsPathWithResponse call
func ParseGetApi217ArrayConnectionsPathResponse(rsp *http.Response) (*GetApi217ArrayConnectionsPathResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArrayConnectionsPathResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayConnectionPathGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArrayConnectionsPerformanceReplicationResponse parses an HTTP response from a GetApi217ArrayConnectionsPerformanceReplicationWithResponse call
func ParseGetApi217ArrayConnectionsPerformanceReplicationResponse(rsp *http.Response) (*GetApi217ArrayConnectionsPerformanceReplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArrayConnectionsPerformanceReplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectionRelationshipPerformanceReplicationGetResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysResponse parses an HTTP response from a GetApi217ArraysWithResponse call
func ParseGetApi217ArraysResponse(rsp *http.Response) (*GetApi217ArraysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ArraysResponse parses an HTTP response from a PatchApi217ArraysWithResponse call
func ParsePatchApi217ArraysResponse(rsp *http.Response) (*PatchApi217ArraysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ArraysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysClientsPerformanceResponse parses an HTTP response from a GetApi217ArraysClientsPerformanceWithResponse call
func ParseGetApi217ArraysClientsPerformanceResponse(rsp *http.Response) (*GetApi217ArraysClientsPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysClientsPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClientPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysEulaResponse parses an HTTP response from a GetApi217ArraysEulaWithResponse call
func ParseGetApi217ArraysEulaResponse(rsp *http.Response) (*GetApi217ArraysEulaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysEulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EulaGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ArraysEulaResponse parses an HTTP response from a PatchApi217ArraysEulaWithResponse call
func ParsePatchApi217ArraysEulaResponse(rsp *http.Response) (*PatchApi217ArraysEulaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ArraysEulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EulaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ArraysFactoryResetTokenResponse parses an HTTP response from a DeleteApi217ArraysFactoryResetTokenWithResponse call
func ParseDeleteApi217ArraysFactoryResetTokenResponse(rsp *http.Response) (*DeleteApi217ArraysFactoryResetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ArraysFactoryResetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ArraysFactoryResetTokenResponse parses an HTTP response from a GetApi217ArraysFactoryResetTokenWithResponse call
func ParseGetApi217ArraysFactoryResetTokenResponse(rsp *http.Response) (*GetApi217ArraysFactoryResetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysFactoryResetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayFactoryResetTokenGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ArraysFactoryResetTokenResponse parses an HTTP response from a PostApi217ArraysFactoryResetTokenWithResponse call
func ParsePostApi217ArraysFactoryResetTokenResponse(rsp *http.Response) (*PostApi217ArraysFactoryResetTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ArraysFactoryResetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayFactoryResetTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysHttpSpecificPerformanceResponse parses an HTTP response from a GetApi217ArraysHttpSpecificPerformanceWithResponse call
func ParseGetApi217ArraysHttpSpecificPerformanceResponse(rsp *http.Response) (*GetApi217ArraysHttpSpecificPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysHttpSpecificPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayHttpSpecificPerformanceGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysNfsSpecificPerformanceResponse parses an HTTP response from a GetApi217ArraysNfsSpecificPerformanceWithResponse call
func ParseGetApi217ArraysNfsSpecificPerformanceResponse(rsp *http.Response) (*GetApi217ArraysNfsSpecificPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysNfsSpecificPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayNfsSpecificPerformanceGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysPerformanceResponse parses an HTTP response from a GetApi217ArraysPerformanceWithResponse call
func ParseGetApi217ArraysPerformanceResponse(rsp *http.Response) (*GetApi217ArraysPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysPerformanceReplicationResponse parses an HTTP response from a GetApi217ArraysPerformanceReplicationWithResponse call
func ParseGetApi217ArraysPerformanceReplicationResponse(rsp *http.Response) (*GetApi217ArraysPerformanceReplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysPerformanceReplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayPerformanceReplicationGetResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysS3SpecificPerformanceResponse parses an HTTP response from a GetApi217ArraysS3SpecificPerformanceWithResponse call
func ParseGetApi217ArraysS3SpecificPerformanceResponse(rsp *http.Response) (*GetApi217ArraysS3SpecificPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysS3SpecificPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArrayS3SpecificPerformanceGetResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysSpaceResponse parses an HTTP response from a GetApi217ArraysSpaceWithResponse call
func ParseGetApi217ArraysSpaceResponse(rsp *http.Response) (*GetApi217ArraysSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArraySpaceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysSpaceStorageClassesResponse parses an HTTP response from a GetApi217ArraysSpaceStorageClassesWithResponse call
func ParseGetApi217ArraysSpaceStorageClassesResponse(rsp *http.Response) (*GetApi217ArraysSpaceStorageClassesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysSpaceStorageClassesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArraySpaceStorageClassGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ArraysSshCertificateAuthorityPoliciesResponse parses an HTTP response from a DeleteApi217ArraysSshCertificateAuthorityPoliciesWithResponse call
func ParseDeleteApi217ArraysSshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ArraysSshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ArraysSshCertificateAuthorityPoliciesResponse parses an HTTP response from a GetApi217ArraysSshCertificateAuthorityPoliciesWithResponse call
func ParseGetApi217ArraysSshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*GetApi217ArraysSshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysSshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ArraysSshCertificateAuthorityPoliciesResponse parses an HTTP response from a PostApi217ArraysSshCertificateAuthorityPoliciesWithResponse call
func ParsePostApi217ArraysSshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*PostApi217ArraysSshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ArraysSshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ArraysSupportedTimeZonesResponse parses an HTTP response from a GetApi217ArraysSupportedTimeZonesWithResponse call
func ParseGetApi217ArraysSupportedTimeZonesResponse(rsp *http.Response) (*GetApi217ArraysSupportedTimeZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ArraysSupportedTimeZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArraysSupportedTimeZonesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217AuditFileSystemsPoliciesResponse parses an HTTP response from a DeleteApi217AuditFileSystemsPoliciesWithResponse call
func ParseDeleteApi217AuditFileSystemsPoliciesResponse(rsp *http.Response) (*DeleteApi217AuditFileSystemsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217AuditFileSystemsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217AuditFileSystemsPoliciesResponse parses an HTTP response from a GetApi217AuditFileSystemsPoliciesWithResponse call
func ParseGetApi217AuditFileSystemsPoliciesResponse(rsp *http.Response) (*GetApi217AuditFileSystemsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AuditFileSystemsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditFileSystemsPoliciesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217AuditFileSystemsPoliciesResponse parses an HTTP response from a PatchApi217AuditFileSystemsPoliciesWithResponse call
func ParsePatchApi217AuditFileSystemsPoliciesResponse(rsp *http.Response) (*PatchApi217AuditFileSystemsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217AuditFileSystemsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditFileSystemsPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217AuditFileSystemsPoliciesResponse parses an HTTP response from a PostApi217AuditFileSystemsPoliciesWithResponse call
func ParsePostApi217AuditFileSystemsPoliciesResponse(rsp *http.Response) (*PostApi217AuditFileSystemsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217AuditFileSystemsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditFileSystemsPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217AuditFileSystemsPoliciesMembersResponse parses an HTTP response from a DeleteApi217AuditFileSystemsPoliciesMembersWithResponse call
func ParseDeleteApi217AuditFileSystemsPoliciesMembersResponse(rsp *http.Response) (*DeleteApi217AuditFileSystemsPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217AuditFileSystemsPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217AuditFileSystemsPoliciesMembersResponse parses an HTTP response from a GetApi217AuditFileSystemsPoliciesMembersWithResponse call
func ParseGetApi217AuditFileSystemsPoliciesMembersResponse(rsp *http.Response) (*GetApi217AuditFileSystemsPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AuditFileSystemsPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditFileSystemsPoliciesMembersGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217AuditFileSystemsPoliciesMembersResponse parses an HTTP response from a PostApi217AuditFileSystemsPoliciesMembersWithResponse call
func ParsePostApi217AuditFileSystemsPoliciesMembersResponse(rsp *http.Response) (*PostApi217AuditFileSystemsPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217AuditFileSystemsPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditFileSystemsPoliciesMembersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217AuditsResponse parses an HTTP response from a GetApi217AuditsWithResponse call
func ParseGetApi217AuditsResponse(rsp *http.Response) (*GetApi217AuditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217AuditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217BladesResponse parses an HTTP response from a GetApi217BladesWithResponse call
func ParseGetApi217BladesResponse(rsp *http.Response) (*GetApi217BladesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BladesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BladeGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217BucketReplicaLinksResponse parses an HTTP response from a DeleteApi217BucketReplicaLinksWithResponse call
func ParseDeleteApi217BucketReplicaLinksResponse(rsp *http.Response) (*DeleteApi217BucketReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217BucketReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217BucketReplicaLinksResponse parses an HTTP response from a GetApi217BucketReplicaLinksWithResponse call
func ParseGetApi217BucketReplicaLinksResponse(rsp *http.Response) (*GetApi217BucketReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketReplicaLinkGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217BucketReplicaLinksResponse parses an HTTP response from a PatchApi217BucketReplicaLinksWithResponse call
func ParsePatchApi217BucketReplicaLinksResponse(rsp *http.Response) (*PatchApi217BucketReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217BucketReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketReplicaLinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217BucketReplicaLinksResponse parses an HTTP response from a PostApi217BucketReplicaLinksWithResponse call
func ParsePostApi217BucketReplicaLinksResponse(rsp *http.Response) (*PostApi217BucketReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217BucketReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketReplicaLinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217BucketsResponse parses an HTTP response from a DeleteApi217BucketsWithResponse call
func ParseDeleteApi217BucketsResponse(rsp *http.Response) (*DeleteApi217BucketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217BucketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217BucketsResponse parses an HTTP response from a GetApi217BucketsWithResponse call
func ParseGetApi217BucketsResponse(rsp *http.Response) (*GetApi217BucketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217BucketsResponse parses an HTTP response from a PatchApi217BucketsWithResponse call
func ParsePatchApi217BucketsResponse(rsp *http.Response) (*PatchApi217BucketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217BucketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217BucketsResponse parses an HTTP response from a PostApi217BucketsWithResponse call
func ParsePostApi217BucketsResponse(rsp *http.Response) (*PostApi217BucketsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217BucketsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217BucketsBucketAccessPoliciesResponse parses an HTTP response from a DeleteApi217BucketsBucketAccessPoliciesWithResponse call
func ParseDeleteApi217BucketsBucketAccessPoliciesResponse(rsp *http.Response) (*DeleteApi217BucketsBucketAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217BucketsBucketAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217BucketsBucketAccessPoliciesResponse parses an HTTP response from a GetApi217BucketsBucketAccessPoliciesWithResponse call
func ParseGetApi217BucketsBucketAccessPoliciesResponse(rsp *http.Response) (*GetApi217BucketsBucketAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketsBucketAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketAccessPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217BucketsBucketAccessPoliciesResponse parses an HTTP response from a PostApi217BucketsBucketAccessPoliciesWithResponse call
func ParsePostApi217BucketsBucketAccessPoliciesResponse(rsp *http.Response) (*PostApi217BucketsBucketAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217BucketsBucketAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketAccessPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217BucketsBucketAccessPoliciesRulesResponse parses an HTTP response from a DeleteApi217BucketsBucketAccessPoliciesRulesWithResponse call
func ParseDeleteApi217BucketsBucketAccessPoliciesRulesResponse(rsp *http.Response) (*DeleteApi217BucketsBucketAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217BucketsBucketAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217BucketsBucketAccessPoliciesRulesResponse parses an HTTP response from a GetApi217BucketsBucketAccessPoliciesRulesWithResponse call
func ParseGetApi217BucketsBucketAccessPoliciesRulesResponse(rsp *http.Response) (*GetApi217BucketsBucketAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketsBucketAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketAccessPolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217BucketsBucketAccessPoliciesRulesResponse parses an HTTP response from a PostApi217BucketsBucketAccessPoliciesRulesWithResponse call
func ParsePostApi217BucketsBucketAccessPoliciesRulesResponse(rsp *http.Response) (*PostApi217BucketsBucketAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217BucketsBucketAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketAccessPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse parses an HTTP response from a DeleteApi217BucketsCrossOriginResourceSharingPoliciesWithResponse call
func ParseDeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse(rsp *http.Response) (*DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217BucketsCrossOriginResourceSharingPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217BucketsCrossOriginResourceSharingPoliciesResponse parses an HTTP response from a GetApi217BucketsCrossOriginResourceSharingPoliciesWithResponse call
func ParseGetApi217BucketsCrossOriginResourceSharingPoliciesResponse(rsp *http.Response) (*GetApi217BucketsCrossOriginResourceSharingPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketsCrossOriginResourceSharingPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrossOriginResourceSharingPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217BucketsCrossOriginResourceSharingPoliciesResponse parses an HTTP response from a PostApi217BucketsCrossOriginResourceSharingPoliciesWithResponse call
func ParsePostApi217BucketsCrossOriginResourceSharingPoliciesResponse(rsp *http.Response) (*PostApi217BucketsCrossOriginResourceSharingPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217BucketsCrossOriginResourceSharingPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrossOriginResourceSharingPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse parses an HTTP response from a DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse call
func ParseDeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse(rsp *http.Response) (*DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse parses an HTTP response from a GetApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse call
func ParseGetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse(rsp *http.Response) (*GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrossOriginResourceSharingPolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse parses an HTTP response from a PostApi217BucketsCrossOriginResourceSharingPoliciesRulesWithResponse call
func ParsePostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse(rsp *http.Response) (*PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217BucketsCrossOriginResourceSharingPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrossOriginResourceSharingPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217BucketsPerformanceResponse parses an HTTP response from a GetApi217BucketsPerformanceWithResponse call
func ParseGetApi217BucketsPerformanceResponse(rsp *http.Response) (*GetApi217BucketsPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketsPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217BucketsS3SpecificPerformanceResponse parses an HTTP response from a GetApi217BucketsS3SpecificPerformanceWithResponse call
func ParseGetApi217BucketsS3SpecificPerformanceResponse(rsp *http.Response) (*GetApi217BucketsS3SpecificPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217BucketsS3SpecificPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BucketS3SpecificPerformanceGetResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217CertificateGroupsResponse parses an HTTP response from a DeleteApi217CertificateGroupsWithResponse call
func ParseDeleteApi217CertificateGroupsResponse(rsp *http.Response) (*DeleteApi217CertificateGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217CertificateGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217CertificateGroupsResponse parses an HTTP response from a GetApi217CertificateGroupsWithResponse call
func ParseGetApi217CertificateGroupsResponse(rsp *http.Response) (*GetApi217CertificateGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217CertificateGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateGroupGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217CertificateGroupsResponse parses an HTTP response from a PostApi217CertificateGroupsWithResponse call
func ParsePostApi217CertificateGroupsResponse(rsp *http.Response) (*PostApi217CertificateGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217CertificateGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217CertificateGroupsCertificatesResponse parses an HTTP response from a DeleteApi217CertificateGroupsCertificatesWithResponse call
func ParseDeleteApi217CertificateGroupsCertificatesResponse(rsp *http.Response) (*DeleteApi217CertificateGroupsCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217CertificateGroupsCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217CertificateGroupsCertificatesResponse parses an HTTP response from a GetApi217CertificateGroupsCertificatesWithResponse call
func ParseGetApi217CertificateGroupsCertificatesResponse(rsp *http.Response) (*GetApi217CertificateGroupsCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217CertificateGroupsCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateGroupCertificateGetResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217CertificateGroupsCertificatesResponse parses an HTTP response from a PostApi217CertificateGroupsCertificatesWithResponse call
func ParsePostApi217CertificateGroupsCertificatesResponse(rsp *http.Response) (*PostApi217CertificateGroupsCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217CertificateGroupsCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateGroupCertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217CertificateGroupsUsesResponse parses an HTTP response from a GetApi217CertificateGroupsUsesWithResponse call
func ParseGetApi217CertificateGroupsUsesResponse(rsp *http.Response) (*GetApi217CertificateGroupsUsesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217CertificateGroupsUsesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateGroupUseGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217CertificatesResponse parses an HTTP response from a DeleteApi217CertificatesWithResponse call
func ParseDeleteApi217CertificatesResponse(rsp *http.Response) (*DeleteApi217CertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217CertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217CertificatesResponse parses an HTTP response from a GetApi217CertificatesWithResponse call
func ParseGetApi217CertificatesResponse(rsp *http.Response) (*GetApi217CertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217CertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217CertificatesResponse parses an HTTP response from a PatchApi217CertificatesWithResponse call
func ParsePatchApi217CertificatesResponse(rsp *http.Response) (*PatchApi217CertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217CertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217CertificatesResponse parses an HTTP response from a PostApi217CertificatesWithResponse call
func ParsePostApi217CertificatesResponse(rsp *http.Response) (*PostApi217CertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217CertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217CertificatesCertificateGroupsResponse parses an HTTP response from a DeleteApi217CertificatesCertificateGroupsWithResponse call
func ParseDeleteApi217CertificatesCertificateGroupsResponse(rsp *http.Response) (*DeleteApi217CertificatesCertificateGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217CertificatesCertificateGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217CertificatesCertificateGroupsResponse parses an HTTP response from a GetApi217CertificatesCertificateGroupsWithResponse call
func ParseGetApi217CertificatesCertificateGroupsResponse(rsp *http.Response) (*GetApi217CertificatesCertificateGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217CertificatesCertificateGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateCertificateGroupGetResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217CertificatesCertificateGroupsResponse parses an HTTP response from a PostApi217CertificatesCertificateGroupsWithResponse call
func ParsePostApi217CertificatesCertificateGroupsResponse(rsp *http.Response) (*PostApi217CertificatesCertificateGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217CertificatesCertificateGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateCertificateGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217CertificatesUsesResponse parses an HTTP response from a GetApi217CertificatesUsesWithResponse call
func ParseGetApi217CertificatesUsesResponse(rsp *http.Response) (*GetApi217CertificatesUsesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217CertificatesUsesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificateUseGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217DirectoryServicesResponse parses an HTTP response from a GetApi217DirectoryServicesWithResponse call
func ParseGetApi217DirectoryServicesResponse(rsp *http.Response) (*GetApi217DirectoryServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217DirectoryServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoryServiceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217DirectoryServicesResponse parses an HTTP response from a PatchApi217DirectoryServicesWithResponse call
func ParsePatchApi217DirectoryServicesResponse(rsp *http.Response) (*PatchApi217DirectoryServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217DirectoryServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoryServiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217DirectoryServicesRolesResponse parses an HTTP response from a DeleteApi217DirectoryServicesRolesWithResponse call
func ParseDeleteApi217DirectoryServicesRolesResponse(rsp *http.Response) (*DeleteApi217DirectoryServicesRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217DirectoryServicesRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217DirectoryServicesRolesResponse parses an HTTP response from a GetApi217DirectoryServicesRolesWithResponse call
func ParseGetApi217DirectoryServicesRolesResponse(rsp *http.Response) (*GetApi217DirectoryServicesRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217DirectoryServicesRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoryServiceRolesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217DirectoryServicesRolesResponse parses an HTTP response from a PatchApi217DirectoryServicesRolesWithResponse call
func ParsePatchApi217DirectoryServicesRolesResponse(rsp *http.Response) (*PatchApi217DirectoryServicesRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217DirectoryServicesRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoryServiceRolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217DirectoryServicesRolesResponse parses an HTTP response from a PostApi217DirectoryServicesRolesWithResponse call
func ParsePostApi217DirectoryServicesRolesResponse(rsp *http.Response) (*PostApi217DirectoryServicesRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217DirectoryServicesRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DirectoryServiceRolesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217DirectoryServicesTestResponse parses an HTTP response from a GetApi217DirectoryServicesTestWithResponse call
func ParseGetApi217DirectoryServicesTestResponse(rsp *http.Response) (*GetApi217DirectoryServicesTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217DirectoryServicesTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217DirectoryServicesTestResponse parses an HTTP response from a PatchApi217DirectoryServicesTestWithResponse call
func ParsePatchApi217DirectoryServicesTestResponse(rsp *http.Response) (*PatchApi217DirectoryServicesTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217DirectoryServicesTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217DnsResponse parses an HTTP response from a DeleteApi217DnsWithResponse call
func ParseDeleteApi217DnsResponse(rsp *http.Response) (*DeleteApi217DnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217DnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217DnsResponse parses an HTTP response from a GetApi217DnsWithResponse call
func ParseGetApi217DnsResponse(rsp *http.Response) (*GetApi217DnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217DnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217DnsResponse parses an HTTP response from a PatchApi217DnsWithResponse call
func ParsePatchApi217DnsResponse(rsp *http.Response) (*PatchApi217DnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217DnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217DnsResponse parses an HTTP response from a PostApi217DnsWithResponse call
func ParsePostApi217DnsResponse(rsp *http.Response) (*PostApi217DnsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217DnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217DrivesResponse parses an HTTP response from a GetApi217DrivesWithResponse call
func ParseGetApi217DrivesResponse(rsp *http.Response) (*GetApi217DrivesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217DrivesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DriveGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemExportsResponse parses an HTTP response from a DeleteApi217FileSystemExportsWithResponse call
func ParseDeleteApi217FileSystemExportsResponse(rsp *http.Response) (*DeleteApi217FileSystemExportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemExportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemExportsResponse parses an HTTP response from a GetApi217FileSystemExportsWithResponse call
func ParseGetApi217FileSystemExportsResponse(rsp *http.Response) (*GetApi217FileSystemExportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemExportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemExportGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217FileSystemExportsResponse parses an HTTP response from a PatchApi217FileSystemExportsWithResponse call
func ParsePatchApi217FileSystemExportsResponse(rsp *http.Response) (*PatchApi217FileSystemExportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217FileSystemExportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemExportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemExportsResponse parses an HTTP response from a PostApi217FileSystemExportsWithResponse call
func ParsePostApi217FileSystemExportsResponse(rsp *http.Response) (*PostApi217FileSystemExportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemExportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemExportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemReplicaLinksResponse parses an HTTP response from a DeleteApi217FileSystemReplicaLinksWithResponse call
func ParseDeleteApi217FileSystemReplicaLinksResponse(rsp *http.Response) (*DeleteApi217FileSystemReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemReplicaLinksResponse parses an HTTP response from a GetApi217FileSystemReplicaLinksWithResponse call
func ParseGetApi217FileSystemReplicaLinksResponse(rsp *http.Response) (*GetApi217FileSystemReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemReplicaLinkGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217FileSystemReplicaLinksResponse parses an HTTP response from a PatchApi217FileSystemReplicaLinksWithResponse call
func ParsePatchApi217FileSystemReplicaLinksResponse(rsp *http.Response) (*PatchApi217FileSystemReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217FileSystemReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemReplicaLinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemReplicaLinksResponse parses an HTTP response from a PostApi217FileSystemReplicaLinksWithResponse call
func ParsePostApi217FileSystemReplicaLinksResponse(rsp *http.Response) (*PostApi217FileSystemReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemReplicaLinkResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemReplicaLinksPoliciesResponse parses an HTTP response from a DeleteApi217FileSystemReplicaLinksPoliciesWithResponse call
func ParseDeleteApi217FileSystemReplicaLinksPoliciesResponse(rsp *http.Response) (*DeleteApi217FileSystemReplicaLinksPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemReplicaLinksPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemReplicaLinksPoliciesResponse parses an HTTP response from a GetApi217FileSystemReplicaLinksPoliciesWithResponse call
func ParseGetApi217FileSystemReplicaLinksPoliciesResponse(rsp *http.Response) (*GetApi217FileSystemReplicaLinksPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemReplicaLinksPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberWithRemoteGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemReplicaLinksPoliciesResponse parses an HTTP response from a PostApi217FileSystemReplicaLinksPoliciesWithResponse call
func ParsePostApi217FileSystemReplicaLinksPoliciesResponse(rsp *http.Response) (*PostApi217FileSystemReplicaLinksPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemReplicaLinksPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberWithRemoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FileSystemReplicaLinksTransferResponse parses an HTTP response from a GetApi217FileSystemReplicaLinksTransferWithResponse call
func ParseGetApi217FileSystemReplicaLinksTransferResponse(rsp *http.Response) (*GetApi217FileSystemReplicaLinksTransferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemReplicaLinksTransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemSnapshotGetTransferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemSnapshotsResponse parses an HTTP response from a DeleteApi217FileSystemSnapshotsWithResponse call
func ParseDeleteApi217FileSystemSnapshotsResponse(rsp *http.Response) (*DeleteApi217FileSystemSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemSnapshotsResponse parses an HTTP response from a GetApi217FileSystemSnapshotsWithResponse call
func ParseGetApi217FileSystemSnapshotsResponse(rsp *http.Response) (*GetApi217FileSystemSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemSnapshotGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217FileSystemSnapshotsResponse parses an HTTP response from a PatchApi217FileSystemSnapshotsWithResponse call
func ParsePatchApi217FileSystemSnapshotsResponse(rsp *http.Response) (*PatchApi217FileSystemSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217FileSystemSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemSnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemSnapshotsResponse parses an HTTP response from a PostApi217FileSystemSnapshotsWithResponse call
func ParsePostApi217FileSystemSnapshotsResponse(rsp *http.Response) (*PostApi217FileSystemSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemSnapshotResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemSnapshotsPoliciesResponse parses an HTTP response from a DeleteApi217FileSystemSnapshotsPoliciesWithResponse call
func ParseDeleteApi217FileSystemSnapshotsPoliciesResponse(rsp *http.Response) (*DeleteApi217FileSystemSnapshotsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemSnapshotsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemSnapshotsPoliciesResponse parses an HTTP response from a GetApi217FileSystemSnapshotsPoliciesWithResponse call
func ParseGetApi217FileSystemSnapshotsPoliciesResponse(rsp *http.Response) (*GetApi217FileSystemSnapshotsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemSnapshotsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyFileSystemSnapshotGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemSnapshotsTransferResponse parses an HTTP response from a DeleteApi217FileSystemSnapshotsTransferWithResponse call
func ParseDeleteApi217FileSystemSnapshotsTransferResponse(rsp *http.Response) (*DeleteApi217FileSystemSnapshotsTransferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemSnapshotsTransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemSnapshotsTransferResponse parses an HTTP response from a GetApi217FileSystemSnapshotsTransferWithResponse call
func ParseGetApi217FileSystemSnapshotsTransferResponse(rsp *http.Response) (*GetApi217FileSystemSnapshotsTransferResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemSnapshotsTransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemSnapshotGetTransferResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemsResponse parses an HTTP response from a DeleteApi217FileSystemsWithResponse call
func ParseDeleteApi217FileSystemsResponse(rsp *http.Response) (*DeleteApi217FileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemsResponse parses an HTTP response from a GetApi217FileSystemsWithResponse call
func ParseGetApi217FileSystemsResponse(rsp *http.Response) (*GetApi217FileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217FileSystemsResponse parses an HTTP response from a PatchApi217FileSystemsWithResponse call
func ParsePatchApi217FileSystemsResponse(rsp *http.Response) (*PatchApi217FileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217FileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemsResponse parses an HTTP response from a PostApi217FileSystemsWithResponse call
func ParsePostApi217FileSystemsResponse(rsp *http.Response) (*PostApi217FileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemsAuditPoliciesResponse parses an HTTP response from a DeleteApi217FileSystemsAuditPoliciesWithResponse call
func ParseDeleteApi217FileSystemsAuditPoliciesResponse(rsp *http.Response) (*DeleteApi217FileSystemsAuditPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemsAuditPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemsAuditPoliciesResponse parses an HTTP response from a GetApi217FileSystemsAuditPoliciesWithResponse call
func ParseGetApi217FileSystemsAuditPoliciesResponse(rsp *http.Response) (*GetApi217FileSystemsAuditPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsAuditPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditFileSystemsPoliciesMembersGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemsAuditPoliciesResponse parses an HTTP response from a PostApi217FileSystemsAuditPoliciesWithResponse call
func ParsePostApi217FileSystemsAuditPoliciesResponse(rsp *http.Response) (*PostApi217FileSystemsAuditPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemsAuditPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditFileSystemsPoliciesMembersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FileSystemsGroupsPerformanceResponse parses an HTTP response from a GetApi217FileSystemsGroupsPerformanceWithResponse call
func ParseGetApi217FileSystemsGroupsPerformanceResponse(rsp *http.Response) (*GetApi217FileSystemsGroupsPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsGroupsPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemGroupsPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemsLocksResponse parses an HTTP response from a DeleteApi217FileSystemsLocksWithResponse call
func ParseDeleteApi217FileSystemsLocksResponse(rsp *http.Response) (*DeleteApi217FileSystemsLocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemsLocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemsLocksResponse parses an HTTP response from a GetApi217FileSystemsLocksWithResponse call
func ParseGetApi217FileSystemsLocksResponse(rsp *http.Response) (*GetApi217FileSystemsLocksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsLocksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileLockGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FileSystemsLocksClientsResponse parses an HTTP response from a GetApi217FileSystemsLocksClientsWithResponse call
func ParseGetApi217FileSystemsLocksClientsResponse(rsp *http.Response) (*GetApi217FileSystemsLocksClientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsLocksClientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemClientsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemsLocksNlmReclamationsResponse parses an HTTP response from a PostApi217FileSystemsLocksNlmReclamationsWithResponse call
func ParsePostApi217FileSystemsLocksNlmReclamationsResponse(rsp *http.Response) (*PostApi217FileSystemsLocksNlmReclamationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemsLocksNlmReclamationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileLockNlmReclamationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemsOpenFilesResponse parses an HTTP response from a DeleteApi217FileSystemsOpenFilesWithResponse call
func ParseDeleteApi217FileSystemsOpenFilesResponse(rsp *http.Response) (*DeleteApi217FileSystemsOpenFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemsOpenFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemsOpenFilesResponse parses an HTTP response from a GetApi217FileSystemsOpenFilesWithResponse call
func ParseGetApi217FileSystemsOpenFilesResponse(rsp *http.Response) (*GetApi217FileSystemsOpenFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsOpenFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemOpenFilesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FileSystemsPerformanceResponse parses an HTTP response from a GetApi217FileSystemsPerformanceWithResponse call
func ParseGetApi217FileSystemsPerformanceResponse(rsp *http.Response) (*GetApi217FileSystemsPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemsPoliciesResponse parses an HTTP response from a DeleteApi217FileSystemsPoliciesWithResponse call
func ParseDeleteApi217FileSystemsPoliciesResponse(rsp *http.Response) (*DeleteApi217FileSystemsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemsPoliciesResponse parses an HTTP response from a GetApi217FileSystemsPoliciesWithResponse call
func ParseGetApi217FileSystemsPoliciesResponse(rsp *http.Response) (*GetApi217FileSystemsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FileSystemsPoliciesResponse parses an HTTP response from a PostApi217FileSystemsPoliciesWithResponse call
func ParsePostApi217FileSystemsPoliciesResponse(rsp *http.Response) (*PostApi217FileSystemsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FileSystemsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FileSystemsPoliciesAllResponse parses an HTTP response from a GetApi217FileSystemsPoliciesAllWithResponse call
func ParseGetApi217FileSystemsPoliciesAllResponse(rsp *http.Response) (*GetApi217FileSystemsPoliciesAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsPoliciesAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FileSystemsSessionsResponse parses an HTTP response from a DeleteApi217FileSystemsSessionsWithResponse call
func ParseDeleteApi217FileSystemsSessionsResponse(rsp *http.Response) (*DeleteApi217FileSystemsSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FileSystemsSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FileSystemsSessionsResponse parses an HTTP response from a GetApi217FileSystemsSessionsWithResponse call
func ParseGetApi217FileSystemsSessionsResponse(rsp *http.Response) (*GetApi217FileSystemsSessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsSessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSessionGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FileSystemsUsersPerformanceResponse parses an HTTP response from a GetApi217FileSystemsUsersPerformanceWithResponse call
func ParseGetApi217FileSystemsUsersPerformanceResponse(rsp *http.Response) (*GetApi217FileSystemsUsersPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsUsersPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileSystemUsersPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FileSystemsWormDataPoliciesResponse parses an HTTP response from a GetApi217FileSystemsWormDataPoliciesWithResponse call
func ParseGetApi217FileSystemsWormDataPoliciesResponse(rsp *http.Response) (*GetApi217FileSystemsWormDataPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FileSystemsWormDataPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WormDataPoliciesMembersGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FleetsResponse parses an HTTP response from a DeleteApi217FleetsWithResponse call
func ParseDeleteApi217FleetsResponse(rsp *http.Response) (*DeleteApi217FleetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FleetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FleetsResponse parses an HTTP response from a GetApi217FleetsWithResponse call
func ParseGetApi217FleetsResponse(rsp *http.Response) (*GetApi217FleetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FleetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FleetGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217FleetsResponse parses an HTTP response from a PatchApi217FleetsWithResponse call
func ParsePatchApi217FleetsResponse(rsp *http.Response) (*PatchApi217FleetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217FleetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FleetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FleetsResponse parses an HTTP response from a PostApi217FleetsWithResponse call
func ParsePostApi217FleetsResponse(rsp *http.Response) (*PostApi217FleetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FleetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FleetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217FleetsFleetKeyResponse parses an HTTP response from a GetApi217FleetsFleetKeyWithResponse call
func ParseGetApi217FleetsFleetKeyResponse(rsp *http.Response) (*GetApi217FleetsFleetKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FleetsFleetKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FleetKeyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FleetsFleetKeyResponse parses an HTTP response from a PostApi217FleetsFleetKeyWithResponse call
func ParsePostApi217FleetsFleetKeyResponse(rsp *http.Response) (*PostApi217FleetsFleetKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FleetsFleetKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FleetKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217FleetsMembersResponse parses an HTTP response from a DeleteApi217FleetsMembersWithResponse call
func ParseDeleteApi217FleetsMembersResponse(rsp *http.Response) (*DeleteApi217FleetsMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217FleetsMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217FleetsMembersResponse parses an HTTP response from a GetApi217FleetsMembersWithResponse call
func ParseGetApi217FleetsMembersResponse(rsp *http.Response) (*GetApi217FleetsMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217FleetsMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FleetMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217FleetsMembersResponse parses an HTTP response from a PostApi217FleetsMembersWithResponse call
func ParsePostApi217FleetsMembersResponse(rsp *http.Response) (*PostApi217FleetsMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217FleetsMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FleetMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217HardwareResponse parses an HTTP response from a GetApi217HardwareWithResponse call
func ParseGetApi217HardwareResponse(rsp *http.Response) (*GetApi217HardwareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217HardwareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HardwareGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217HardwareResponse parses an HTTP response from a PatchApi217HardwareWithResponse call
func ParsePatchApi217HardwareResponse(rsp *http.Response) (*PatchApi217HardwareResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217HardwareResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HardwareResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217HardwareConnectorsResponse parses an HTTP response from a GetApi217HardwareConnectorsWithResponse call
func ParseGetApi217HardwareConnectorsResponse(rsp *http.Response) (*GetApi217HardwareConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217HardwareConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HardwareConnectorGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217HardwareConnectorsResponse parses an HTTP response from a PatchApi217HardwareConnectorsWithResponse call
func ParsePatchApi217HardwareConnectorsResponse(rsp *http.Response) (*PatchApi217HardwareConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217HardwareConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HardwareConnectorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217HardwareConnectorsPerformanceResponse parses an HTTP response from a GetApi217HardwareConnectorsPerformanceWithResponse call
func ParseGetApi217HardwareConnectorsPerformanceResponse(rsp *http.Response) (*GetApi217HardwareConnectorsPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217HardwareConnectorsPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HardwareConnectorPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217KeytabsResponse parses an HTTP response from a DeleteApi217KeytabsWithResponse call
func ParseDeleteApi217KeytabsResponse(rsp *http.Response) (*DeleteApi217KeytabsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217KeytabsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217KeytabsResponse parses an HTTP response from a GetApi217KeytabsWithResponse call
func ParseGetApi217KeytabsResponse(rsp *http.Response) (*GetApi217KeytabsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217KeytabsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeytabGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217KeytabsResponse parses an HTTP response from a PostApi217KeytabsWithResponse call
func ParsePostApi217KeytabsResponse(rsp *http.Response) (*PostApi217KeytabsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217KeytabsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeytabResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217KeytabsDownloadResponse parses an HTTP response from a GetApi217KeytabsDownloadWithResponse call
func ParseGetApi217KeytabsDownloadResponse(rsp *http.Response) (*GetApi217KeytabsDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217KeytabsDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostApi217KeytabsUploadResponse parses an HTTP response from a PostApi217KeytabsUploadWithResponse call
func ParsePostApi217KeytabsUploadResponse(rsp *http.Response) (*PostApi217KeytabsUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217KeytabsUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteApi217KmipResponse parses an HTTP response from a DeleteApi217KmipWithResponse call
func ParseDeleteApi217KmipResponse(rsp *http.Response) (*DeleteApi217KmipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217KmipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217KmipResponse parses an HTTP response from a GetApi217KmipWithResponse call
func ParseGetApi217KmipResponse(rsp *http.Response) (*GetApi217KmipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217KmipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KmipServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217KmipResponse parses an HTTP response from a PatchApi217KmipWithResponse call
func ParsePatchApi217KmipResponse(rsp *http.Response) (*PatchApi217KmipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217KmipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KmipServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217KmipResponse parses an HTTP response from a PostApi217KmipWithResponse call
func ParsePostApi217KmipResponse(rsp *http.Response) (*PostApi217KmipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217KmipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KmipServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217KmipTestResponse parses an HTTP response from a GetApi217KmipTestWithResponse call
func ParseGetApi217KmipTestResponse(rsp *http.Response) (*GetApi217KmipTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217KmipTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217LegalHoldsResponse parses an HTTP response from a DeleteApi217LegalHoldsWithResponse call
func ParseDeleteApi217LegalHoldsResponse(rsp *http.Response) (*DeleteApi217LegalHoldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217LegalHoldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217LegalHoldsResponse parses an HTTP response from a GetApi217LegalHoldsWithResponse call
func ParseGetApi217LegalHoldsResponse(rsp *http.Response) (*GetApi217LegalHoldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217LegalHoldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalHoldsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217LegalHoldsResponse parses an HTTP response from a PatchApi217LegalHoldsWithResponse call
func ParsePatchApi217LegalHoldsResponse(rsp *http.Response) (*PatchApi217LegalHoldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217LegalHoldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalHoldsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217LegalHoldsResponse parses an HTTP response from a PostApi217LegalHoldsWithResponse call
func ParsePostApi217LegalHoldsResponse(rsp *http.Response) (*PostApi217LegalHoldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217LegalHoldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalHoldsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217LegalHoldsHeldEntitiesResponse parses an HTTP response from a GetApi217LegalHoldsHeldEntitiesWithResponse call
func ParseGetApi217LegalHoldsHeldEntitiesResponse(rsp *http.Response) (*GetApi217LegalHoldsHeldEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217LegalHoldsHeldEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalHoldsHeldEntitiesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217LegalHoldsHeldEntitiesResponse parses an HTTP response from a PatchApi217LegalHoldsHeldEntitiesWithResponse call
func ParsePatchApi217LegalHoldsHeldEntitiesResponse(rsp *http.Response) (*PatchApi217LegalHoldsHeldEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217LegalHoldsHeldEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalHoldsHeldEntitiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217LegalHoldsHeldEntitiesResponse parses an HTTP response from a PostApi217LegalHoldsHeldEntitiesWithResponse call
func ParsePostApi217LegalHoldsHeldEntitiesResponse(rsp *http.Response) (*PostApi217LegalHoldsHeldEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217LegalHoldsHeldEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegalHoldsHeldEntitiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217LifecycleRulesResponse parses an HTTP response from a DeleteApi217LifecycleRulesWithResponse call
func ParseDeleteApi217LifecycleRulesResponse(rsp *http.Response) (*DeleteApi217LifecycleRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217LifecycleRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217LifecycleRulesResponse parses an HTTP response from a GetApi217LifecycleRulesWithResponse call
func ParseGetApi217LifecycleRulesResponse(rsp *http.Response) (*GetApi217LifecycleRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217LifecycleRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LifecycleRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217LifecycleRulesResponse parses an HTTP response from a PatchApi217LifecycleRulesWithResponse call
func ParsePatchApi217LifecycleRulesResponse(rsp *http.Response) (*PatchApi217LifecycleRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217LifecycleRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LifecycleRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217LifecycleRulesResponse parses an HTTP response from a PostApi217LifecycleRulesWithResponse call
func ParsePostApi217LifecycleRulesResponse(rsp *http.Response) (*PostApi217LifecycleRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217LifecycleRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LifecycleRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217LinkAggregationGroupsResponse parses an HTTP response from a DeleteApi217LinkAggregationGroupsWithResponse call
func ParseDeleteApi217LinkAggregationGroupsResponse(rsp *http.Response) (*DeleteApi217LinkAggregationGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217LinkAggregationGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217LinkAggregationGroupsResponse parses an HTTP response from a GetApi217LinkAggregationGroupsWithResponse call
func ParseGetApi217LinkAggregationGroupsResponse(rsp *http.Response) (*GetApi217LinkAggregationGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217LinkAggregationGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkAggregationGroupGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217LinkAggregationGroupsResponse parses an HTTP response from a PatchApi217LinkAggregationGroupsWithResponse call
func ParsePatchApi217LinkAggregationGroupsResponse(rsp *http.Response) (*PatchApi217LinkAggregationGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217LinkAggregationGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkAggregationGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217LinkAggregationGroupsResponse parses an HTTP response from a PostApi217LinkAggregationGroupsWithResponse call
func ParsePostApi217LinkAggregationGroupsResponse(rsp *http.Response) (*PostApi217LinkAggregationGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217LinkAggregationGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LinkAggregationGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217LogsResponse parses an HTTP response from a GetApi217LogsWithResponse call
func ParseGetApi217LogsResponse(rsp *http.Response) (*GetApi217LogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217LogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseGetApi217LogsAsyncResponse parses an HTTP response from a GetApi217LogsAsyncWithResponse call
func ParseGetApi217LogsAsyncResponse(rsp *http.Response) (*GetApi217LogsAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217LogsAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogsAsyncGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217LogsAsyncResponse parses an HTTP response from a PatchApi217LogsAsyncWithResponse call
func ParsePatchApi217LogsAsyncResponse(rsp *http.Response) (*PatchApi217LogsAsyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217LogsAsyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogsAsyncResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217LogsAsyncDownloadResponse parses an HTTP response from a GetApi217LogsAsyncDownloadWithResponse call
func ParseGetApi217LogsAsyncDownloadResponse(rsp *http.Response) (*GetApi217LogsAsyncDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217LogsAsyncDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/plain) unsupported

	}

	return response, nil
}

// ParseDeleteApi217MaintenanceWindowsResponse parses an HTTP response from a DeleteApi217MaintenanceWindowsWithResponse call
func ParseDeleteApi217MaintenanceWindowsResponse(rsp *http.Response) (*DeleteApi217MaintenanceWindowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217MaintenanceWindowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217MaintenanceWindowsResponse parses an HTTP response from a GetApi217MaintenanceWindowsWithResponse call
func ParseGetApi217MaintenanceWindowsResponse(rsp *http.Response) (*GetApi217MaintenanceWindowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217MaintenanceWindowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaintenanceWindowsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217MaintenanceWindowsResponse parses an HTTP response from a PostApi217MaintenanceWindowsWithResponse call
func ParsePostApi217MaintenanceWindowsResponse(rsp *http.Response) (*PostApi217MaintenanceWindowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217MaintenanceWindowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MaintenanceWindowsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217NetworkAccessPoliciesResponse parses an HTTP response from a GetApi217NetworkAccessPoliciesWithResponse call
func ParseGetApi217NetworkAccessPoliciesResponse(rsp *http.Response) (*GetApi217NetworkAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkAccessPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217NetworkAccessPoliciesResponse parses an HTTP response from a PatchApi217NetworkAccessPoliciesWithResponse call
func ParsePatchApi217NetworkAccessPoliciesResponse(rsp *http.Response) (*PatchApi217NetworkAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217NetworkAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkAccessPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217NetworkAccessPoliciesMembersResponse parses an HTTP response from a GetApi217NetworkAccessPoliciesMembersWithResponse call
func ParseGetApi217NetworkAccessPoliciesMembersResponse(rsp *http.Response) (*GetApi217NetworkAccessPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkAccessPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217NetworkAccessPoliciesRulesResponse parses an HTTP response from a DeleteApi217NetworkAccessPoliciesRulesWithResponse call
func ParseDeleteApi217NetworkAccessPoliciesRulesResponse(rsp *http.Response) (*DeleteApi217NetworkAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217NetworkAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217NetworkAccessPoliciesRulesResponse parses an HTTP response from a GetApi217NetworkAccessPoliciesRulesWithResponse call
func ParseGetApi217NetworkAccessPoliciesRulesResponse(rsp *http.Response) (*GetApi217NetworkAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkAccessPolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217NetworkAccessPoliciesRulesResponse parses an HTTP response from a PatchApi217NetworkAccessPoliciesRulesWithResponse call
func ParsePatchApi217NetworkAccessPoliciesRulesResponse(rsp *http.Response) (*PatchApi217NetworkAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217NetworkAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkAccessPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217NetworkAccessPoliciesRulesResponse parses an HTTP response from a PostApi217NetworkAccessPoliciesRulesWithResponse call
func ParsePostApi217NetworkAccessPoliciesRulesResponse(rsp *http.Response) (*PostApi217NetworkAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217NetworkAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkAccessPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217NetworkInterfacesResponse parses an HTTP response from a DeleteApi217NetworkInterfacesWithResponse call
func ParseDeleteApi217NetworkInterfacesResponse(rsp *http.Response) (*DeleteApi217NetworkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217NetworkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217NetworkInterfacesResponse parses an HTTP response from a GetApi217NetworkInterfacesWithResponse call
func ParseGetApi217NetworkInterfacesResponse(rsp *http.Response) (*GetApi217NetworkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfaceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217NetworkInterfacesResponse parses an HTTP response from a PatchApi217NetworkInterfacesWithResponse call
func ParsePatchApi217NetworkInterfacesResponse(rsp *http.Response) (*PatchApi217NetworkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217NetworkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217NetworkInterfacesResponse parses an HTTP response from a PostApi217NetworkInterfacesWithResponse call
func ParsePostApi217NetworkInterfacesResponse(rsp *http.Response) (*PostApi217NetworkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217NetworkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217NetworkInterfacesConnectorsResponse parses an HTTP response from a GetApi217NetworkInterfacesConnectorsWithResponse call
func ParseGetApi217NetworkInterfacesConnectorsResponse(rsp *http.Response) (*GetApi217NetworkInterfacesConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkInterfacesConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfacesConnectorsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217NetworkInterfacesConnectorsResponse parses an HTTP response from a PatchApi217NetworkInterfacesConnectorsWithResponse call
func ParsePatchApi217NetworkInterfacesConnectorsResponse(rsp *http.Response) (*PatchApi217NetworkInterfacesConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217NetworkInterfacesConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfacesConnectorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217NetworkInterfacesConnectorsPerformanceResponse parses an HTTP response from a GetApi217NetworkInterfacesConnectorsPerformanceWithResponse call
func ParseGetApi217NetworkInterfacesConnectorsPerformanceResponse(rsp *http.Response) (*GetApi217NetworkInterfacesConnectorsPerformanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkInterfacesConnectorsPerformanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfacesConnectorsPerformanceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217NetworkInterfacesConnectorsSettingsResponse parses an HTTP response from a GetApi217NetworkInterfacesConnectorsSettingsWithResponse call
func ParseGetApi217NetworkInterfacesConnectorsSettingsResponse(rsp *http.Response) (*GetApi217NetworkInterfacesConnectorsSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkInterfacesConnectorsSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfacesConnectorsSettingsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217NetworkInterfacesPingResponse parses an HTTP response from a GetApi217NetworkInterfacesPingWithResponse call
func ParseGetApi217NetworkInterfacesPingResponse(rsp *http.Response) (*GetApi217NetworkInterfacesPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkInterfacesPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfacePingGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217NetworkInterfacesTlsPoliciesResponse parses an HTTP response from a DeleteApi217NetworkInterfacesTlsPoliciesWithResponse call
func ParseDeleteApi217NetworkInterfacesTlsPoliciesResponse(rsp *http.Response) (*DeleteApi217NetworkInterfacesTlsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217NetworkInterfacesTlsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217NetworkInterfacesTlsPoliciesResponse parses an HTTP response from a GetApi217NetworkInterfacesTlsPoliciesWithResponse call
func ParseGetApi217NetworkInterfacesTlsPoliciesResponse(rsp *http.Response) (*GetApi217NetworkInterfacesTlsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkInterfacesTlsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217NetworkInterfacesTlsPoliciesResponse parses an HTTP response from a PostApi217NetworkInterfacesTlsPoliciesWithResponse call
func ParsePostApi217NetworkInterfacesTlsPoliciesResponse(rsp *http.Response) (*PostApi217NetworkInterfacesTlsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217NetworkInterfacesTlsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217NetworkInterfacesTraceResponse parses an HTTP response from a GetApi217NetworkInterfacesTraceWithResponse call
func ParseGetApi217NetworkInterfacesTraceResponse(rsp *http.Response) (*GetApi217NetworkInterfacesTraceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NetworkInterfacesTraceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkInterfaceTraceGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217NfsExportPoliciesResponse parses an HTTP response from a DeleteApi217NfsExportPoliciesWithResponse call
func ParseDeleteApi217NfsExportPoliciesResponse(rsp *http.Response) (*DeleteApi217NfsExportPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217NfsExportPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217NfsExportPoliciesResponse parses an HTTP response from a GetApi217NfsExportPoliciesWithResponse call
func ParseGetApi217NfsExportPoliciesResponse(rsp *http.Response) (*GetApi217NfsExportPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NfsExportPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NfsExportPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217NfsExportPoliciesResponse parses an HTTP response from a PatchApi217NfsExportPoliciesWithResponse call
func ParsePatchApi217NfsExportPoliciesResponse(rsp *http.Response) (*PatchApi217NfsExportPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217NfsExportPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NfsExportPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217NfsExportPoliciesResponse parses an HTTP response from a PostApi217NfsExportPoliciesWithResponse call
func ParsePostApi217NfsExportPoliciesResponse(rsp *http.Response) (*PostApi217NfsExportPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217NfsExportPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NfsExportPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217NfsExportPoliciesRulesResponse parses an HTTP response from a DeleteApi217NfsExportPoliciesRulesWithResponse call
func ParseDeleteApi217NfsExportPoliciesRulesResponse(rsp *http.Response) (*DeleteApi217NfsExportPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217NfsExportPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217NfsExportPoliciesRulesResponse parses an HTTP response from a GetApi217NfsExportPoliciesRulesWithResponse call
func ParseGetApi217NfsExportPoliciesRulesResponse(rsp *http.Response) (*GetApi217NfsExportPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217NfsExportPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NfsExportPolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217NfsExportPoliciesRulesResponse parses an HTTP response from a PatchApi217NfsExportPoliciesRulesWithResponse call
func ParsePatchApi217NfsExportPoliciesRulesResponse(rsp *http.Response) (*PatchApi217NfsExportPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217NfsExportPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NfsExportPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217NfsExportPoliciesRulesResponse parses an HTTP response from a PostApi217NfsExportPoliciesRulesWithResponse call
func ParsePostApi217NfsExportPoliciesRulesResponse(rsp *http.Response) (*PostApi217NfsExportPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217NfsExportPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NfsExportPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreAccessKeysResponse parses an HTTP response from a DeleteApi217ObjectStoreAccessKeysWithResponse call
func ParseDeleteApi217ObjectStoreAccessKeysResponse(rsp *http.Response) (*DeleteApi217ObjectStoreAccessKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreAccessKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreAccessKeysResponse parses an HTTP response from a GetApi217ObjectStoreAccessKeysWithResponse call
func ParseGetApi217ObjectStoreAccessKeysResponse(rsp *http.Response) (*GetApi217ObjectStoreAccessKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreAccessKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessKeyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreAccessKeysResponse parses an HTTP response from a PatchApi217ObjectStoreAccessKeysWithResponse call
func ParsePatchApi217ObjectStoreAccessKeysResponse(rsp *http.Response) (*PatchApi217ObjectStoreAccessKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreAccessKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreAccessKeysResponse parses an HTTP response from a PostApi217ObjectStoreAccessKeysWithResponse call
func ParsePostApi217ObjectStoreAccessKeysResponse(rsp *http.Response) (*PostApi217ObjectStoreAccessKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreAccessKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreAccessPoliciesResponse parses an HTTP response from a DeleteApi217ObjectStoreAccessPoliciesWithResponse call
func ParseDeleteApi217ObjectStoreAccessPoliciesResponse(rsp *http.Response) (*DeleteApi217ObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreAccessPoliciesResponse parses an HTTP response from a GetApi217ObjectStoreAccessPoliciesWithResponse call
func ParseGetApi217ObjectStoreAccessPoliciesResponse(rsp *http.Response) (*GetApi217ObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreAccessPoliciesResponse parses an HTTP response from a PatchApi217ObjectStoreAccessPoliciesWithResponse call
func ParsePatchApi217ObjectStoreAccessPoliciesResponse(rsp *http.Response) (*PatchApi217ObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreAccessPoliciesResponse parses an HTTP response from a PostApi217ObjectStoreAccessPoliciesWithResponse call
func ParsePostApi217ObjectStoreAccessPoliciesResponse(rsp *http.Response) (*PostApi217ObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse parses an HTTP response from a DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse call
func ParseDeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse(rsp *http.Response) (*DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse parses an HTTP response from a GetApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse call
func ParseGetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse(rsp *http.Response) (*GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse parses an HTTP response from a PostApi217ObjectStoreAccessPoliciesObjectStoreRolesWithResponse call
func ParsePostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse(rsp *http.Response) (*PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreAccessPoliciesObjectStoreRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse parses an HTTP response from a DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse call
func ParseDeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse(rsp *http.Response) (*DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse parses an HTTP response from a GetApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse call
func ParseGetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse(rsp *http.Response) (*GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse parses an HTTP response from a PostApi217ObjectStoreAccessPoliciesObjectStoreUsersWithResponse call
func ParsePostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse(rsp *http.Response) (*PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreAccessPoliciesObjectStoreUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreAccessPoliciesRulesResponse parses an HTTP response from a DeleteApi217ObjectStoreAccessPoliciesRulesWithResponse call
func ParseDeleteApi217ObjectStoreAccessPoliciesRulesResponse(rsp *http.Response) (*DeleteApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreAccessPoliciesRulesResponse parses an HTTP response from a GetApi217ObjectStoreAccessPoliciesRulesWithResponse call
func ParseGetApi217ObjectStoreAccessPoliciesRulesResponse(rsp *http.Response) (*GetApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessPolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreAccessPoliciesRulesResponse parses an HTTP response from a PatchApi217ObjectStoreAccessPoliciesRulesWithResponse call
func ParsePatchApi217ObjectStoreAccessPoliciesRulesResponse(rsp *http.Response) (*PatchApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreAccessPoliciesRulesResponse parses an HTTP response from a PostApi217ObjectStoreAccessPoliciesRulesWithResponse call
func ParsePostApi217ObjectStoreAccessPoliciesRulesResponse(rsp *http.Response) (*PostApi217ObjectStoreAccessPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreAccessPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ObjectStoreAccessPolicyActionsResponse parses an HTTP response from a GetApi217ObjectStoreAccessPolicyActionsWithResponse call
func ParseGetApi217ObjectStoreAccessPolicyActionsResponse(rsp *http.Response) (*GetApi217ObjectStoreAccessPolicyActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreAccessPolicyActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccessPolicyActionGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreAccountsResponse parses an HTTP response from a DeleteApi217ObjectStoreAccountsWithResponse call
func ParseDeleteApi217ObjectStoreAccountsResponse(rsp *http.Response) (*DeleteApi217ObjectStoreAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreAccountsResponse parses an HTTP response from a GetApi217ObjectStoreAccountsWithResponse call
func ParseGetApi217ObjectStoreAccountsResponse(rsp *http.Response) (*GetApi217ObjectStoreAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccountGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreAccountsResponse parses an HTTP response from a PatchApi217ObjectStoreAccountsWithResponse call
func ParsePatchApi217ObjectStoreAccountsResponse(rsp *http.Response) (*PatchApi217ObjectStoreAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreAccountsResponse parses an HTTP response from a PostApi217ObjectStoreAccountsWithResponse call
func ParsePostApi217ObjectStoreAccountsResponse(rsp *http.Response) (*PostApi217ObjectStoreAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreAccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreRemoteCredentialsResponse parses an HTTP response from a DeleteApi217ObjectStoreRemoteCredentialsWithResponse call
func ParseDeleteApi217ObjectStoreRemoteCredentialsResponse(rsp *http.Response) (*DeleteApi217ObjectStoreRemoteCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreRemoteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreRemoteCredentialsResponse parses an HTTP response from a GetApi217ObjectStoreRemoteCredentialsWithResponse call
func ParseGetApi217ObjectStoreRemoteCredentialsResponse(rsp *http.Response) (*GetApi217ObjectStoreRemoteCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreRemoteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreRemoteCredentialGetResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreRemoteCredentialsResponse parses an HTTP response from a PatchApi217ObjectStoreRemoteCredentialsWithResponse call
func ParsePatchApi217ObjectStoreRemoteCredentialsResponse(rsp *http.Response) (*PatchApi217ObjectStoreRemoteCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreRemoteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreRemoteCredentialsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreRemoteCredentialsResponse parses an HTTP response from a PostApi217ObjectStoreRemoteCredentialsWithResponse call
func ParsePostApi217ObjectStoreRemoteCredentialsResponse(rsp *http.Response) (*PostApi217ObjectStoreRemoteCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreRemoteCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreRemoteCredentialsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreRolesResponse parses an HTTP response from a DeleteApi217ObjectStoreRolesWithResponse call
func ParseDeleteApi217ObjectStoreRolesResponse(rsp *http.Response) (*DeleteApi217ObjectStoreRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreRolesResponse parses an HTTP response from a GetApi217ObjectStoreRolesWithResponse call
func ParseGetApi217ObjectStoreRolesResponse(rsp *http.Response) (*GetApi217ObjectStoreRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreRoleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreRolesResponse parses an HTTP response from a PatchApi217ObjectStoreRolesWithResponse call
func ParsePatchApi217ObjectStoreRolesResponse(rsp *http.Response) (*PatchApi217ObjectStoreRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreRolesResponse parses an HTTP response from a PostApi217ObjectStoreRolesWithResponse call
func ParsePostApi217ObjectStoreRolesResponse(rsp *http.Response) (*PostApi217ObjectStoreRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreRoleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse parses an HTTP response from a DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse call
func ParseDeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse(rsp *http.Response) (*DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse parses an HTTP response from a GetApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse call
func ParseGetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse(rsp *http.Response) (*GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse parses an HTTP response from a PostApi217ObjectStoreRolesObjectStoreAccessPoliciesWithResponse call
func ParsePostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse(rsp *http.Response) (*PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreRolesObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse parses an HTTP response from a GetApi217ObjectStoreRolesObjectStoreTrustPoliciesWithResponse call
func ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse(rsp *http.Response) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreRolesObjectStoreTrustPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreTrustPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse parses an HTTP response from a GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadWithResponse call
func ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse(rsp *http.Response) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreRolesObjectStoreTrustPoliciesDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreTrustPolicyIam
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse parses an HTTP response from a DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse call
func ParseDeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp *http.Response) (*DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse parses an HTTP response from a GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse call
func ParseGetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp *http.Response) (*GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreTrustPolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse parses an HTTP response from a PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse call
func ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp *http.Response) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreTrustPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse parses an HTTP response from a PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesWithResponse call
func ParsePostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse(rsp *http.Response) (*PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreRolesObjectStoreTrustPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreTrustPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse parses an HTTP response from a PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadWithResponse call
func ParsePatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse(rsp *http.Response) (*PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ObjectStoreRolesObjectStoreTrustPoliciesUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreTrustPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreUsersResponse parses an HTTP response from a DeleteApi217ObjectStoreUsersWithResponse call
func ParseDeleteApi217ObjectStoreUsersResponse(rsp *http.Response) (*DeleteApi217ObjectStoreUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreUsersResponse parses an HTTP response from a GetApi217ObjectStoreUsersWithResponse call
func ParseGetApi217ObjectStoreUsersResponse(rsp *http.Response) (*GetApi217ObjectStoreUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreUserGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreUsersResponse parses an HTTP response from a PostApi217ObjectStoreUsersWithResponse call
func ParsePostApi217ObjectStoreUsersResponse(rsp *http.Response) (*PostApi217ObjectStoreUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse parses an HTTP response from a DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse call
func ParseDeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse(rsp *http.Response) (*DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse parses an HTTP response from a GetApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse call
func ParseGetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse(rsp *http.Response) (*GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse parses an HTTP response from a PostApi217ObjectStoreUsersObjectStoreAccessPoliciesWithResponse call
func ParsePostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse(rsp *http.Response) (*PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreUsersObjectStoreAccessPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ObjectStoreVirtualHostsResponse parses an HTTP response from a DeleteApi217ObjectStoreVirtualHostsWithResponse call
func ParseDeleteApi217ObjectStoreVirtualHostsResponse(rsp *http.Response) (*DeleteApi217ObjectStoreVirtualHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ObjectStoreVirtualHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ObjectStoreVirtualHostsResponse parses an HTTP response from a GetApi217ObjectStoreVirtualHostsWithResponse call
func ParseGetApi217ObjectStoreVirtualHostsResponse(rsp *http.Response) (*GetApi217ObjectStoreVirtualHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ObjectStoreVirtualHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreVirtualHostGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ObjectStoreVirtualHostsResponse parses an HTTP response from a PostApi217ObjectStoreVirtualHostsWithResponse call
func ParsePostApi217ObjectStoreVirtualHostsResponse(rsp *http.Response) (*PostApi217ObjectStoreVirtualHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ObjectStoreVirtualHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ObjectStoreVirtualHostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217PasswordPoliciesResponse parses an HTTP response from a GetApi217PasswordPoliciesWithResponse call
func ParseGetApi217PasswordPoliciesResponse(rsp *http.Response) (*GetApi217PasswordPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PasswordPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasswordPoliciesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217PasswordPoliciesResponse parses an HTTP response from a PatchApi217PasswordPoliciesWithResponse call
func ParsePatchApi217PasswordPoliciesResponse(rsp *http.Response) (*PatchApi217PasswordPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217PasswordPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PasswordPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217PoliciesResponse parses an HTTP response from a DeleteApi217PoliciesWithResponse call
func ParseDeleteApi217PoliciesResponse(rsp *http.Response) (*DeleteApi217PoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217PoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217PoliciesResponse parses an HTTP response from a GetApi217PoliciesWithResponse call
func ParseGetApi217PoliciesResponse(rsp *http.Response) (*GetApi217PoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217PoliciesResponse parses an HTTP response from a PatchApi217PoliciesWithResponse call
func ParsePatchApi217PoliciesResponse(rsp *http.Response) (*PatchApi217PoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217PoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217PoliciesResponse parses an HTTP response from a PostApi217PoliciesWithResponse call
func ParsePostApi217PoliciesResponse(rsp *http.Response) (*PostApi217PoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217PoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217PoliciesAllResponse parses an HTTP response from a GetApi217PoliciesAllWithResponse call
func ParseGetApi217PoliciesAllResponse(rsp *http.Response) (*GetApi217PoliciesAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PoliciesAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyBaseGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217PoliciesAllMembersResponse parses an HTTP response from a GetApi217PoliciesAllMembersWithResponse call
func ParseGetApi217PoliciesAllMembersResponse(rsp *http.Response) (*GetApi217PoliciesAllMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PoliciesAllMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberWithRemoteGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217PoliciesFileSystemReplicaLinksResponse parses an HTTP response from a DeleteApi217PoliciesFileSystemReplicaLinksWithResponse call
func ParseDeleteApi217PoliciesFileSystemReplicaLinksResponse(rsp *http.Response) (*DeleteApi217PoliciesFileSystemReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217PoliciesFileSystemReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217PoliciesFileSystemReplicaLinksResponse parses an HTTP response from a GetApi217PoliciesFileSystemReplicaLinksWithResponse call
func ParseGetApi217PoliciesFileSystemReplicaLinksResponse(rsp *http.Response) (*GetApi217PoliciesFileSystemReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PoliciesFileSystemReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberWithRemoteGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217PoliciesFileSystemReplicaLinksResponse parses an HTTP response from a PostApi217PoliciesFileSystemReplicaLinksWithResponse call
func ParsePostApi217PoliciesFileSystemReplicaLinksResponse(rsp *http.Response) (*PostApi217PoliciesFileSystemReplicaLinksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217PoliciesFileSystemReplicaLinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberWithRemoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217PoliciesFileSystemSnapshotsResponse parses an HTTP response from a DeleteApi217PoliciesFileSystemSnapshotsWithResponse call
func ParseDeleteApi217PoliciesFileSystemSnapshotsResponse(rsp *http.Response) (*DeleteApi217PoliciesFileSystemSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217PoliciesFileSystemSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217PoliciesFileSystemSnapshotsResponse parses an HTTP response from a GetApi217PoliciesFileSystemSnapshotsWithResponse call
func ParseGetApi217PoliciesFileSystemSnapshotsResponse(rsp *http.Response) (*GetApi217PoliciesFileSystemSnapshotsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PoliciesFileSystemSnapshotsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyFileSystemSnapshotGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217PoliciesFileSystemsResponse parses an HTTP response from a DeleteApi217PoliciesFileSystemsWithResponse call
func ParseDeleteApi217PoliciesFileSystemsResponse(rsp *http.Response) (*DeleteApi217PoliciesFileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217PoliciesFileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217PoliciesFileSystemsResponse parses an HTTP response from a GetApi217PoliciesFileSystemsWithResponse call
func ParseGetApi217PoliciesFileSystemsResponse(rsp *http.Response) (*GetApi217PoliciesFileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PoliciesFileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217PoliciesFileSystemsResponse parses an HTTP response from a PostApi217PoliciesFileSystemsWithResponse call
func ParsePostApi217PoliciesFileSystemsResponse(rsp *http.Response) (*PostApi217PoliciesFileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217PoliciesFileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberContextResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217PoliciesMembersResponse parses an HTTP response from a GetApi217PoliciesMembersWithResponse call
func ParseGetApi217PoliciesMembersResponse(rsp *http.Response) (*GetApi217PoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberWithRemoteGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217PublicKeysResponse parses an HTTP response from a DeleteApi217PublicKeysWithResponse call
func ParseDeleteApi217PublicKeysResponse(rsp *http.Response) (*DeleteApi217PublicKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217PublicKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217PublicKeysResponse parses an HTTP response from a GetApi217PublicKeysWithResponse call
func ParseGetApi217PublicKeysResponse(rsp *http.Response) (*GetApi217PublicKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PublicKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicKeyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217PublicKeysResponse parses an HTTP response from a PostApi217PublicKeysWithResponse call
func ParsePostApi217PublicKeysResponse(rsp *http.Response) (*PostApi217PublicKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217PublicKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217PublicKeysUsesResponse parses an HTTP response from a GetApi217PublicKeysUsesWithResponse call
func ParseGetApi217PublicKeysUsesResponse(rsp *http.Response) (*GetApi217PublicKeysUsesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217PublicKeysUsesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublicKeyUseGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217QosPoliciesResponse parses an HTTP response from a DeleteApi217QosPoliciesWithResponse call
func ParseDeleteApi217QosPoliciesResponse(rsp *http.Response) (*DeleteApi217QosPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217QosPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217QosPoliciesResponse parses an HTTP response from a GetApi217QosPoliciesWithResponse call
func ParseGetApi217QosPoliciesResponse(rsp *http.Response) (*GetApi217QosPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217QosPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QosPoliciesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217QosPoliciesResponse parses an HTTP response from a PatchApi217QosPoliciesWithResponse call
func ParsePatchApi217QosPoliciesResponse(rsp *http.Response) (*PatchApi217QosPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217QosPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QosPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217QosPoliciesResponse parses an HTTP response from a PostApi217QosPoliciesWithResponse call
func ParsePostApi217QosPoliciesResponse(rsp *http.Response) (*PostApi217QosPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217QosPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QosPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217QosPoliciesFileSystemsResponse parses an HTTP response from a GetApi217QosPoliciesFileSystemsWithResponse call
func ParseGetApi217QosPoliciesFileSystemsResponse(rsp *http.Response) (*GetApi217QosPoliciesFileSystemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217QosPoliciesFileSystemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217QosPoliciesMembersResponse parses an HTTP response from a GetApi217QosPoliciesMembersWithResponse call
func ParseGetApi217QosPoliciesMembersResponse(rsp *http.Response) (*GetApi217QosPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217QosPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217QuotasGroupsResponse parses an HTTP response from a DeleteApi217QuotasGroupsWithResponse call
func ParseDeleteApi217QuotasGroupsResponse(rsp *http.Response) (*DeleteApi217QuotasGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217QuotasGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217QuotasGroupsResponse parses an HTTP response from a GetApi217QuotasGroupsWithResponse call
func ParseGetApi217QuotasGroupsResponse(rsp *http.Response) (*GetApi217QuotasGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217QuotasGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupQuotaGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217QuotasGroupsResponse parses an HTTP response from a PatchApi217QuotasGroupsWithResponse call
func ParsePatchApi217QuotasGroupsResponse(rsp *http.Response) (*PatchApi217QuotasGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217QuotasGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupQuotaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217QuotasGroupsResponse parses an HTTP response from a PostApi217QuotasGroupsWithResponse call
func ParsePostApi217QuotasGroupsResponse(rsp *http.Response) (*PostApi217QuotasGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217QuotasGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupQuotaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217QuotasSettingsResponse parses an HTTP response from a GetApi217QuotasSettingsWithResponse call
func ParseGetApi217QuotasSettingsResponse(rsp *http.Response) (*GetApi217QuotasSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217QuotasSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuotaSettingGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217QuotasSettingsResponse parses an HTTP response from a PatchApi217QuotasSettingsWithResponse call
func ParsePatchApi217QuotasSettingsResponse(rsp *http.Response) (*PatchApi217QuotasSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217QuotasSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuotaSettingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217QuotasUsersResponse parses an HTTP response from a DeleteApi217QuotasUsersWithResponse call
func ParseDeleteApi217QuotasUsersResponse(rsp *http.Response) (*DeleteApi217QuotasUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217QuotasUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217QuotasUsersResponse parses an HTTP response from a GetApi217QuotasUsersWithResponse call
func ParseGetApi217QuotasUsersResponse(rsp *http.Response) (*GetApi217QuotasUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217QuotasUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserQuotaGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217QuotasUsersResponse parses an HTTP response from a PatchApi217QuotasUsersWithResponse call
func ParsePatchApi217QuotasUsersResponse(rsp *http.Response) (*PatchApi217QuotasUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217QuotasUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserQuotaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217QuotasUsersResponse parses an HTTP response from a PostApi217QuotasUsersWithResponse call
func ParsePostApi217QuotasUsersResponse(rsp *http.Response) (*PostApi217QuotasUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217QuotasUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserQuotaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217RapidDataLockingResponse parses an HTTP response from a GetApi217RapidDataLockingWithResponse call
func ParseGetApi217RapidDataLockingResponse(rsp *http.Response) (*GetApi217RapidDataLockingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217RapidDataLockingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RapidDataLockingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217RapidDataLockingResponse parses an HTTP response from a PatchApi217RapidDataLockingWithResponse call
func ParsePatchApi217RapidDataLockingResponse(rsp *http.Response) (*PatchApi217RapidDataLockingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217RapidDataLockingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RapidDataLockingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217RapidDataLockingRotateResponse parses an HTTP response from a PostApi217RapidDataLockingRotateWithResponse call
func ParsePostApi217RapidDataLockingRotateResponse(rsp *http.Response) (*PostApi217RapidDataLockingRotateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217RapidDataLockingRotateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217RapidDataLockingTestResponse parses an HTTP response from a GetApi217RapidDataLockingTestWithResponse call
func ParseGetApi217RapidDataLockingTestResponse(rsp *http.Response) (*GetApi217RapidDataLockingTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217RapidDataLockingTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217RemoteArraysResponse parses an HTTP response from a GetApi217RemoteArraysWithResponse call
func ParseGetApi217RemoteArraysResponse(rsp *http.Response) (*GetApi217RemoteArraysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217RemoteArraysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RemoteArraysResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217RolesResponse parses an HTTP response from a GetApi217RolesWithResponse call
func ParseGetApi217RolesResponse(rsp *http.Response) (*GetApi217RolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217RolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217ServersResponse parses an HTTP response from a DeleteApi217ServersWithResponse call
func ParseDeleteApi217ServersResponse(rsp *http.Response) (*DeleteApi217ServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217ServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217ServersResponse parses an HTTP response from a GetApi217ServersWithResponse call
func ParseGetApi217ServersResponse(rsp *http.Response) (*GetApi217ServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217ServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217ServersResponse parses an HTTP response from a PatchApi217ServersWithResponse call
func ParsePatchApi217ServersResponse(rsp *http.Response) (*PatchApi217ServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217ServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217ServersResponse parses an HTTP response from a PostApi217ServersWithResponse call
func ParsePostApi217ServersResponse(rsp *http.Response) (*PostApi217ServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217ServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SessionsResponse parses an HTTP response from a GetApi217SessionsWithResponse call
func ParseGetApi217SessionsResponse(rsp *http.Response) (*GetApi217SessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SessionGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SmbClientPoliciesResponse parses an HTTP response from a DeleteApi217SmbClientPoliciesWithResponse call
func ParseDeleteApi217SmbClientPoliciesResponse(rsp *http.Response) (*DeleteApi217SmbClientPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SmbClientPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SmbClientPoliciesResponse parses an HTTP response from a GetApi217SmbClientPoliciesWithResponse call
func ParseGetApi217SmbClientPoliciesResponse(rsp *http.Response) (*GetApi217SmbClientPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SmbClientPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbClientPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SmbClientPoliciesResponse parses an HTTP response from a PatchApi217SmbClientPoliciesWithResponse call
func ParsePatchApi217SmbClientPoliciesResponse(rsp *http.Response) (*PatchApi217SmbClientPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SmbClientPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbClientPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SmbClientPoliciesResponse parses an HTTP response from a PostApi217SmbClientPoliciesWithResponse call
func ParsePostApi217SmbClientPoliciesResponse(rsp *http.Response) (*PostApi217SmbClientPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SmbClientPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbClientPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SmbClientPoliciesRulesResponse parses an HTTP response from a DeleteApi217SmbClientPoliciesRulesWithResponse call
func ParseDeleteApi217SmbClientPoliciesRulesResponse(rsp *http.Response) (*DeleteApi217SmbClientPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SmbClientPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SmbClientPoliciesRulesResponse parses an HTTP response from a GetApi217SmbClientPoliciesRulesWithResponse call
func ParseGetApi217SmbClientPoliciesRulesResponse(rsp *http.Response) (*GetApi217SmbClientPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SmbClientPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbClientPolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SmbClientPoliciesRulesResponse parses an HTTP response from a PatchApi217SmbClientPoliciesRulesWithResponse call
func ParsePatchApi217SmbClientPoliciesRulesResponse(rsp *http.Response) (*PatchApi217SmbClientPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SmbClientPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbClientPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SmbClientPoliciesRulesResponse parses an HTTP response from a PostApi217SmbClientPoliciesRulesWithResponse call
func ParsePostApi217SmbClientPoliciesRulesResponse(rsp *http.Response) (*PostApi217SmbClientPoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SmbClientPoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbClientPolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SmbSharePoliciesResponse parses an HTTP response from a DeleteApi217SmbSharePoliciesWithResponse call
func ParseDeleteApi217SmbSharePoliciesResponse(rsp *http.Response) (*DeleteApi217SmbSharePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SmbSharePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SmbSharePoliciesResponse parses an HTTP response from a GetApi217SmbSharePoliciesWithResponse call
func ParseGetApi217SmbSharePoliciesResponse(rsp *http.Response) (*GetApi217SmbSharePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SmbSharePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbSharePolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SmbSharePoliciesResponse parses an HTTP response from a PatchApi217SmbSharePoliciesWithResponse call
func ParsePatchApi217SmbSharePoliciesResponse(rsp *http.Response) (*PatchApi217SmbSharePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SmbSharePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SmbSharePoliciesResponse parses an HTTP response from a PostApi217SmbSharePoliciesWithResponse call
func ParsePostApi217SmbSharePoliciesResponse(rsp *http.Response) (*PostApi217SmbSharePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SmbSharePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbSharePolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SmbSharePoliciesRulesResponse parses an HTTP response from a DeleteApi217SmbSharePoliciesRulesWithResponse call
func ParseDeleteApi217SmbSharePoliciesRulesResponse(rsp *http.Response) (*DeleteApi217SmbSharePoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SmbSharePoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SmbSharePoliciesRulesResponse parses an HTTP response from a GetApi217SmbSharePoliciesRulesWithResponse call
func ParseGetApi217SmbSharePoliciesRulesResponse(rsp *http.Response) (*GetApi217SmbSharePoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SmbSharePoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbSharePolicyRuleGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SmbSharePoliciesRulesResponse parses an HTTP response from a PatchApi217SmbSharePoliciesRulesWithResponse call
func ParsePatchApi217SmbSharePoliciesRulesResponse(rsp *http.Response) (*PatchApi217SmbSharePoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SmbSharePoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbSharePolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SmbSharePoliciesRulesResponse parses an HTTP response from a PostApi217SmbSharePoliciesRulesWithResponse call
func ParsePostApi217SmbSharePoliciesRulesResponse(rsp *http.Response) (*PostApi217SmbSharePoliciesRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SmbSharePoliciesRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmbSharePolicyRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SmtpServersResponse parses an HTTP response from a GetApi217SmtpServersWithResponse call
func ParseGetApi217SmtpServersResponse(rsp *http.Response) (*GetApi217SmtpServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SmtpServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmtpServerGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SmtpServersResponse parses an HTTP response from a PatchApi217SmtpServersWithResponse call
func ParsePatchApi217SmtpServersResponse(rsp *http.Response) (*PatchApi217SmtpServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SmtpServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SmtpServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SnmpAgentsResponse parses an HTTP response from a GetApi217SnmpAgentsWithResponse call
func ParseGetApi217SnmpAgentsResponse(rsp *http.Response) (*GetApi217SnmpAgentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SnmpAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnmpAgentGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SnmpAgentsResponse parses an HTTP response from a PatchApi217SnmpAgentsWithResponse call
func ParsePatchApi217SnmpAgentsResponse(rsp *http.Response) (*PatchApi217SnmpAgentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SnmpAgentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnmpAgentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SnmpAgentsMibResponse parses an HTTP response from a GetApi217SnmpAgentsMibWithResponse call
func ParseGetApi217SnmpAgentsMibResponse(rsp *http.Response) (*GetApi217SnmpAgentsMibResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SnmpAgentsMibResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnmpAgentMibResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SnmpManagersResponse parses an HTTP response from a DeleteApi217SnmpManagersWithResponse call
func ParseDeleteApi217SnmpManagersResponse(rsp *http.Response) (*DeleteApi217SnmpManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SnmpManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SnmpManagersResponse parses an HTTP response from a GetApi217SnmpManagersWithResponse call
func ParseGetApi217SnmpManagersResponse(rsp *http.Response) (*GetApi217SnmpManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SnmpManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnmpManagerGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SnmpManagersResponse parses an HTTP response from a PatchApi217SnmpManagersWithResponse call
func ParsePatchApi217SnmpManagersResponse(rsp *http.Response) (*PatchApi217SnmpManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SnmpManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnmpManagerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SnmpManagersResponse parses an HTTP response from a PostApi217SnmpManagersWithResponse call
func ParsePostApi217SnmpManagersResponse(rsp *http.Response) (*PostApi217SnmpManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SnmpManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnmpManagerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SnmpManagersTestResponse parses an HTTP response from a GetApi217SnmpManagersTestWithResponse call
func ParseGetApi217SnmpManagersTestResponse(rsp *http.Response) (*GetApi217SnmpManagersTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SnmpManagersTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SoftwareCheckResponse parses an HTTP response from a GetApi217SoftwareCheckWithResponse call
func ParseGetApi217SoftwareCheckResponse(rsp *http.Response) (*GetApi217SoftwareCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SoftwareCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SoftwareChecksGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SoftwareCheckResponse parses an HTTP response from a PostApi217SoftwareCheckWithResponse call
func ParsePostApi217SoftwareCheckResponse(rsp *http.Response) (*PostApi217SoftwareCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SoftwareCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SoftwareChecksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SshCertificateAuthorityPoliciesResponse parses an HTTP response from a DeleteApi217SshCertificateAuthorityPoliciesWithResponse call
func ParseDeleteApi217SshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*DeleteApi217SshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SshCertificateAuthorityPoliciesResponse parses an HTTP response from a GetApi217SshCertificateAuthorityPoliciesWithResponse call
func ParseGetApi217SshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*GetApi217SshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SshCertificateAuthorityPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SshCertificateAuthorityPoliciesResponse parses an HTTP response from a PatchApi217SshCertificateAuthorityPoliciesWithResponse call
func ParsePatchApi217SshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*PatchApi217SshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SshCertificateAuthorityPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SshCertificateAuthorityPoliciesResponse parses an HTTP response from a PostApi217SshCertificateAuthorityPoliciesWithResponse call
func ParsePostApi217SshCertificateAuthorityPoliciesResponse(rsp *http.Response) (*PostApi217SshCertificateAuthorityPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SshCertificateAuthorityPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SshCertificateAuthorityPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SshCertificateAuthorityPoliciesAdminsResponse parses an HTTP response from a DeleteApi217SshCertificateAuthorityPoliciesAdminsWithResponse call
func ParseDeleteApi217SshCertificateAuthorityPoliciesAdminsResponse(rsp *http.Response) (*DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SshCertificateAuthorityPoliciesAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SshCertificateAuthorityPoliciesAdminsResponse parses an HTTP response from a GetApi217SshCertificateAuthorityPoliciesAdminsWithResponse call
func ParseGetApi217SshCertificateAuthorityPoliciesAdminsResponse(rsp *http.Response) (*GetApi217SshCertificateAuthorityPoliciesAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SshCertificateAuthorityPoliciesAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SshCertificateAuthorityPoliciesAdminsResponse parses an HTTP response from a PostApi217SshCertificateAuthorityPoliciesAdminsWithResponse call
func ParsePostApi217SshCertificateAuthorityPoliciesAdminsResponse(rsp *http.Response) (*PostApi217SshCertificateAuthorityPoliciesAdminsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SshCertificateAuthorityPoliciesAdminsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SshCertificateAuthorityPoliciesArraysResponse parses an HTTP response from a DeleteApi217SshCertificateAuthorityPoliciesArraysWithResponse call
func ParseDeleteApi217SshCertificateAuthorityPoliciesArraysResponse(rsp *http.Response) (*DeleteApi217SshCertificateAuthorityPoliciesArraysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SshCertificateAuthorityPoliciesArraysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SshCertificateAuthorityPoliciesArraysResponse parses an HTTP response from a GetApi217SshCertificateAuthorityPoliciesArraysWithResponse call
func ParseGetApi217SshCertificateAuthorityPoliciesArraysResponse(rsp *http.Response) (*GetApi217SshCertificateAuthorityPoliciesArraysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SshCertificateAuthorityPoliciesArraysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SshCertificateAuthorityPoliciesArraysResponse parses an HTTP response from a PostApi217SshCertificateAuthorityPoliciesArraysWithResponse call
func ParsePostApi217SshCertificateAuthorityPoliciesArraysResponse(rsp *http.Response) (*PostApi217SshCertificateAuthorityPoliciesArraysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SshCertificateAuthorityPoliciesArraysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SshCertificateAuthorityPoliciesMembersResponse parses an HTTP response from a GetApi217SshCertificateAuthorityPoliciesMembersWithResponse call
func ParseGetApi217SshCertificateAuthorityPoliciesMembersResponse(rsp *http.Response) (*GetApi217SshCertificateAuthorityPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SshCertificateAuthorityPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SsoOidcIdpsResponse parses an HTTP response from a DeleteApi217SsoOidcIdpsWithResponse call
func ParseDeleteApi217SsoOidcIdpsResponse(rsp *http.Response) (*DeleteApi217SsoOidcIdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SsoOidcIdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SsoOidcIdpsResponse parses an HTTP response from a GetApi217SsoOidcIdpsWithResponse call
func ParseGetApi217SsoOidcIdpsResponse(rsp *http.Response) (*GetApi217SsoOidcIdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SsoOidcIdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcSsoGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SsoOidcIdpsResponse parses an HTTP response from a PatchApi217SsoOidcIdpsWithResponse call
func ParsePatchApi217SsoOidcIdpsResponse(rsp *http.Response) (*PatchApi217SsoOidcIdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SsoOidcIdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcSsoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SsoOidcIdpsResponse parses an HTTP response from a PostApi217SsoOidcIdpsWithResponse call
func ParsePostApi217SsoOidcIdpsResponse(rsp *http.Response) (*PostApi217SsoOidcIdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SsoOidcIdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OidcSsoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SsoSaml2IdpsResponse parses an HTTP response from a DeleteApi217SsoSaml2IdpsWithResponse call
func ParseDeleteApi217SsoSaml2IdpsResponse(rsp *http.Response) (*DeleteApi217SsoSaml2IdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SsoSaml2IdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SsoSaml2IdpsResponse parses an HTTP response from a GetApi217SsoSaml2IdpsWithResponse call
func ParseGetApi217SsoSaml2IdpsResponse(rsp *http.Response) (*GetApi217SsoSaml2IdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SsoSaml2IdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Saml2SsoGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SsoSaml2IdpsResponse parses an HTTP response from a PatchApi217SsoSaml2IdpsWithResponse call
func ParsePatchApi217SsoSaml2IdpsResponse(rsp *http.Response) (*PatchApi217SsoSaml2IdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SsoSaml2IdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Saml2SsoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SsoSaml2IdpsResponse parses an HTTP response from a PostApi217SsoSaml2IdpsWithResponse call
func ParsePostApi217SsoSaml2IdpsResponse(rsp *http.Response) (*PostApi217SsoSaml2IdpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SsoSaml2IdpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Saml2SsoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SsoSaml2IdpsTestResponse parses an HTTP response from a GetApi217SsoSaml2IdpsTestWithResponse call
func ParseGetApi217SsoSaml2IdpsTestResponse(rsp *http.Response) (*GetApi217SsoSaml2IdpsTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SsoSaml2IdpsTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SsoSaml2IdpsTestResponse parses an HTTP response from a PatchApi217SsoSaml2IdpsTestWithResponse call
func ParsePatchApi217SsoSaml2IdpsTestResponse(rsp *http.Response) (*PatchApi217SsoSaml2IdpsTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SsoSaml2IdpsTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SubnetsResponse parses an HTTP response from a DeleteApi217SubnetsWithResponse call
func ParseDeleteApi217SubnetsResponse(rsp *http.Response) (*DeleteApi217SubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SubnetsResponse parses an HTTP response from a GetApi217SubnetsWithResponse call
func ParseGetApi217SubnetsResponse(rsp *http.Response) (*GetApi217SubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubnetGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SubnetsResponse parses an HTTP response from a PatchApi217SubnetsWithResponse call
func ParsePatchApi217SubnetsResponse(rsp *http.Response) (*PatchApi217SubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubnetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SubnetsResponse parses an HTTP response from a PostApi217SubnetsWithResponse call
func ParsePostApi217SubnetsResponse(rsp *http.Response) (*PostApi217SubnetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SubnetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubnetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SupportResponse parses an HTTP response from a GetApi217SupportWithResponse call
func ParseGetApi217SupportResponse(rsp *http.Response) (*GetApi217SupportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SupportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SupportResponse parses an HTTP response from a PatchApi217SupportWithResponse call
func ParsePatchApi217SupportResponse(rsp *http.Response) (*PatchApi217SupportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SupportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SupportDiagnosticsResponse parses an HTTP response from a GetApi217SupportDiagnosticsWithResponse call
func ParseGetApi217SupportDiagnosticsResponse(rsp *http.Response) (*GetApi217SupportDiagnosticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SupportDiagnosticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportDiagnosticsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SupportDiagnosticsResponse parses an HTTP response from a PostApi217SupportDiagnosticsWithResponse call
func ParsePostApi217SupportDiagnosticsResponse(rsp *http.Response) (*PostApi217SupportDiagnosticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SupportDiagnosticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportDiagnosticsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SupportDiagnosticsDetailsResponse parses an HTTP response from a GetApi217SupportDiagnosticsDetailsWithResponse call
func ParseGetApi217SupportDiagnosticsDetailsResponse(rsp *http.Response) (*GetApi217SupportDiagnosticsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SupportDiagnosticsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportDiagnosticsDetailsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SupportTestResponse parses an HTTP response from a GetApi217SupportTestWithResponse call
func ParseGetApi217SupportTestResponse(rsp *http.Response) (*GetApi217SupportTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SupportTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SupportVerificationKeysResponse parses an HTTP response from a GetApi217SupportVerificationKeysWithResponse call
func ParseGetApi217SupportVerificationKeysResponse(rsp *http.Response) (*GetApi217SupportVerificationKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SupportVerificationKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationKeyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SupportVerificationKeysResponse parses an HTTP response from a PatchApi217SupportVerificationKeysWithResponse call
func ParsePatchApi217SupportVerificationKeysResponse(rsp *http.Response) (*PatchApi217SupportVerificationKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SupportVerificationKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerificationKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217SyslogServersResponse parses an HTTP response from a DeleteApi217SyslogServersWithResponse call
func ParseDeleteApi217SyslogServersResponse(rsp *http.Response) (*DeleteApi217SyslogServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217SyslogServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217SyslogServersResponse parses an HTTP response from a GetApi217SyslogServersWithResponse call
func ParseGetApi217SyslogServersResponse(rsp *http.Response) (*GetApi217SyslogServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SyslogServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyslogServerGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SyslogServersResponse parses an HTTP response from a PatchApi217SyslogServersWithResponse call
func ParsePatchApi217SyslogServersResponse(rsp *http.Response) (*PatchApi217SyslogServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SyslogServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyslogServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217SyslogServersResponse parses an HTTP response from a PostApi217SyslogServersWithResponse call
func ParsePostApi217SyslogServersResponse(rsp *http.Response) (*PostApi217SyslogServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217SyslogServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyslogServerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SyslogServersSettingsResponse parses an HTTP response from a GetApi217SyslogServersSettingsWithResponse call
func ParseGetApi217SyslogServersSettingsResponse(rsp *http.Response) (*GetApi217SyslogServersSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SyslogServersSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyslogServerSettingsGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217SyslogServersSettingsResponse parses an HTTP response from a PatchApi217SyslogServersSettingsWithResponse call
func ParsePatchApi217SyslogServersSettingsResponse(rsp *http.Response) (*PatchApi217SyslogServersSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217SyslogServersSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyslogServerSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217SyslogServersTestResponse parses an HTTP response from a GetApi217SyslogServersTestWithResponse call
func ParseGetApi217SyslogServersTestResponse(rsp *http.Response) (*GetApi217SyslogServersTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217SyslogServersTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResultGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217TargetsResponse parses an HTTP response from a DeleteApi217TargetsWithResponse call
func ParseDeleteApi217TargetsResponse(rsp *http.Response) (*DeleteApi217TargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217TargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217TargetsResponse parses an HTTP response from a GetApi217TargetsWithResponse call
func ParseGetApi217TargetsResponse(rsp *http.Response) (*GetApi217TargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217TargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217TargetsResponse parses an HTTP response from a PatchApi217TargetsWithResponse call
func ParsePatchApi217TargetsResponse(rsp *http.Response) (*PatchApi217TargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217TargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217TargetsResponse parses an HTTP response from a PostApi217TargetsWithResponse call
func ParsePostApi217TargetsResponse(rsp *http.Response) (*PostApi217TargetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217TargetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TargetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217TargetsPerformanceReplicationResponse parses an HTTP response from a GetApi217TargetsPerformanceReplicationWithResponse call
func ParseGetApi217TargetsPerformanceReplicationResponse(rsp *http.Response) (*GetApi217TargetsPerformanceReplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217TargetsPerformanceReplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourcePerformanceReplicationGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217TlsPoliciesResponse parses an HTTP response from a DeleteApi217TlsPoliciesWithResponse call
func ParseDeleteApi217TlsPoliciesResponse(rsp *http.Response) (*DeleteApi217TlsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217TlsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217TlsPoliciesResponse parses an HTTP response from a GetApi217TlsPoliciesWithResponse call
func ParseGetApi217TlsPoliciesResponse(rsp *http.Response) (*GetApi217TlsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217TlsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsPolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217TlsPoliciesResponse parses an HTTP response from a PatchApi217TlsPoliciesWithResponse call
func ParsePatchApi217TlsPoliciesResponse(rsp *http.Response) (*PatchApi217TlsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217TlsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217TlsPoliciesResponse parses an HTTP response from a PostApi217TlsPoliciesWithResponse call
func ParsePostApi217TlsPoliciesResponse(rsp *http.Response) (*PostApi217TlsPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217TlsPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TlsPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217TlsPoliciesMembersResponse parses an HTTP response from a GetApi217TlsPoliciesMembersWithResponse call
func ParseGetApi217TlsPoliciesMembersResponse(rsp *http.Response) (*GetApi217TlsPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217TlsPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217TlsPoliciesNetworkInterfacesResponse parses an HTTP response from a DeleteApi217TlsPoliciesNetworkInterfacesWithResponse call
func ParseDeleteApi217TlsPoliciesNetworkInterfacesResponse(rsp *http.Response) (*DeleteApi217TlsPoliciesNetworkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217TlsPoliciesNetworkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217TlsPoliciesNetworkInterfacesResponse parses an HTTP response from a GetApi217TlsPoliciesNetworkInterfacesWithResponse call
func ParseGetApi217TlsPoliciesNetworkInterfacesResponse(rsp *http.Response) (*GetApi217TlsPoliciesNetworkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217TlsPoliciesNetworkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217TlsPoliciesNetworkInterfacesResponse parses an HTTP response from a PostApi217TlsPoliciesNetworkInterfacesWithResponse call
func ParsePostApi217TlsPoliciesNetworkInterfacesResponse(rsp *http.Response) (*PostApi217TlsPoliciesNetworkInterfacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217TlsPoliciesNetworkInterfacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PolicyMemberResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217UsageGroupsResponse parses an HTTP response from a GetApi217UsageGroupsWithResponse call
func ParseGetApi217UsageGroupsResponse(rsp *http.Response) (*GetApi217UsageGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217UsageGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupQuotaGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217UsageUsersResponse parses an HTTP response from a GetApi217UsageUsersWithResponse call
func ParseGetApi217UsageUsersResponse(rsp *http.Response) (*GetApi217UsageUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217UsageUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserQuotaGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteApi217WormDataPoliciesResponse parses an HTTP response from a DeleteApi217WormDataPoliciesWithResponse call
func ParseDeleteApi217WormDataPoliciesResponse(rsp *http.Response) (*DeleteApi217WormDataPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApi217WormDataPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetApi217WormDataPoliciesResponse parses an HTTP response from a GetApi217WormDataPoliciesWithResponse call
func ParseGetApi217WormDataPoliciesResponse(rsp *http.Response) (*GetApi217WormDataPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217WormDataPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WormDataPoliciesGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchApi217WormDataPoliciesResponse parses an HTTP response from a PatchApi217WormDataPoliciesWithResponse call
func ParsePatchApi217WormDataPoliciesResponse(rsp *http.Response) (*PatchApi217WormDataPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApi217WormDataPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WormDataPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApi217WormDataPoliciesResponse parses an HTTP response from a PostApi217WormDataPoliciesWithResponse call
func ParsePostApi217WormDataPoliciesResponse(rsp *http.Response) (*PostApi217WormDataPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApi217WormDataPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WormDataPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApi217WormDataPoliciesMembersResponse parses an HTTP response from a GetApi217WormDataPoliciesMembersWithResponse call
func ParseGetApi217WormDataPoliciesMembersResponse(rsp *http.Response) (*GetApi217WormDataPoliciesMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApi217WormDataPoliciesMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WormDataPoliciesMembersGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiApiVersionResponse parses an HTTP response from a GetApiApiVersionWithResponse call
func ParseGetApiApiVersionResponse(rsp *http.Response) (*GetApiApiVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiApiVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApiLoginResponse parses an HTTP response from a PostApiLoginWithResponse call
func ParsePostApiLoginResponse(rsp *http.Response) (*PostApiLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Login
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetApiLoginBannerResponse parses an HTTP response from a GetApiLoginBannerWithResponse call
func ParseGetApiLoginBannerResponse(rsp *http.Response) (*GetApiLoginBannerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiLoginBannerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginBannerGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostApiLogoutResponse parses an HTTP response from a PostApiLogoutWithResponse call
func ParsePostApiLogoutResponse(rsp *http.Response) (*PostApiLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostApiLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostOauth210TokenResponse parses an HTTP response from a PostOauth210TokenWithResponse call
func ParsePostOauth210TokenResponse(rsp *http.Response) (*PostOauth210TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOauth210TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OauthToken200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest OauthToken400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OauthToken401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
